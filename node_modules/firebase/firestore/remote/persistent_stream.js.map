{"version":3,"sources":["src/firestore/remote/persistent_stream.ts","firestore/remote/persistent_stream.js"],"names":["log","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","LOG_TAG","PersistentStreamState","BACKOFF_INITIAL_DELAY_MS","BACKOFF_MAX_DELAY_MS","BACKOFF_FACTOR","PersistentStream","queue","connection","credentialsProvider","listener","initialBackoffDelay","stream","backoff","state","Initial","isStarted","Backoff","Auth","Open","isOpen","start","Error","performBackoff","auth","stop","Stopped","close","inhibitBackoff","reset","_this","getToken","then","token","startStream","error","schedule","rpcError","UNKNOWN","message","handleStreamClose","resolve","dispatchIfNotStopped","fn","startRpc","onOpen","onClose","onMessage","msg","backoffAndWait","debug","code","RESOURCE_EXHAUSTED","resetToMax","PersistentListenStream","_super","databaseInfo","credentials","serializer","call","openStream","watchChangeProto","watchChange","fromWatchChange","snapshot","versionFromListenResponse","onWatchChange","watch","queryData","request","database","encodedDatabaseId","addTarget","toTarget","labels","toListenRequestLabels","send","unwatch","targetId","removeTarget","PersistentWriteStream","handshakeComplete_","defineProperty","get","enumerable","configurable","responseProto","streamToken","lastStreamToken","writeResults","length","onHandshakeComplete","results","fromWriteResults","commitVersion","fromVersion","commitTime","onMutationResult","writeHandshake","writeMutations","mutations","writes","map","mutation","toMutation"],"mappings":"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","file":"persistent_stream.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { CredentialsProvider, Token } from '../api/credentials';\nimport { DatabaseInfo } from '../core/database_info';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData } from '../local/query_data';\nimport { Mutation, MutationResult } from '../model/mutation';\nimport { assert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { ExponentialBackoff } from './backoff';\nimport { Connection, Stream } from './connection';\nimport { JsonProtoSerializer } from './serializer';\nimport { WatchChange } from './watch_change';\n\nconst LOG_TAG = 'PersistentStream';\n\n// The generated proto interfaces for these class are missing the database\n// field. So we add it here.\n// TODO(b/36015800): Remove this once the api generator is fixed.\ninterface ListenRequest extends api.ListenRequest {\n  database?: string;\n}\nexport interface WriteRequest extends api.WriteRequest {\n  database?: string;\n}\n\nenum PersistentStreamState {\n  /**\n   * The streaming RPC is not running and there's no error condition.\n   * Calling `start` will start the stream immediately without backoff.\n   * While in this state isStarted will return false.\n   */\n  Initial,\n\n  /**\n   * The stream is starting, and is waiting for an auth token to attach to\n   * the initial request. While in this state, isStarted will return\n   * true but isOpen will return false.\n   */\n  Auth,\n\n  /**\n   * The streaming RPC is up and running. Requests and responses can flow\n   * freely. Both isStarted and isOpen will return true.\n   */\n  Open,\n\n  /**\n   * The stream encountered an error. The next start attempt will back off.\n   * While in this state isStarted() will return false.\n   *\n   */\n  Error,\n\n  /**\n   * An in-between state after an error where the stream is waiting before\n   * re-starting. After\n   * waiting is complete, the stream will try to open. While in this\n   * state isStarted() will return YES but isOpen will return false.\n   */\n  Backoff,\n\n  /**\n   * The stream has been explicitly stopped; no further events will be emitted.\n   */\n  Stopped\n}\n\n/**\n * Provides a common interface that is shared by the listeners for stream\n * events by the concrete implementation classes.\n */\nexport interface PersistentStreamListener {\n  /**\n   * Called after the stream was established and can accept outgoing\n   * messages\n   */\n  onOpen: () => Promise<void>;\n  /**\n   * Called after the stream has closed. If there was an error, the\n   * FirestoreError will be set.\n   */\n  onClose: (err?: FirestoreError) => Promise<void>;\n}\n\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst BACKOFF_INITIAL_DELAY_MS = 1000;\n\n/** Maximum backoff time in milliseconds */\nconst BACKOFF_MAX_DELAY_MS = 60 * 1000;\n\nconst BACKOFF_FACTOR = 1.5;\n\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nexport abstract class PersistentStream<\n  SendType,\n  ReceiveType,\n  ListenerType extends PersistentStreamListener\n> {\n  private state: PersistentStreamState;\n\n  protected stream: Stream<SendType, ReceiveType> | null = null;\n\n  protected backoff: ExponentialBackoff;\n\n  protected listener: ListenerType | null = null;\n\n  constructor(\n    private queue: AsyncQueue,\n    protected connection: Connection,\n    private credentialsProvider: CredentialsProvider,\n    listener: ListenerType,\n    // Used for faster retries in testing\n    initialBackoffDelay?: number\n  ) {\n    this.backoff = new ExponentialBackoff(\n      initialBackoffDelay ? initialBackoffDelay : BACKOFF_INITIAL_DELAY_MS,\n      BACKOFF_FACTOR,\n      BACKOFF_MAX_DELAY_MS\n    );\n    this.state = PersistentStreamState.Initial;\n    this.listener = listener;\n  }\n\n  /**\n   * Returns true if `start` has been called and no error has occurred. True\n   * indicates the stream is open or in the process of opening (which\n   * encompasses respecting backoff, getting auth tokens, and starting the\n   * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n   * outbound requests.\n   */\n  isStarted(): boolean {\n    return (\n      this.state === PersistentStreamState.Backoff ||\n      this.state === PersistentStreamState.Auth ||\n      this.state === PersistentStreamState.Open\n    );\n  }\n\n  /**\n   * Returns true if the underlying RPC is open (the openHandler has been\n   * called) and the stream is ready for outbound requests.\n   */\n  isOpen(): boolean {\n    return this.state === PersistentStreamState.Open;\n  }\n\n  /**\n   * Starts the RPC. Only allowed if isStarted returns false. The stream is\n   * not immediately ready for use: onOpen will be invoked when the RPC is ready\n   * for outbound requests, at which point isOpen will return true.\n   *\n   *  When start returns, isStarted will return true.\n   */\n  start(): void {\n    if (this.state === PersistentStreamState.Error) {\n      this.performBackoff();\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Initial, 'Already started');\n\n    this.auth();\n  }\n\n  /**\n   * Stops the RPC. This call is idempotent and allowed regardless of the\n   * current isStarted state.\n   *\n   * When stop returns, isStarted and isOpen will both return false.\n   */\n  stop(): void {\n    // Prevent any possible future restart of this stream\n    this.state = PersistentStreamState.Stopped;\n\n    // Clear the listener to avoid bleeding of events from the underlying\n    // streams\n    this.listener = null;\n\n    // Clean up the underlying stream because we are no longer interested in\n    // events\n    if (this.stream !== null) {\n      this.stream.close();\n      this.stream = null;\n    }\n  }\n\n  /**\n   * After an error the stream will usually back off on the next attempt to\n   * start it. If the error warrants an immediate restart of the stream, the\n   * sender can use this to indicate that the receiver should not back off.\n   *\n   * Each error will call the onClose function. That function can decide to\n   * inhibit backoff if required.\n   */\n  inhibitBackoff(): void {\n    assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n\n    this.state = PersistentStreamState.Initial;\n    this.backoff.reset();\n  }\n\n  /**\n   * Used by subclasses to start the concrete RPC and return the underlying\n   * connection stream.\n   */\n  protected abstract startRpc(\n    token: Token | null\n  ): Stream<SendType, ReceiveType>;\n\n  /**\n   * Called after the stream has received a message. The function will be\n   * called on the right queue and must return a Promise.\n   * @param message The message received from the stream.\n   */\n  protected abstract onMessage(message: ReceiveType): Promise<void>;\n\n  private auth(): void {\n    assert(\n      this.state === PersistentStreamState.Initial,\n      'Must be in initial state to auth'\n    );\n\n    this.state = PersistentStreamState.Auth;\n\n    this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(\n      token => {\n        // Normally we'd have to schedule the callback on the AsyncQueue.\n        // However, the following calls are safe to be called outside the\n        // AsyncQueue since they don't chain asynchronous calls\n        this.startStream(token);\n      },\n      (error: Error) => {\n        this.queue.schedule(() => {\n          if (this.state !== PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            const rpcError = new FirestoreError(\n              Code.UNKNOWN,\n              'Fetching auth token failed: ' + error.message\n            );\n            return this.handleStreamClose(rpcError);\n          } else {\n            return Promise.resolve();\n          }\n        });\n      }\n    );\n  }\n\n  private startStream(token: Token | null): void {\n    if (this.state === PersistentStreamState.Stopped) {\n      // Stream can be stopped while waiting for authorization.\n      return;\n    }\n\n    assert(\n      this.state === PersistentStreamState.Auth,\n      'Trying to start stream in a non-auth state'\n    );\n    // Helper function to dispatch to AsyncQueue and make sure that any\n    // close will seem instantaneous and events are prevented from being\n    // raised after the close call\n    const dispatchIfNotStopped = (fn: () => Promise<void>) => {\n      this.queue.schedule(() => {\n        // Only raise events if the listener has not changed\n        if (this.state !== PersistentStreamState.Stopped) {\n          return fn();\n        } else {\n          return Promise.resolve();\n        }\n      });\n    };\n\n    // Only start stream if listener has not changed\n    if (this.listener !== null) {\n      this.stream = this.startRpc(token);\n      this.stream.onOpen(() => {\n        dispatchIfNotStopped(() => {\n          assert(\n            this.state === PersistentStreamState.Auth,\n            'Expected stream to be in state auth, but was ' + this.state\n          );\n          this.state = PersistentStreamState.Open;\n          return this.listener!.onOpen();\n        });\n      });\n      this.stream.onClose((error: FirestoreError) => {\n        dispatchIfNotStopped(() => {\n          return this.handleStreamClose(error);\n        });\n      });\n      this.stream.onMessage((msg: ReceiveType) => {\n        dispatchIfNotStopped(() => {\n          return this.onMessage(msg);\n        });\n      });\n    }\n  }\n\n  private performBackoff(): void {\n    assert(\n      this.state === PersistentStreamState.Error,\n      'Should only perform backoff in an error case'\n    );\n    this.state = PersistentStreamState.Backoff;\n\n    this.backoff.backoffAndWait().then(() => {\n      // Backoff does not run on the AsyncQueue, so we need to reschedule to\n      // make sure the queue blocks\n      this.queue.schedule(() => {\n        if (this.state === PersistentStreamState.Stopped) {\n          // Stream can be stopped while waiting for backoff to complete.\n          return Promise.resolve();\n        }\n\n        this.state = PersistentStreamState.Initial;\n        this.start();\n        assert(this.isStarted(), 'PersistentStream should have started');\n        return Promise.resolve();\n      });\n    });\n  }\n\n  private handleStreamClose(error?: FirestoreError): Promise<void> {\n    assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n    log.debug(LOG_TAG, `close with error: ${error}`);\n\n    this.stream = null;\n\n    // In theory the stream could close cleanly, however, in our current model\n    // we never expect this to happen because if we stop a stream ourselves,\n    // this callback will never be called. To prevent cases where we retry\n    // without a backoff accidentally, we set the stream to error in all cases.\n    this.state = PersistentStreamState.Error;\n\n    if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n      log.debug(\n        LOG_TAG,\n        'Using maximum backoff delay to prevent overloading the backend.'\n      );\n      this.backoff.resetToMax();\n    }\n\n    return this.listener!.onClose(error);\n  }\n}\n\n/** Listener for the PersistentWatchStream */\nexport interface WatchStreamListener extends PersistentStreamListener {\n  /**\n   * Called on a watchChange. The snapshot parameter will be MIN if the watch\n   * change did not have a snapshot associated with it.\n   */\n  onWatchChange: (\n    watchChange: WatchChange,\n    snapshot: SnapshotVersion\n  ) => Promise<void>;\n}\n\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nexport class PersistentListenStream extends PersistentStream<\n  api.ListenRequest,\n  api.ListenResponse,\n  WatchStreamListener\n> {\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    listener: WatchStreamListener,\n    initialBackoffDelay?: number\n  ) {\n    super(queue, connection, credentials, listener, initialBackoffDelay);\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.ListenRequest, api.ListenResponse> {\n    return this.connection.openStream('Listen', token);\n  }\n\n  protected onMessage(watchChangeProto: api.ListenResponse): Promise<void> {\n    // A successful response means the stream is healthy\n    this.backoff.reset();\n\n    const watchChange = this.serializer.fromWatchChange(watchChangeProto);\n    const snapshot = this.serializer.versionFromListenResponse(\n      watchChangeProto\n    );\n    return this.listener!.onWatchChange(watchChange, snapshot);\n  }\n\n  /**\n   * Registers interest in the results of the given query. If the query\n   * includes a resumeToken it will be included in the request. Results that\n   * affect the query will be streamed back as WatchChange messages that\n   * reference the targetId.\n   */\n  watch(queryData: QueryData): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.addTarget = this.serializer.toTarget(queryData);\n\n    const labels = this.serializer.toListenRequestLabels(queryData);\n    if (labels) {\n      request.labels = labels;\n    }\n\n    this.stream!.send(request);\n  }\n\n  /**\n   * Unregisters interest in the results of the query associated with the\n   * given targetId.\n   */\n  unwatch(targetId: TargetId): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.removeTarget = targetId;\n    this.stream!.send(request);\n  }\n}\n\n/** Listener for the PersistentWriteStream */\nexport interface WriteStreamListener extends PersistentStreamListener {\n  /**\n   * Called by the PersistentWriteStream upon a successful handshake response\n   * from the server, which is the receiver's cue to send any pending writes.\n   */\n  onHandshakeComplete: () => Promise<void>;\n\n  /**\n   * Called by the PersistentWriteStream upon receiving a StreamingWriteResponse\n   * from the server that contains a mutation result.\n   */\n  onMutationResult: (\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ) => Promise<void>;\n}\n\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nexport class PersistentWriteStream extends PersistentStream<\n  api.WriteRequest,\n  api.WriteResponse,\n  WriteStreamListener\n> {\n  private handshakeComplete_ = false;\n\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    listener: WriteStreamListener,\n    initialBackoffDelay?: number\n  ) {\n    super(queue, connection, credentials, listener, initialBackoffDelay);\n  }\n\n  /**\n   * The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   *\n   * PersistentWriteStream manages propagating this value from responses to the\n   * next request.\n   */\n  public lastStreamToken: ProtoByteString;\n\n  /**\n   * Tracks whether or not a handshake has been successfully exchanged and\n   * the stream is ready to accept mutations.\n   */\n  get handshakeComplete(): boolean {\n    return this.handshakeComplete_;\n  }\n\n  // Override of PersistentStream.start\n  start(): void {\n    this.handshakeComplete_ = false;\n    super.start();\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.WriteRequest, api.WriteResponse> {\n    return this.connection.openStream('Write', token);\n  }\n\n  protected onMessage(responseProto: api.WriteResponse): Promise<void> {\n    // Always capture the last stream token.\n    assert(\n      !!responseProto.streamToken,\n      'Got a write response without a stream token'\n    );\n    this.lastStreamToken = responseProto.streamToken!;\n\n    if (!this.handshakeComplete_) {\n      // The first response is always the handshake response\n      assert(\n        !responseProto.writeResults || responseProto.writeResults.length === 0,\n        'Got mutation results for handshake'\n      );\n      this.handshakeComplete_ = true;\n      return this.listener!.onHandshakeComplete();\n    } else {\n      // A successful first write response means the stream is healthy,\n      // Note, that we could consider a successful handshake healthy, however,\n      // the write itself might be causing an error we want to back off from.\n      this.backoff.reset();\n\n      const results = this.serializer.fromWriteResults(\n        responseProto.writeResults\n      );\n      const commitVersion = this.serializer.fromVersion(\n        responseProto.commitTime!\n      );\n      return this.listener!.onMutationResult(commitVersion, results);\n    }\n  }\n\n  /**\n   * Sends an initial streamToken to the server, performing the handshake\n   * required to make the StreamingWrite RPC work. Subsequent\n   * calls should wait until onHandshakeComplete was called.\n   */\n  writeHandshake(): void {\n    assert(this.isOpen(), 'Writing handshake requires an opened stream');\n    assert(!this.handshakeComplete_, 'Handshake already completed');\n    // TODO(dimond): Support stream resumption. We intentionally do not set the\n    // stream token on the handshake, ignoring any stream token we might have.\n    const request: WriteRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    this.stream!.send(request);\n  }\n\n  /** Sends a group of mutations to the Firestore backend to apply. */\n  writeMutations(mutations: Mutation[]): void {\n    assert(this.isOpen(), 'Writing mutations requires an opened stream');\n    assert(\n      this.handshakeComplete_,\n      'Handshake must be complete before writing mutations'\n    );\n    assert(\n      this.lastStreamToken.length > 0,\n      'Trying to write mutation without a token'\n    );\n\n    const request: WriteRequest = {\n      // Protos are typed with string, but we support UInt8Array on Node\n      // tslint:disable-next-line:no-any\n      streamToken: this.lastStreamToken as any,\n      writes: mutations.map(mutation => this.serializer.toMutation(mutation))\n    };\n\n    this.stream!.send(request);\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { PromiseImpl as Promise } from '../../utils/promise';\nimport { ExponentialBackoff } from './backoff';\nvar LOG_TAG = 'PersistentStream';\nvar PersistentStreamState;\n(function (PersistentStreamState) {\n    /**\n     * The streaming RPC is not running and there's no error condition.\n     * Calling `start` will start the stream immediately without backoff.\n     * While in this state isStarted will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Initial\"] = 0] = \"Initial\";\n    /**\n     * The stream is starting, and is waiting for an auth token to attach to\n     * the initial request. While in this state, isStarted will return\n     * true but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Auth\"] = 1] = \"Auth\";\n    /**\n     * The streaming RPC is up and running. Requests and responses can flow\n     * freely. Both isStarted and isOpen will return true.\n     */\n    PersistentStreamState[PersistentStreamState[\"Open\"] = 2] = \"Open\";\n    /**\n     * The stream encountered an error. The next start attempt will back off.\n     * While in this state isStarted() will return false.\n     *\n     */\n    PersistentStreamState[PersistentStreamState[\"Error\"] = 3] = \"Error\";\n    /**\n     * An in-between state after an error where the stream is waiting before\n     * re-starting. After\n     * waiting is complete, the stream will try to open. While in this\n     * state isStarted() will return YES but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Backoff\"] = 4] = \"Backoff\";\n    /**\n     * The stream has been explicitly stopped; no further events will be emitted.\n     */\n    PersistentStreamState[PersistentStreamState[\"Stopped\"] = 5] = \"Stopped\";\n})(PersistentStreamState || (PersistentStreamState = {}));\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nvar BACKOFF_INITIAL_DELAY_MS = 1000;\n/** Maximum backoff time in milliseconds */\nvar BACKOFF_MAX_DELAY_MS = 60 * 1000;\nvar BACKOFF_FACTOR = 1.5;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nvar PersistentStream = /** @class */ (function () {\n    function PersistentStream(queue, connection, credentialsProvider, listener, \n        // Used for faster retries in testing\n        initialBackoffDelay) {\n        this.queue = queue;\n        this.connection = connection;\n        this.credentialsProvider = credentialsProvider;\n        this.stream = null;\n        this.listener = null;\n        this.backoff = new ExponentialBackoff(initialBackoffDelay ? initialBackoffDelay : BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);\n        this.state = PersistentStreamState.Initial;\n        this.listener = listener;\n    }\n    /**\n     * Returns true if `start` has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    PersistentStream.prototype.isStarted = function () {\n        return (this.state === PersistentStreamState.Backoff ||\n            this.state === PersistentStreamState.Auth ||\n            this.state === PersistentStreamState.Open);\n    };\n    /**\n     * Returns true if the underlying RPC is open (the openHandler has been\n     * called) and the stream is ready for outbound requests.\n     */\n    PersistentStream.prototype.isOpen = function () {\n        return this.state === PersistentStreamState.Open;\n    };\n    /**\n     * Starts the RPC. Only allowed if isStarted returns false. The stream is\n     * not immediately ready for use: onOpen will be invoked when the RPC is ready\n     * for outbound requests, at which point isOpen will return true.\n     *\n     *  When start returns, isStarted will return true.\n     */\n    PersistentStream.prototype.start = function () {\n        if (this.state === PersistentStreamState.Error) {\n            this.performBackoff();\n            return;\n        }\n        assert(this.state === PersistentStreamState.Initial, 'Already started');\n        this.auth();\n    };\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted state.\n     *\n     * When stop returns, isStarted and isOpen will both return false.\n     */\n    PersistentStream.prototype.stop = function () {\n        // Prevent any possible future restart of this stream\n        this.state = PersistentStreamState.Stopped;\n        // Clear the listener to avoid bleeding of events from the underlying\n        // streams\n        this.listener = null;\n        // Clean up the underlying stream because we are no longer interested in\n        // events\n        if (this.stream !== null) {\n            this.stream.close();\n            this.stream = null;\n        }\n    };\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose function. That function can decide to\n     * inhibit backoff if required.\n     */\n    PersistentStream.prototype.inhibitBackoff = function () {\n        assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n        this.state = PersistentStreamState.Initial;\n        this.backoff.reset();\n    };\n    PersistentStream.prototype.auth = function () {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');\n        this.state = PersistentStreamState.Auth;\n        this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(function (token) {\n            // Normally we'd have to schedule the callback on the AsyncQueue.\n            // However, the following calls are safe to be called outside the\n            // AsyncQueue since they don't chain asynchronous calls\n            _this.startStream(token);\n        }, function (error) {\n            _this.queue.schedule(function () {\n                if (_this.state !== PersistentStreamState.Stopped) {\n                    // Stream can be stopped while waiting for authorization.\n                    var rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                    return _this.handleStreamClose(rpcError);\n                }\n                else {\n                    return Promise.resolve();\n                }\n            });\n        });\n    };\n    PersistentStream.prototype.startStream = function (token) {\n        var _this = this;\n        if (this.state === PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            return;\n        }\n        assert(this.state === PersistentStreamState.Auth, 'Trying to start stream in a non-auth state');\n        // Helper function to dispatch to AsyncQueue and make sure that any\n        // close will seem instantaneous and events are prevented from being\n        // raised after the close call\n        var dispatchIfNotStopped = function (fn) {\n            _this.queue.schedule(function () {\n                // Only raise events if the listener has not changed\n                if (_this.state !== PersistentStreamState.Stopped) {\n                    return fn();\n                }\n                else {\n                    return Promise.resolve();\n                }\n            });\n        };\n        // Only start stream if listener has not changed\n        if (this.listener !== null) {\n            this.stream = this.startRpc(token);\n            this.stream.onOpen(function () {\n                dispatchIfNotStopped(function () {\n                    assert(_this.state === PersistentStreamState.Auth, 'Expected stream to be in state auth, but was ' + _this.state);\n                    _this.state = PersistentStreamState.Open;\n                    return _this.listener.onOpen();\n                });\n            });\n            this.stream.onClose(function (error) {\n                dispatchIfNotStopped(function () {\n                    return _this.handleStreamClose(error);\n                });\n            });\n            this.stream.onMessage(function (msg) {\n                dispatchIfNotStopped(function () {\n                    return _this.onMessage(msg);\n                });\n            });\n        }\n    };\n    PersistentStream.prototype.performBackoff = function () {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Error, 'Should only perform backoff in an error case');\n        this.state = PersistentStreamState.Backoff;\n        this.backoff.backoffAndWait().then(function () {\n            // Backoff does not run on the AsyncQueue, so we need to reschedule to\n            // make sure the queue blocks\n            _this.queue.schedule(function () {\n                if (_this.state === PersistentStreamState.Stopped) {\n                    // Stream can be stopped while waiting for backoff to complete.\n                    return Promise.resolve();\n                }\n                _this.state = PersistentStreamState.Initial;\n                _this.start();\n                assert(_this.isStarted(), 'PersistentStream should have started');\n                return Promise.resolve();\n            });\n        });\n    };\n    PersistentStream.prototype.handleStreamClose = function (error) {\n        assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n        log.debug(LOG_TAG, \"close with error: \" + error);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        this.state = PersistentStreamState.Error;\n        if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n            log.debug(LOG_TAG, 'Using maximum backoff delay to prevent overloading the backend.');\n            this.backoff.resetToMax();\n        }\n        return this.listener.onClose(error);\n    };\n    return PersistentStream;\n}());\nexport { PersistentStream };\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nvar PersistentListenStream = /** @class */ (function (_super) {\n    __extends(PersistentListenStream, _super);\n    function PersistentListenStream(databaseInfo, queue, connection, credentials, serializer, listener, initialBackoffDelay) {\n        var _this = _super.call(this, queue, connection, credentials, listener, initialBackoffDelay) || this;\n        _this.databaseInfo = databaseInfo;\n        _this.serializer = serializer;\n        return _this;\n    }\n    PersistentListenStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Listen', token);\n    };\n    PersistentListenStream.prototype.onMessage = function (watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        var watchChange = this.serializer.fromWatchChange(watchChangeProto);\n        var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    };\n    /**\n     * Registers interest in the results of the given query. If the query\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the query will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    PersistentListenStream.prototype.watch = function (queryData) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.addTarget = this.serializer.toTarget(queryData);\n        var labels = this.serializer.toListenRequestLabels(queryData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.stream.send(request);\n    };\n    /**\n     * Unregisters interest in the results of the query associated with the\n     * given targetId.\n     */\n    PersistentListenStream.prototype.unwatch = function (targetId) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.removeTarget = targetId;\n        this.stream.send(request);\n    };\n    return PersistentListenStream;\n}(PersistentStream));\nexport { PersistentListenStream };\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nvar PersistentWriteStream = /** @class */ (function (_super) {\n    __extends(PersistentWriteStream, _super);\n    function PersistentWriteStream(databaseInfo, queue, connection, credentials, serializer, listener, initialBackoffDelay) {\n        var _this = _super.call(this, queue, connection, credentials, listener, initialBackoffDelay) || this;\n        _this.databaseInfo = databaseInfo;\n        _this.serializer = serializer;\n        _this.handshakeComplete_ = false;\n        return _this;\n    }\n    Object.defineProperty(PersistentWriteStream.prototype, \"handshakeComplete\", {\n        /**\n         * Tracks whether or not a handshake has been successfully exchanged and\n         * the stream is ready to accept mutations.\n         */\n        get: function () {\n            return this.handshakeComplete_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Override of PersistentStream.start\n    PersistentWriteStream.prototype.start = function () {\n        this.handshakeComplete_ = false;\n        _super.prototype.start.call(this);\n    };\n    PersistentWriteStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Write', token);\n    };\n    PersistentWriteStream.prototype.onMessage = function (responseProto) {\n        // Always capture the last stream token.\n        assert(!!responseProto.streamToken, 'Got a write response without a stream token');\n        this.lastStreamToken = responseProto.streamToken;\n        if (!this.handshakeComplete_) {\n            // The first response is always the handshake response\n            assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');\n            this.handshakeComplete_ = true;\n            return this.listener.onHandshakeComplete();\n        }\n        else {\n            // A successful first write response means the stream is healthy,\n            // Note, that we could consider a successful handshake healthy, however,\n            // the write itself might be causing an error we want to back off from.\n            this.backoff.reset();\n            var results = this.serializer.fromWriteResults(responseProto.writeResults);\n            var commitVersion = this.serializer.fromVersion(responseProto.commitTime);\n            return this.listener.onMutationResult(commitVersion, results);\n        }\n    };\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    PersistentWriteStream.prototype.writeHandshake = function () {\n        assert(this.isOpen(), 'Writing handshake requires an opened stream');\n        assert(!this.handshakeComplete_, 'Handshake already completed');\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        this.stream.send(request);\n    };\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    PersistentWriteStream.prototype.writeMutations = function (mutations) {\n        var _this = this;\n        assert(this.isOpen(), 'Writing mutations requires an opened stream');\n        assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');\n        assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');\n        var request = {\n            // Protos are typed with string, but we support UInt8Array on Node\n            // tslint:disable-next-line:no-any\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(function (mutation) { return _this.serializer.toMutation(mutation); })\n        };\n        this.stream.send(request);\n    };\n    return PersistentWriteStream;\n}(PersistentStream));\nexport { PersistentWriteStream };\n\n\n"]}