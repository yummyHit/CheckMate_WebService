{"version":3,"sources":["src/firestore/remote/watch_change.ts","firestore/remote/watch_change.js"],"names":["objUtils","DocumentWatchChange","updatedTargetIds","removedTargetIds","key","newDoc","ExistenceFilterChange","targetId","existenceFilter","WatchTargetChangeState","WatchTargetChange","state","targetIds","resumeToken","cause","WatchChangeAggregator","snapshotVersion","listenTargets","pendingTargetResponses","existenceFilters","targetChanges","documentUpdates","frozen","shallowCopy","prototype","add","watchChange","addDocumentChange","addTargetChange","addExistenceFilterChange","addChanges","watchChanges","_this","forEach","change","createRemoteEvent","forEachNumber","isActiveTarget","ensureTargetChange","currentStatusUpdate","None","mapping","contains","docChange","relevant","_i","_a","length","_b","_c","delete","insert","targetChange","NoChange","applyResumeToken","Added","recordTargetResponse","Removed","Current","MarkCurrent","Reset","newCount"],"mappings":"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","file":"watch_change.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData } from '../local/query_data';\nimport { maybeDocumentMap } from '../model/collections';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { emptyByteString } from '../platform/platform';\nimport { assert, fail } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport * as objUtils from '../util/obj';\n\nimport { ExistenceFilter } from './existence_filter';\nimport {\n  CurrentStatusUpdate,\n  RemoteEvent,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n} from './remote_event';\n\n/**\n * Internal representation of the watcher API protocol buffers.\n */\nexport type WatchChange =\n  | DocumentWatchChange\n  | WatchTargetChange\n  | ExistenceFilterChange;\n\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nexport class DocumentWatchChange {\n  constructor(\n    /** The new document applies to all of these targets. */\n    public updatedTargetIds: TargetId[],\n    /** The new document is removed from all of these targets. */\n    public removedTargetIds: TargetId[],\n    /** The key of the document for this change. */\n    public key: DocumentKey,\n    /**\n       * The new document or NoDocument if it was deleted. Is null if the\n       * document went out of view without the server sending a new document.\n       */\n    public newDoc: Document | NoDocument | null\n  ) {}\n}\n\nexport class ExistenceFilterChange {\n  constructor(\n    public targetId: TargetId,\n    public existenceFilter: ExistenceFilter\n  ) {}\n}\n\nexport enum WatchTargetChangeState {\n  NoChange,\n  Added,\n  Removed,\n  Current,\n  Reset\n}\n\nexport class WatchTargetChange {\n  constructor(\n    /** What kind of change occurred to the watch target. */\n    public state: WatchTargetChangeState,\n    /** The target IDs that were added/removed/set. */\n    public targetIds: TargetId[],\n    /**\n       * An opaque, server-assigned token that allows watching a query to be\n       * resumed after disconnecting without retransmitting all the data that\n       * matches the query. The resume token essentially identifies a point in\n       * time from which the server should resume sending results.\n       */\n    public resumeToken: ProtoByteString = emptyByteString(),\n    /** An RPC error indicating why the watch failed. */\n    public cause: FirestoreError | null = null\n  ) {}\n}\n\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nexport class WatchChangeAggregator {\n  constructor(\n    private snapshotVersion: SnapshotVersion,\n    private readonly listenTargets: { [targetId: number]: QueryData },\n    pendingTargetResponses: { [targetId: number]: number }\n  ) {\n    this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n  }\n\n  /** The existence filter - if any - for the given target IDs. */\n  readonly existenceFilters: { [targetId: number]: ExistenceFilter } = {};\n\n  /** The number of pending responses that we are waiting on from watch. */\n  readonly pendingTargetResponses: { [targetId: number]: number };\n\n  /** Keeps track of the current target mappings */\n  private targetChanges: { [targetId: number]: TargetChange } = {};\n\n  /** Keeps track of document to update */\n  private documentUpdates = maybeDocumentMap();\n\n  /** Whether this aggregator was frozen and can no longer be modified */\n  private frozen = false;\n\n  /** Aggregates a watch change into the current state */\n  add(watchChange: WatchChange): void {\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    if (watchChange instanceof DocumentWatchChange) {\n      this.addDocumentChange(watchChange);\n    } else if (watchChange instanceof WatchTargetChange) {\n      this.addTargetChange(watchChange);\n    } else if (watchChange instanceof ExistenceFilterChange) {\n      this.addExistenceFilterChange(watchChange);\n    } else {\n      fail('Unknown watch change: ' + watchChange);\n    }\n  }\n\n  /** Aggregates all provided watch changes to the current state in order */\n  addChanges(watchChanges: WatchChange[]): void {\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    watchChanges.forEach(change => this.add(change));\n  }\n\n  /**\n   * Converts the current state into a remote event with the snapshot version\n   * provided via the constructor.\n   */\n  createRemoteEvent(): RemoteEvent {\n    const targetChanges = this.targetChanges;\n\n    // Remove all the non-active targets from the remote event.\n    objUtils.forEachNumber(this.targetChanges, targetId => {\n      if (!this.isActiveTarget(targetId)) {\n        delete targetChanges[targetId];\n      }\n    });\n\n    // Mark this aggregator as frozen so no further modifications are made\n    this.frozen = true;\n    return new RemoteEvent(\n      this.snapshotVersion,\n      targetChanges,\n      this.documentUpdates\n    );\n  }\n\n  private ensureTargetChange(targetId: TargetId): TargetChange {\n    let change = this.targetChanges[targetId];\n    if (!change) {\n      // Create an UpdateMapping by default, since resets are always explicit.\n      change = {\n        currentStatusUpdate: CurrentStatusUpdate.None,\n        snapshotVersion: this.snapshotVersion,\n        mapping: new UpdateMapping(),\n        resumeToken: emptyByteString()\n      };\n      this.targetChanges[targetId] = change;\n    }\n    return change;\n  }\n\n  /**\n   * We need to wait for watch to ack targets before we process those events,\n   * so to know if a target is active, there must be no pending acks we're\n   * waiting for and it must be in the current list of targets that the client\n   * cares about.\n   *\n   * This method is visible for testing.\n   */\n  protected isActiveTarget(targetId: TargetId): boolean {\n    return (\n      !objUtils.contains(this.pendingTargetResponses, targetId) &&\n      objUtils.contains(this.listenTargets, targetId)\n    );\n  }\n\n  private addDocumentChange(docChange: DocumentWatchChange) {\n    let relevant = false;\n\n    for (const targetId of docChange.updatedTargetIds) {\n      if (this.isActiveTarget(targetId)) {\n        const change = this.ensureTargetChange(targetId);\n        change.mapping.add(docChange.key);\n        relevant = true;\n      }\n    }\n\n    for (const targetId of docChange.removedTargetIds) {\n      if (this.isActiveTarget(targetId)) {\n        const change = this.ensureTargetChange(targetId);\n        change.mapping.delete(docChange.key);\n        relevant = true;\n      }\n    }\n\n    // Only update the document if there is a new document to replace to an\n    // active target that is being listened to, this might be just a target\n    // update instead.\n    if (docChange.newDoc && relevant) {\n      this.documentUpdates = this.documentUpdates.insert(\n        docChange.key,\n        docChange.newDoc\n      );\n    }\n  }\n\n  private addTargetChange(targetChange: WatchTargetChange) {\n    targetChange.targetIds.forEach(targetId => {\n      const change = this.ensureTargetChange(targetId);\n      switch (targetChange.state) {\n        case WatchTargetChangeState.NoChange:\n          if (this.isActiveTarget(targetId)) {\n            // Creating the change above satisfies the semantics of no-change.\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        case WatchTargetChangeState.Added:\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          this.recordTargetResponse(targetId);\n          if (!objUtils.contains(this.pendingTargetResponses, targetId)) {\n            // We have a freshly added target, so we need to reset any state\n            // that we had previously This can happen e.g. when remove and add\n            // back a target for existence filter mismatches.\n            change.mapping = new UpdateMapping();\n            change.currentStatusUpdate = CurrentStatusUpdate.None;\n            delete this.existenceFilters[targetId];\n          }\n          applyResumeToken(change, targetChange.resumeToken);\n          break;\n        case WatchTargetChangeState.Removed:\n          // We need to keep track of removed targets to we can\n          // post-filter and remove any target changes.\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          this.recordTargetResponse(targetId);\n          assert(\n            !targetChange.cause,\n            'WatchChangeAggregator does not handle errored targets'\n          );\n          break;\n        case WatchTargetChangeState.Current:\n          if (this.isActiveTarget(targetId)) {\n            change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        case WatchTargetChangeState.Reset:\n          if (this.isActiveTarget(targetId)) {\n            // Overwrite any existing target mapping with a reset\n            // mapping. Every subsequent update will modify the reset\n            // mapping, not an update mapping.\n            change.mapping = new ResetMapping();\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n          break;\n        default:\n          fail('Unknown target watch change state: ' + targetChange.state);\n      }\n    });\n  }\n\n  /**\n   * Record that we get a watch target add/remove by decrementing the number of\n   * pending target responses that we have.\n   */\n  private recordTargetResponse(targetId: TargetId): void {\n    const newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n    if (newCount === 0) {\n      delete this.pendingTargetResponses[targetId];\n    } else {\n      this.pendingTargetResponses[targetId] = newCount;\n    }\n  }\n\n  private addExistenceFilterChange(change: ExistenceFilterChange): void {\n    if (this.isActiveTarget(change.targetId)) {\n      this.existenceFilters[change.targetId] = change.existenceFilter;\n    }\n  }\n}\n\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(\n  change: TargetChange,\n  resumeToken: ProtoByteString\n): void {\n  if (resumeToken.length > 0) {\n    change.resumeToken = resumeToken;\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { emptyByteString } from '../platform/platform';\nimport { assert, fail } from '../util/assert';\nimport * as objUtils from '../util/obj';\nimport { CurrentStatusUpdate, RemoteEvent, ResetMapping, UpdateMapping } from './remote_event';\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nvar DocumentWatchChange = /** @class */ (function () {\n    function DocumentWatchChange(\n        /** The new document applies to all of these targets. */\n        updatedTargetIds, \n        /** The new document is removed from all of these targets. */\n        removedTargetIds, \n        /** The key of the document for this change. */\n        key, \n        /**\n           * The new document or NoDocument if it was deleted. Is null if the\n           * document went out of view without the server sending a new document.\n           */\n        newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n    return DocumentWatchChange;\n}());\nexport { DocumentWatchChange };\nvar ExistenceFilterChange = /** @class */ (function () {\n    function ExistenceFilterChange(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n    return ExistenceFilterChange;\n}());\nexport { ExistenceFilterChange };\nexport var WatchTargetChangeState;\n(function (WatchTargetChangeState) {\n    WatchTargetChangeState[WatchTargetChangeState[\"NoChange\"] = 0] = \"NoChange\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Added\"] = 1] = \"Added\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Removed\"] = 2] = \"Removed\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Current\"] = 3] = \"Current\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Reset\"] = 4] = \"Reset\";\n})(WatchTargetChangeState || (WatchTargetChangeState = {}));\nvar WatchTargetChange = /** @class */ (function () {\n    function WatchTargetChange(\n        /** What kind of change occurred to the watch target. */\n        state, \n        /** The target IDs that were added/removed/set. */\n        targetIds, \n        /**\n           * An opaque, server-assigned token that allows watching a query to be\n           * resumed after disconnecting without retransmitting all the data that\n           * matches the query. The resume token essentially identifies a point in\n           * time from which the server should resume sending results.\n           */\n        resumeToken, \n        /** An RPC error indicating why the watch failed. */\n        cause) {\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        if (cause === void 0) { cause = null; }\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n    return WatchTargetChange;\n}());\nexport { WatchTargetChange };\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nvar WatchChangeAggregator = /** @class */ (function () {\n    function WatchChangeAggregator(snapshotVersion, listenTargets, pendingTargetResponses) {\n        this.snapshotVersion = snapshotVersion;\n        this.listenTargets = listenTargets;\n        /** The existence filter - if any - for the given target IDs. */\n        this.existenceFilters = {};\n        /** Keeps track of the current target mappings */\n        this.targetChanges = {};\n        /** Keeps track of document to update */\n        this.documentUpdates = maybeDocumentMap();\n        /** Whether this aggregator was frozen and can no longer be modified */\n        this.frozen = false;\n        this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n    }\n    /** Aggregates a watch change into the current state */\n    WatchChangeAggregator.prototype.add = function (watchChange) {\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        if (watchChange instanceof DocumentWatchChange) {\n            this.addDocumentChange(watchChange);\n        }\n        else if (watchChange instanceof WatchTargetChange) {\n            this.addTargetChange(watchChange);\n        }\n        else if (watchChange instanceof ExistenceFilterChange) {\n            this.addExistenceFilterChange(watchChange);\n        }\n        else {\n            fail('Unknown watch change: ' + watchChange);\n        }\n    };\n    /** Aggregates all provided watch changes to the current state in order */\n    WatchChangeAggregator.prototype.addChanges = function (watchChanges) {\n        var _this = this;\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        watchChanges.forEach(function (change) { return _this.add(change); });\n    };\n    /**\n     * Converts the current state into a remote event with the snapshot version\n     * provided via the constructor.\n     */\n    WatchChangeAggregator.prototype.createRemoteEvent = function () {\n        var _this = this;\n        var targetChanges = this.targetChanges;\n        // Remove all the non-active targets from the remote event.\n        objUtils.forEachNumber(this.targetChanges, function (targetId) {\n            if (!_this.isActiveTarget(targetId)) {\n                delete targetChanges[targetId];\n            }\n        });\n        // Mark this aggregator as frozen so no further modifications are made\n        this.frozen = true;\n        return new RemoteEvent(this.snapshotVersion, targetChanges, this.documentUpdates);\n    };\n    WatchChangeAggregator.prototype.ensureTargetChange = function (targetId) {\n        var change = this.targetChanges[targetId];\n        if (!change) {\n            // Create an UpdateMapping by default, since resets are always explicit.\n            change = {\n                currentStatusUpdate: CurrentStatusUpdate.None,\n                snapshotVersion: this.snapshotVersion,\n                mapping: new UpdateMapping(),\n                resumeToken: emptyByteString()\n            };\n            this.targetChanges[targetId] = change;\n        }\n        return change;\n    };\n    /**\n     * We need to wait for watch to ack targets before we process those events,\n     * so to know if a target is active, there must be no pending acks we're\n     * waiting for and it must be in the current list of targets that the client\n     * cares about.\n     *\n     * This method is visible for testing.\n     */\n    WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {\n        return (!objUtils.contains(this.pendingTargetResponses, targetId) &&\n            objUtils.contains(this.listenTargets, targetId));\n    };\n    WatchChangeAggregator.prototype.addDocumentChange = function (docChange) {\n        var relevant = false;\n        for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {\n            var targetId = _a[_i];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.add(docChange.key);\n                relevant = true;\n            }\n        }\n        for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {\n            var targetId = _c[_b];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.delete(docChange.key);\n                relevant = true;\n            }\n        }\n        // Only update the document if there is a new document to replace to an\n        // active target that is being listened to, this might be just a target\n        // update instead.\n        if (docChange.newDoc && relevant) {\n            this.documentUpdates = this.documentUpdates.insert(docChange.key, docChange.newDoc);\n        }\n    };\n    WatchChangeAggregator.prototype.addTargetChange = function (targetChange) {\n        var _this = this;\n        targetChange.targetIds.forEach(function (targetId) {\n            var change = _this.ensureTargetChange(targetId);\n            switch (targetChange.state) {\n                case WatchTargetChangeState.NoChange:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Creating the change above satisfies the semantics of no-change.\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Added:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    if (!objUtils.contains(_this.pendingTargetResponses, targetId)) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        change.mapping = new UpdateMapping();\n                        change.currentStatusUpdate = CurrentStatusUpdate.None;\n                        delete _this.existenceFilters[targetId];\n                    }\n                    applyResumeToken(change, targetChange.resumeToken);\n                    break;\n                case WatchTargetChangeState.Removed:\n                    // We need to keep track of removed targets to we can\n                    // post-filter and remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');\n                    break;\n                case WatchTargetChangeState.Current:\n                    if (_this.isActiveTarget(targetId)) {\n                        change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Reset:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Overwrite any existing target mapping with a reset\n                        // mapping. Every subsequent update will modify the reset\n                        // mapping, not an update mapping.\n                        change.mapping = new ResetMapping();\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail('Unknown target watch change state: ' + targetChange.state);\n            }\n        });\n    };\n    /**\n     * Record that we get a watch target add/remove by decrementing the number of\n     * pending target responses that we have.\n     */\n    WatchChangeAggregator.prototype.recordTargetResponse = function (targetId) {\n        var newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n        if (newCount === 0) {\n            delete this.pendingTargetResponses[targetId];\n        }\n        else {\n            this.pendingTargetResponses[targetId] = newCount;\n        }\n    };\n    WatchChangeAggregator.prototype.addExistenceFilterChange = function (change) {\n        if (this.isActiveTarget(change.targetId)) {\n            this.existenceFilters[change.targetId] = change.existenceFilter;\n        }\n    };\n    return WatchChangeAggregator;\n}());\nexport { WatchChangeAggregator };\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(change, resumeToken) {\n    if (resumeToken.length > 0) {\n        change.resumeToken = resumeToken;\n    }\n}\n\n\n"]}