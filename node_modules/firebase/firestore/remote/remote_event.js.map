{"version":3,"sources":["src/firestore/remote/remote_event.ts","firestore/remote/remote_event.js"],"names":["RemoteEvent","snapshotVersion","targetChanges","documentUpdates","prototype","addDocumentUpdate","doc","insert","key","handleExistenceFilterMismatch","targetId","mapping","ResetMapping","MIN","currentStatusUpdate","CurrentStatusUpdate","MarkNotCurrent","resumeToken","EMPTY_KEY_SET","docs","Object","defineProperty","get","enumerable","configurable","add","delete","equals","other","UpdateMapping","addedDocuments","removedDocuments","applyToKeySet","keys","result","forEach"],"mappings":"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","file":"remote_event.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { emptyByteString } from '../platform/platform';\n\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nexport class RemoteEvent {\n  constructor(\n    /**\n       * The snapshot version this event brings us up to, or MIN if not set.\n       */\n    public readonly snapshotVersion: SnapshotVersion,\n    /**\n       * A map from target to changes to the target. See TargetChange.\n       */\n    public readonly targetChanges: { [targetId: number]: TargetChange },\n    /**\n       * A set of which documents have changed or been deleted, along with the\n       * doc's new values (if not deleted).\n       */\n    public documentUpdates: MaybeDocumentMap\n  ) {}\n\n  addDocumentUpdate(doc: MaybeDocument) {\n    this.documentUpdates = this.documentUpdates.insert(doc.key, doc);\n  }\n\n  handleExistenceFilterMismatch(targetId: TargetId) {\n    /*\n     * An existence filter mismatch will reset the query and we need to reset\n     * the mapping to contain no documents and an empty resume token.\n     *\n     * Note:\n     *   * The reset mapping is empty, specifically forcing the consumer of the\n     *     change to forget all keys for this targetID;\n     *   * The resume snapshot for this target must be reset\n     *   * The target must be unacked because unwatching and rewatching\n     *     introduces a race for changes.\n     */\n    this.targetChanges[targetId] = {\n      mapping: new ResetMapping(),\n      snapshotVersion: SnapshotVersion.MIN,\n      currentStatusUpdate: CurrentStatusUpdate.MarkNotCurrent,\n      resumeToken: emptyByteString()\n    };\n  }\n}\n\n/**\n * Represents an update to the current status of a target, either explicitly\n * having no new state, or the new value to set. Note \"current\" has special\n * meaning for in the RPC protocol that implies that a target is both up-to-date\n * and consistent with the rest of the watch stream.\n */\nexport enum CurrentStatusUpdate {\n  /** The current status is not affected and should not be modified. */\n  None,\n  /** The target must be marked as no longer \"current\". */\n  MarkNotCurrent,\n  /** The target must be marked as \"current\". */\n  MarkCurrent\n}\n\n/**\n * A part of a RemoteEvent specifying set of changes to a specific target. These\n * changes track what documents are currently included in the target as well as\n * the current snapshot version and resume token but the actual changes *to*\n * documents are not part of the TargetChange since documents may be part of\n * multiple targets.\n */\nexport interface TargetChange {\n  /**\n   * The new \"current\" (synced) status of this target. Set to\n   * CurrentStatusUpdateNone if the status should not be updated. Note \"current\"\n   * has special meaning in the RPC protocol that implies that a target is\n   * both up-to-date and consistent with the rest of the watch stream.\n   */\n  currentStatusUpdate: CurrentStatusUpdate;\n\n  /**\n   * A set of changes to documents in this target.\n   */\n  mapping: TargetMapping;\n\n  /** The snapshot version that this target change brings us up to. */\n  snapshotVersion: SnapshotVersion;\n\n  /**\n   * An opaque, server-assigned token that allows watching a query to be resumed\n   * after disconnecting without retransmitting all the data that matches the\n   * query. The resume token essentially identifies a point in time from which\n   * the server should resume sending results.\n   */\n  resumeToken: ProtoByteString;\n}\n\nexport type TargetMapping = ResetMapping | UpdateMapping;\n\nconst EMPTY_KEY_SET = documentKeySet();\n\nexport class ResetMapping {\n  private docs: DocumentKeySet = EMPTY_KEY_SET;\n\n  get documents(): DocumentKeySet {\n    return this.docs;\n  }\n\n  add(key: DocumentKey) {\n    this.docs = this.docs.add(key);\n  }\n\n  delete(key: DocumentKey) {\n    this.docs = this.docs.delete(key);\n  }\n\n  equals(other: ResetMapping): boolean {\n    return other !== null && this.docs.equals(other.docs);\n  }\n}\n\nexport class UpdateMapping {\n  addedDocuments: DocumentKeySet = EMPTY_KEY_SET;\n  removedDocuments: DocumentKeySet = EMPTY_KEY_SET;\n\n  applyToKeySet(keys: DocumentKeySet): DocumentKeySet {\n    let result = keys;\n    this.addedDocuments.forEach(key => (result = result.add(key)));\n    this.removedDocuments.forEach(key => (result = result.delete(key)));\n    return result;\n  }\n\n  add(key: DocumentKey) {\n    this.addedDocuments = this.addedDocuments.add(key);\n    this.removedDocuments = this.removedDocuments.delete(key);\n  }\n\n  delete(key: DocumentKey) {\n    this.addedDocuments = this.addedDocuments.delete(key);\n    this.removedDocuments = this.removedDocuments.add(key);\n  }\n\n  equals(other: UpdateMapping): boolean {\n    return (\n      other !== null &&\n      this.addedDocuments.equals(other.addedDocuments) &&\n      this.removedDocuments.equals(other.removedDocuments)\n    );\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { documentKeySet } from '../model/collections';\nimport { emptyByteString } from '../platform/platform';\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nvar RemoteEvent = /** @class */ (function () {\n    function RemoteEvent(\n        /**\n           * The snapshot version this event brings us up to, or MIN if not set.\n           */\n        snapshotVersion, \n        /**\n           * A map from target to changes to the target. See TargetChange.\n           */\n        targetChanges, \n        /**\n           * A set of which documents have changed or been deleted, along with the\n           * doc's new values (if not deleted).\n           */\n        documentUpdates) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.documentUpdates = documentUpdates;\n    }\n    RemoteEvent.prototype.addDocumentUpdate = function (doc) {\n        this.documentUpdates = this.documentUpdates.insert(doc.key, doc);\n    };\n    RemoteEvent.prototype.handleExistenceFilterMismatch = function (targetId) {\n        /*\n         * An existence filter mismatch will reset the query and we need to reset\n         * the mapping to contain no documents and an empty resume token.\n         *\n         * Note:\n         *   * The reset mapping is empty, specifically forcing the consumer of the\n         *     change to forget all keys for this targetID;\n         *   * The resume snapshot for this target must be reset\n         *   * The target must be unacked because unwatching and rewatching\n         *     introduces a race for changes.\n         */\n        this.targetChanges[targetId] = {\n            mapping: new ResetMapping(),\n            snapshotVersion: SnapshotVersion.MIN,\n            currentStatusUpdate: CurrentStatusUpdate.MarkNotCurrent,\n            resumeToken: emptyByteString()\n        };\n    };\n    return RemoteEvent;\n}());\nexport { RemoteEvent };\n/**\n * Represents an update to the current status of a target, either explicitly\n * having no new state, or the new value to set. Note \"current\" has special\n * meaning for in the RPC protocol that implies that a target is both up-to-date\n * and consistent with the rest of the watch stream.\n */\nexport var CurrentStatusUpdate;\n(function (CurrentStatusUpdate) {\n    /** The current status is not affected and should not be modified. */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"None\"] = 0] = \"None\";\n    /** The target must be marked as no longer \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkNotCurrent\"] = 1] = \"MarkNotCurrent\";\n    /** The target must be marked as \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkCurrent\"] = 2] = \"MarkCurrent\";\n})(CurrentStatusUpdate || (CurrentStatusUpdate = {}));\nvar EMPTY_KEY_SET = documentKeySet();\nvar ResetMapping = /** @class */ (function () {\n    function ResetMapping() {\n        this.docs = EMPTY_KEY_SET;\n    }\n    Object.defineProperty(ResetMapping.prototype, \"documents\", {\n        get: function () {\n            return this.docs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ResetMapping.prototype.add = function (key) {\n        this.docs = this.docs.add(key);\n    };\n    ResetMapping.prototype.delete = function (key) {\n        this.docs = this.docs.delete(key);\n    };\n    ResetMapping.prototype.equals = function (other) {\n        return other !== null && this.docs.equals(other.docs);\n    };\n    return ResetMapping;\n}());\nexport { ResetMapping };\nvar UpdateMapping = /** @class */ (function () {\n    function UpdateMapping() {\n        this.addedDocuments = EMPTY_KEY_SET;\n        this.removedDocuments = EMPTY_KEY_SET;\n    }\n    UpdateMapping.prototype.applyToKeySet = function (keys) {\n        var result = keys;\n        this.addedDocuments.forEach(function (key) { return (result = result.add(key)); });\n        this.removedDocuments.forEach(function (key) { return (result = result.delete(key)); });\n        return result;\n    };\n    UpdateMapping.prototype.add = function (key) {\n        this.addedDocuments = this.addedDocuments.add(key);\n        this.removedDocuments = this.removedDocuments.delete(key);\n    };\n    UpdateMapping.prototype.delete = function (key) {\n        this.addedDocuments = this.addedDocuments.delete(key);\n        this.removedDocuments = this.removedDocuments.add(key);\n    };\n    UpdateMapping.prototype.equals = function (other) {\n        return (other !== null &&\n            this.addedDocuments.equals(other.addedDocuments) &&\n            this.removedDocuments.equals(other.removedDocuments));\n    };\n    return UpdateMapping;\n}());\nexport { UpdateMapping };\n\n\n"]}