{"version":3,"sources":["src/firestore/remote/serializer.ts","firestore/remote/serializer.js"],"names":["fieldValue","obj","typeUtils","DIRECTIONS","dirs","ASCENDING","name","DESCENDING","OPERATORS","ops","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","EQUAL","assertPresent","value","description","isNullOrUndefined","parseInt64","parseInt","JsonProtoSerializer","databaseId","options","prototype","emptyByteString","useProto3Json","Uint8Array","unsafeCastProtoByteString","byteString","fromRpcStatus","status","code","undefined","UNKNOWN","message","toTimestamp","timestamp","seconds","nanos","fromTimestamp","date","fromISOString","toBytes","bytes","toBase64","toUint8Array","fromBlob","blob","fromBase64String","fromUint8Array","toVersion","version","fromVersion","toResourceName","path","fullyQualifiedPrefixPath","child","canonicalString","fromResourceName","resource","fromString","isValidResourceName","toString","toName","key","fromName","get","projectId","database","extractLocalPathFromResourceName","toQueryPath","length","encodedDatabaseId","fromQueryPath","resourceName","EMPTY_PATH","Object","defineProperty","enumerable","configurable","popFirst","toValue","val","NullValue","nullValue","BooleanValue","booleanValue","IntegerValue","integerValue","DoubleValue","doubleValue","isNaN","Infinity","StringValue","stringValue","ObjectValue","mapValue","toMapValue","ArrayValue","arrayValue","toArrayValue","TimestampValue","timestampValue","internalValue","GeoPointValue","geoPointValue","latitude","longitude","BlobValue","bytesValue","RefValue","referenceValue","JSON","stringify","fromValue","_this","type","hasTag","INSTANCE","of","NAN","POSITIVE_INFINITY","NEGATIVE_INFINITY","fromFields","fields","values","map","v","dbId","toMutationDocument","toFields","toDocument","document","hasLocalMutations","data","updateTime","fromDocument","result","forEach","object","EMPTY","set","array","push","fromFound","doc","found","fromMissing","missing","readTime","fromMaybeDocument","toWatchTargetChangeState","state","Added","Current","NoChange","Removed","Reset","toTestWatchChange","watchChange","filter","count","existenceFilter","targetId","newDoc","documentChange","targetIds","updatedTargetIds","removedTargetIds","documentDelete","documentRemove","cause","targetChange","targetChangeType","resumeToken","fromWatchChange","change","fromWatchTargetChangeState","causeProto","entityChange","docDelete","forDeletedDoc","docRemove","versionFromListenResponse","MIN","toMutation","mutation","update","delete","updateMask","toDocumentMask","fieldMask","transform","fieldTransforms","toFieldTransform","precondition","isNone","currentDocument","toPrecondition","fromMutation","proto","fromPrecondition","NONE","fromDocumentMask","fromFieldTransform","exists","fromWriteResult","transformResults","fromWriteResults","protos","fieldTransform","fieldPath","field","setToServerValue","fromServerFormat","instance","toDocumentsTarget","query","documents","fromDocumentsTarget","documentsTarget","atPath","toQueryTarget","structuredQuery","isEmpty","parent","popLast","from","collectionId","lastSegment","where","toFilter","filters","orderBy","toOrder","limit","toLimit","startAt","toCursor","endAt","fromQueryTarget","target","fromCount","filterBy","fromFilter","fromOrder","fromCursor","toListenRequestLabels","queryData","toLabel","purpose","Listen","ExistenceFilterMismatch","LimboResolution","toTarget","isDocumentQuery","toRelationFilter","toUnaryFilter","compositeFilter","op","unaryFilter","fromUnaryFilter","fieldFilter","fromRelationFilter","f","reduce","accum","current","concat","orderBys","order","toPropertyOrder","fromPropertyOrder","cursor","before","position","component","toDirection","dir","fromDirection","toOperatorName","fromOperatorName","toFieldPathReference","fromFieldPathReference","fieldReference","direction","nanField","nullField","fieldPaths","paths","tag"],"mappings":"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","file":"serializer.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { Blob } from '../api/blob';\nimport { GeoPoint } from '../api/geo_point';\nimport { DatabaseId } from '../core/database_info';\nimport {\n  Bound,\n  Direction,\n  Filter,\n  NanFilter,\n  NullFilter,\n  OrderBy,\n  Query,\n  RelationFilter,\n  RelationOp\n} from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport * as fieldValue from '../model/field_value';\nimport {\n  DeleteMutation,\n  FieldMask,\n  FieldTransform,\n  Mutation,\n  MutationResult,\n  PatchMutation,\n  Precondition,\n  ServerTimestampTransform,\n  SetMutation,\n  TransformMutation\n} from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { AnyJs } from '../util/misc';\nimport * as obj from '../util/obj';\nimport * as typeUtils from '../util/types';\n\nimport { ExistenceFilter } from './existence_filter';\nimport { mapCodeFromRpcCode, mapRpcCodeFromCode } from './rpc_error';\nimport {\n  DocumentWatchChange,\n  ExistenceFilterChange,\n  WatchChange,\n  WatchTargetChange,\n  WatchTargetChangeState\n} from './watch_change';\nimport { ApiClientObjectMap } from '../protos/firestore_proto_api';\n\nconst DIRECTIONS = (() => {\n  const dirs: { [dir: string]: api.OrderDirection } = {};\n  dirs[Direction.ASCENDING.name] = 'ASCENDING';\n  dirs[Direction.DESCENDING.name] = 'DESCENDING';\n  return dirs;\n})();\n\nconst OPERATORS = (() => {\n  const ops: { [op: string]: api.FieldFilterOp } = {};\n  ops[RelationOp.LESS_THAN.name] = 'LESS_THAN';\n  ops[RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';\n  ops[RelationOp.GREATER_THAN.name] = 'GREATER_THAN';\n  ops[RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';\n  ops[RelationOp.EQUAL.name] = 'EQUAL';\n  return ops;\n})();\n\nfunction assertPresent(value: AnyJs, description: string) {\n  assert(!typeUtils.isNullOrUndefined(value), description + ' is missing');\n}\n\nfunction parseInt64(value: number | string): number {\n  // TODO(bjornick): Handle int64 greater than 53 bits.\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return parseInt(value, 10);\n  } else {\n    return fail(\"can't parse \" + value);\n  }\n}\n\n// This is a supplement to the generated proto interfaces, which fail to account\n// for the fact that a timestamp may be encoded as either a string OR this.\ninterface TimestampProto {\n  seconds?: string;\n  nanos?: number;\n}\n\nexport interface SerializerOptions {\n  /**\n   * The serializer supports both Protobuf.js and Proto3 JSON formats. By\n   * setting this flag to true, the serializer will use the Proto3 JSON format.\n   *\n   * For a description of the Proto3 JSON format check\n   * https://developers.google.com/protocol-buffers/docs/proto3#json\n   */\n  useProto3Json: boolean;\n}\n\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nexport class JsonProtoSerializer {\n  constructor(\n    private databaseId: DatabaseId,\n    private options: SerializerOptions\n  ) {}\n\n  private emptyByteString(): ProtoByteString {\n    if (this.options.useProto3Json) {\n      return '';\n    } else {\n      return new Uint8Array(0);\n    }\n  }\n\n  private unsafeCastProtoByteString(byteString: ProtoByteString): string {\n    // byteStrings can be either string or UInt8Array, but the typings say\n    // it's always a string. Cast as string to avoid type check failing\n    return byteString as string;\n  }\n\n  fromRpcStatus(status: api.Status): FirestoreError {\n    const code =\n      status.code === undefined\n        ? Code.UNKNOWN\n        : mapCodeFromRpcCode(status.code);\n    return new FirestoreError(code, status.message || '');\n  }\n\n  /**\n   * Returns a value for a Date that's appropriate to put into a proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"string\" because that's what\n   * our generated proto interfaces say dates must be. But it's easier and safer\n   * to actually return a Timestamp proto.\n   */\n  private toTimestamp(timestamp: Timestamp): string {\n    return {\n      seconds: timestamp.seconds,\n      nanos: timestamp.nanos\n      // tslint:disable-next-line:no-any\n    } as any;\n  }\n\n  private fromTimestamp(date: string | TimestampProto): Timestamp {\n    // The json interface (for the browser) will return an iso timestamp string,\n    // while the proto js library (for node) will return a\n    // google.protobuf.Timestamp instance.\n    if (typeof date === 'string') {\n      // TODO(b/37282237): Use strings for Proto3 timestamps\n      // assert(this.options.useProto3Json,\n      //   'The timestamp string format requires Proto3.');\n      return Timestamp.fromISOString(date);\n    } else {\n      assert(!!date, 'Cannot deserialize null or undefined timestamp.');\n      // TODO(b/37282237): Use strings for Proto3 timestamps\n      // assert(!this.options.useProto3Json,\n      //   'The timestamp instance format requires Proto JS.');\n      const seconds = parseInt64(date.seconds || '0');\n      const nanos = date.nanos || 0;\n      return new Timestamp(seconds, nanos);\n    }\n  }\n\n  /**\n   * Returns a value for bytes that's appropriate to put in a proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"string\" because that's what\n   * our generated proto interfaces say bytes must be. But it should return\n   * an Uint8Array in Node.\n   */\n  private toBytes(bytes: Blob): string {\n    if (this.options.useProto3Json) {\n      return bytes.toBase64();\n    } else {\n      // The typings say it's a string, but it needs to be a Uint8Array in Node.\n      return this.unsafeCastProtoByteString(bytes.toUint8Array());\n    }\n  }\n\n  /**\n   * Parse the blob from the protos into the internal Blob class. Note that the\n   * typings assume all blobs are strings, but they are actually Uint8Arrays\n   * on Node.\n   */\n  private fromBlob(blob: string | Uint8Array): Blob {\n    if (typeof blob === 'string') {\n      assert(\n        this.options.useProto3Json,\n        'Expected bytes to be passed in as Uint8Array, but got a string instead.'\n      );\n      return Blob.fromBase64String(blob);\n    } else {\n      assert(\n        !this.options.useProto3Json,\n        'Expected bytes to be passed in as string, but got something else instead.'\n      );\n      return Blob.fromUint8Array(blob);\n    }\n  }\n\n  toVersion(version: SnapshotVersion): string {\n    return this.toTimestamp(version.toTimestamp());\n  }\n\n  fromVersion(version: string): SnapshotVersion {\n    assert(!!version, \"Trying to deserialize version that isn't set\");\n    return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n  }\n\n  toResourceName(databaseId: DatabaseId, path: ResourcePath): string {\n    return this.fullyQualifiedPrefixPath(databaseId)\n      .child('documents')\n      .child(path)\n      .canonicalString();\n  }\n\n  fromResourceName(name: string): ResourcePath {\n    const resource = ResourcePath.fromString(name);\n    assert(\n      this.isValidResourceName(resource),\n      'Tried to deserialize invalid key ' + resource.toString()\n    );\n    return resource;\n  }\n\n  toName(key: DocumentKey): string {\n    return this.toResourceName(this.databaseId, key.path);\n  }\n\n  fromName(name: string): DocumentKey {\n    const resource = this.fromResourceName(name);\n    assert(\n      resource.get(1) === this.databaseId.projectId,\n      'Tried to deserialize key from different project: ' +\n        resource.get(1) +\n        ' vs ' +\n        this.databaseId.projectId\n    );\n    assert(\n      (!resource.get(3) && !this.databaseId.database) ||\n        resource.get(3) === this.databaseId.database,\n      'Tried to deserialize key from different database: ' +\n        resource.get(3) +\n        ' vs ' +\n        this.databaseId.database\n    );\n    return new DocumentKey(this.extractLocalPathFromResourceName(resource));\n  }\n\n  toQueryPath(path: ResourcePath): string {\n    if (path.length === 0) {\n      // If the path is empty, the backend requires we leave off the /documents\n      // at the end.\n      return this.encodedDatabaseId;\n    }\n    return this.toResourceName(this.databaseId, path);\n  }\n\n  fromQueryPath(name: string): ResourcePath {\n    const resourceName = this.fromResourceName(name);\n    if (resourceName.length === 4) {\n      return ResourcePath.EMPTY_PATH;\n    }\n    return this.extractLocalPathFromResourceName(resourceName);\n  }\n\n  get encodedDatabaseId(): string {\n    const path = new ResourcePath([\n      'projects',\n      this.databaseId.projectId,\n      'databases',\n      this.databaseId.database\n    ]);\n    return path.canonicalString();\n  }\n\n  private fullyQualifiedPrefixPath(databaseId: DatabaseId): ResourcePath {\n    return new ResourcePath([\n      'projects',\n      databaseId.projectId,\n      'databases',\n      databaseId.database\n    ]);\n  }\n\n  private extractLocalPathFromResourceName(\n    resourceName: ResourcePath\n  ): ResourcePath {\n    assert(\n      resourceName.length > 4 && resourceName.get(4) === 'documents',\n      'tried to deserialize invalid key ' + resourceName.toString()\n    );\n    return resourceName.popFirst(5);\n  }\n\n  private isValidResourceName(path: ResourcePath): boolean {\n    // Resource names have at least 4 components (project ID, database ID)\n    return (\n      path.length >= 4 &&\n      path.get(0) === 'projects' &&\n      path.get(2) === 'databases'\n    );\n  }\n\n  toValue(val: fieldValue.FieldValue): api.Value {\n    if (val instanceof fieldValue.NullValue) {\n      return { nullValue: 'NULL_VALUE' };\n    } else if (val instanceof fieldValue.BooleanValue) {\n      return { booleanValue: val.value() };\n    } else if (val instanceof fieldValue.IntegerValue) {\n      return { integerValue: '' + val.value() };\n    } else if (val instanceof fieldValue.DoubleValue) {\n      const doubleValue = val.value();\n      if (this.options.useProto3Json) {\n        // Proto 3 let's us encode NaN and Infinity as string values as\n        // expected by the backend. This is currently not checked by our unit\n        // tests because they rely on protobuf.js.\n        if (isNaN(doubleValue)) {\n          return { doubleValue: 'NaN' } as {};\n        } else if (doubleValue === Infinity) {\n          return { doubleValue: 'Infinity' } as {};\n        } else if (doubleValue === -Infinity) {\n          return { doubleValue: '-Infinity' } as {};\n        }\n      }\n      return { doubleValue: val.value() };\n    } else if (val instanceof fieldValue.StringValue) {\n      return { stringValue: val.value() };\n    } else if (val instanceof fieldValue.ObjectValue) {\n      return { mapValue: this.toMapValue(val) };\n    } else if (val instanceof fieldValue.ArrayValue) {\n      return { arrayValue: this.toArrayValue(val) };\n    } else if (val instanceof fieldValue.TimestampValue) {\n      return {\n        timestampValue: this.toTimestamp(val.internalValue)\n      };\n    } else if (val instanceof fieldValue.GeoPointValue) {\n      return {\n        geoPointValue: {\n          latitude: val.value().latitude,\n          longitude: val.value().longitude\n        }\n      };\n    } else if (val instanceof fieldValue.BlobValue) {\n      return {\n        bytesValue: this.toBytes(val.value())\n      };\n    } else if (val instanceof fieldValue.RefValue) {\n      return {\n        referenceValue: this.toResourceName(val.databaseId, val.key.path)\n      };\n    } else {\n      return fail('Unknown FieldValue ' + JSON.stringify(val));\n    }\n  }\n\n  fromValue(obj: api.Value): fieldValue.FieldValue {\n    // tslint:disable-next-line:no-any\n    const type = (obj as any)['value_type'];\n    if (hasTag(obj, type, 'nullValue')) {\n      return fieldValue.NullValue.INSTANCE;\n    } else if (hasTag(obj, type, 'booleanValue')) {\n      return fieldValue.BooleanValue.of(obj.booleanValue!);\n    } else if (hasTag(obj, type, 'integerValue')) {\n      return new fieldValue.IntegerValue(parseInt64(obj.integerValue!));\n    } else if (hasTag(obj, type, 'doubleValue')) {\n      if (this.options.useProto3Json) {\n        // Proto 3 uses the string values 'NaN' and 'Infinity'.\n        if ((obj.doubleValue as {}) === 'NaN') {\n          return fieldValue.DoubleValue.NAN;\n        } else if ((obj.doubleValue as {}) === 'Infinity') {\n          return fieldValue.DoubleValue.POSITIVE_INFINITY;\n        } else if ((obj.doubleValue as {}) === '-Infinity') {\n          return fieldValue.DoubleValue.NEGATIVE_INFINITY;\n        }\n      }\n\n      return new fieldValue.DoubleValue(obj.doubleValue!);\n    } else if (hasTag(obj, type, 'stringValue')) {\n      return new fieldValue.StringValue(obj.stringValue!);\n    } else if (hasTag(obj, type, 'mapValue')) {\n      return this.fromFields(obj.mapValue!.fields || {});\n    } else if (hasTag(obj, type, 'arrayValue')) {\n      // \"values\" is not present if the array is empty\n      assertPresent(obj.arrayValue, 'arrayValue');\n      const values = obj.arrayValue!.values || [];\n      return new fieldValue.ArrayValue(values.map(v => this.fromValue(v)));\n    } else if (hasTag(obj, type, 'timestampValue')) {\n      assertPresent(obj.timestampValue, 'timestampValue');\n      return new fieldValue.TimestampValue(\n        this.fromTimestamp(obj.timestampValue!)\n      );\n    } else if (hasTag(obj, type, 'geoPointValue')) {\n      assertPresent(obj.geoPointValue, 'geoPointValue');\n      const latitude = obj.geoPointValue!.latitude || 0;\n      const longitude = obj.geoPointValue!.longitude || 0;\n      return new fieldValue.GeoPointValue(new GeoPoint(latitude, longitude));\n    } else if (hasTag(obj, type, 'bytesValue')) {\n      assertPresent(obj.bytesValue, 'bytesValue');\n      const blob = this.fromBlob(obj.bytesValue!);\n      return new fieldValue.BlobValue(blob);\n    } else if (hasTag(obj, type, 'referenceValue')) {\n      assertPresent(obj.referenceValue, 'referenceValue');\n      const resourceName = this.fromResourceName(obj.referenceValue!);\n      const dbId = new DatabaseId(resourceName.get(1), resourceName.get(3));\n      const key = new DocumentKey(\n        this.extractLocalPathFromResourceName(resourceName)\n      );\n      return new fieldValue.RefValue(dbId, key);\n    } else {\n      return fail('Unknown Value proto ' + JSON.stringify(obj));\n    }\n  }\n\n  /** Creates an api.Document from key and fields (but no create/update time) */\n  toMutationDocument(\n    key: DocumentKey,\n    fields: fieldValue.ObjectValue\n  ): api.Document {\n    return {\n      name: this.toName(key),\n      fields: this.toFields(fields)\n    };\n  }\n\n  toDocument(document: Document): api.Document {\n    assert(\n      !document.hasLocalMutations,\n      \"Can't serialize documents with mutations.\"\n    );\n    return {\n      name: this.toName(document.key),\n      fields: this.toFields(document.data),\n      updateTime: this.toTimestamp(document.version.toTimestamp())\n    };\n  }\n\n  fromDocument(document: api.Document): Document {\n    return new Document(\n      this.fromName(document.name!),\n      this.fromVersion(document.updateTime!),\n      this.fromFields(document.fields || {}),\n      { hasLocalMutations: false }\n    );\n  }\n\n  toFields(fields: fieldValue.ObjectValue): { [key: string]: api.Value } {\n    const result: { [key: string]: api.Value } = {};\n    fields.forEach((key, value) => {\n      result[key] = this.toValue(value);\n    });\n    return result;\n  }\n\n  fromFields(object: {}): fieldValue.ObjectValue {\n    // Proto map<string, Value> gets mapped to Object, so cast it.\n    const map = object as { [key: string]: api.Value };\n    let result = fieldValue.ObjectValue.EMPTY;\n    obj.forEach(map, (key, value) => {\n      result = result.set(new FieldPath([key]), this.fromValue(value));\n    });\n    return result;\n  }\n\n  toMapValue(map: fieldValue.ObjectValue): api.MapValue {\n    return {\n      fields: this.toFields(map)\n    };\n  }\n\n  toArrayValue(array: fieldValue.ArrayValue): api.ArrayValue {\n    const result: api.Value[] = [];\n    array.forEach(value => {\n      result.push(this.toValue(value));\n    });\n    return { values: result };\n  }\n\n  private fromFound(doc: api.BatchGetDocumentsResponse): Document {\n    assert(\n      !!doc.found,\n      'Tried to deserialize a found document from a missing document.'\n    );\n    assertPresent(doc.found!.name, 'doc.found.name');\n    assertPresent(doc.found!.updateTime, 'doc.found.updateTime');\n    const key = this.fromName(doc.found!.name!);\n    const version = this.fromVersion(doc.found!.updateTime!);\n    const fields = this.fromFields(doc.found!.fields || {});\n    return new Document(key, version, fields, { hasLocalMutations: false });\n  }\n\n  private fromMissing(result: api.BatchGetDocumentsResponse): NoDocument {\n    assert(\n      !!result.missing,\n      'Tried to deserialize a missing document from a found document.'\n    );\n    assert(\n      !!result.readTime,\n      'Tried to deserialize a missing document without a read time.'\n    );\n    const key = this.fromName(result.missing!);\n    const version = this.fromVersion(result.readTime!);\n    return new NoDocument(key, version);\n  }\n\n  fromMaybeDocument(result: api.BatchGetDocumentsResponse): MaybeDocument {\n    // tslint:disable-next-line:no-any\n    const type = (result as any)['result_type'];\n    if (hasTag(result, type, 'found')) {\n      return this.fromFound(result);\n    } else if (hasTag(result, type, 'missing')) {\n      return this.fromMissing(result);\n    }\n    return fail('invalid batch get response: ' + JSON.stringify(result));\n  }\n\n  private toWatchTargetChangeState(\n    state: WatchTargetChangeState\n  ): api.TargetChangeTargetChangeType {\n    switch (state) {\n      case WatchTargetChangeState.Added:\n        return 'ADD';\n      case WatchTargetChangeState.Current:\n        return 'CURRENT';\n      case WatchTargetChangeState.NoChange:\n        return 'NO_CHANGE';\n      case WatchTargetChangeState.Removed:\n        return 'REMOVE';\n      case WatchTargetChangeState.Reset:\n        return 'RESET';\n      default:\n        return fail('Unknown WatchTargetChangeState: ' + state);\n    }\n  }\n\n  toTestWatchChange(watchChange: WatchChange): api.ListenResponse {\n    if (watchChange instanceof ExistenceFilterChange) {\n      return {\n        filter: {\n          count: watchChange.existenceFilter.count,\n          targetId: watchChange.targetId\n        }\n      };\n    }\n    if (watchChange instanceof DocumentWatchChange) {\n      if (watchChange.newDoc instanceof Document) {\n        const doc = watchChange.newDoc;\n        return {\n          documentChange: {\n            document: {\n              name: this.toName(doc.key),\n              fields: this.toFields(doc.data),\n              updateTime: this.toVersion(doc.version)\n            },\n            targetIds: watchChange.updatedTargetIds,\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      } else if (watchChange.newDoc instanceof NoDocument) {\n        const doc = watchChange.newDoc;\n        return {\n          documentDelete: {\n            document: this.toName(doc.key),\n            readTime: this.toVersion(doc.version),\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      } else if (watchChange.newDoc === null) {\n        return {\n          documentRemove: {\n            document: this.toName(watchChange.key),\n            removedTargetIds: watchChange.removedTargetIds\n          }\n        };\n      }\n    }\n    if (watchChange instanceof WatchTargetChange) {\n      let cause: api.Status | undefined = undefined;\n      if (watchChange.cause) {\n        cause = {\n          code: mapRpcCodeFromCode(watchChange.cause.code),\n          message: watchChange.cause.message\n        };\n      }\n      return {\n        targetChange: {\n          targetChangeType: this.toWatchTargetChangeState(watchChange.state),\n          targetIds: watchChange.targetIds,\n          resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),\n          cause\n        }\n      };\n    }\n    return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));\n  }\n\n  fromWatchChange(change: api.ListenResponse): WatchChange {\n    // tslint:disable-next-line:no-any\n    const type = (change as any)['change_type'];\n    let watchChange: WatchChange;\n    if (hasTag(change, type, 'targetChange')) {\n      assertPresent(change.targetChange, 'targetChange');\n      // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n      // if unset\n      const state = this.fromWatchTargetChangeState(\n        change.targetChange!.targetChangeType || 'NO_CHANGE'\n      );\n      const targetIds: TargetId[] = change.targetChange!.targetIds || [];\n      const resumeToken =\n        change.targetChange!.resumeToken || this.emptyByteString();\n      const causeProto = change.targetChange!.cause;\n      const cause = causeProto && this.fromRpcStatus(causeProto);\n      watchChange = new WatchTargetChange(\n        state,\n        targetIds,\n        resumeToken,\n        cause || null\n      );\n    } else if (hasTag(change, type, 'documentChange')) {\n      assertPresent(change.documentChange, 'documentChange');\n      assertPresent(change.documentChange!.document, 'documentChange.name');\n      assertPresent(\n        change.documentChange!.document!.name,\n        'documentChange.document.name'\n      );\n      assertPresent(\n        change.documentChange!.document!.updateTime,\n        'documentChange.document.updateTime'\n      );\n      const entityChange = change.documentChange!;\n      const key = this.fromName(entityChange.document!.name!);\n      const version = this.fromVersion(entityChange.document!.updateTime!);\n      const fields = this.fromFields(entityChange.document!.fields || {});\n      const doc = new Document(key, version, fields, {\n        hasLocalMutations: false\n      });\n      const updatedTargetIds = entityChange.targetIds || [];\n      const removedTargetIds = entityChange.removedTargetIds || [];\n      watchChange = new DocumentWatchChange(\n        updatedTargetIds,\n        removedTargetIds,\n        doc.key,\n        doc\n      );\n    } else if (hasTag(change, type, 'documentDelete')) {\n      assertPresent(change.documentDelete, 'documentDelete');\n      assertPresent(change.documentDelete!.document, 'documentDelete.document');\n      const docDelete = change.documentDelete!;\n      const key = this.fromName(docDelete.document!);\n      const version = docDelete.readTime\n        ? this.fromVersion(docDelete.readTime)\n        : SnapshotVersion.forDeletedDoc();\n      const doc = new NoDocument(key, version);\n      const removedTargetIds = docDelete.removedTargetIds || [];\n      watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n    } else if (hasTag(change, type, 'documentRemove')) {\n      assertPresent(change.documentRemove, 'documentRemove');\n      assertPresent(change.documentRemove!.document, 'documentRemove');\n      const docRemove = change.documentRemove!;\n      const key = this.fromName(docRemove.document!);\n      const removedTargetIds = docRemove.removedTargetIds || [];\n      watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n    } else if (hasTag(change, type, 'filter')) {\n      // TODO(dimond): implement existence filter parsing with strategy.\n      assertPresent(change.filter, 'filter');\n      assertPresent(change.filter!.targetId, 'filter.targetId');\n      const filter = change.filter;\n      const count = filter!.count || 0;\n      const existenceFilter = new ExistenceFilter(count);\n      const targetId = filter!.targetId!;\n      watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n    } else {\n      return fail('Unknown change type ' + JSON.stringify(change));\n    }\n    return watchChange;\n  }\n\n  fromWatchTargetChangeState(\n    state: api.TargetChangeTargetChangeType\n  ): WatchTargetChangeState {\n    if (state === 'NO_CHANGE') {\n      return WatchTargetChangeState.NoChange;\n    } else if (state === 'ADD') {\n      return WatchTargetChangeState.Added;\n    } else if (state === 'REMOVE') {\n      return WatchTargetChangeState.Removed;\n    } else if (state === 'CURRENT') {\n      return WatchTargetChangeState.Current;\n    } else if (state === 'RESET') {\n      return WatchTargetChangeState.Reset;\n    } else {\n      return fail('Got unexpected TargetChange.state: ' + state);\n    }\n  }\n\n  versionFromListenResponse(change: api.ListenResponse): SnapshotVersion {\n    // We have only reached a consistent snapshot for the entire stream if there\n    // is a read_time set and it applies to all targets (i.e. the list of\n    // targets is empty). The backend is guaranteed to send such responses.\n    // tslint:disable-next-line:no-any\n    const type = (change as any)['response_type'];\n    if (!hasTag(change, type, 'targetChange')) {\n      return SnapshotVersion.MIN;\n    }\n    const targetChange = change.targetChange!;\n    if (targetChange.targetIds && targetChange.targetIds.length) {\n      return SnapshotVersion.MIN;\n    }\n    if (!targetChange.readTime) {\n      return SnapshotVersion.MIN;\n    }\n    return this.fromVersion(targetChange.readTime);\n  }\n\n  toMutation(mutation: Mutation): api.Write {\n    let result: api.Write;\n    if (mutation instanceof SetMutation) {\n      result = {\n        update: this.toMutationDocument(mutation.key, mutation.value)\n      };\n    } else if (mutation instanceof DeleteMutation) {\n      result = { delete: this.toName(mutation.key) };\n    } else if (mutation instanceof PatchMutation) {\n      result = {\n        update: this.toMutationDocument(mutation.key, mutation.data),\n        updateMask: this.toDocumentMask(mutation.fieldMask)\n      };\n    } else if (mutation instanceof TransformMutation) {\n      result = {\n        transform: {\n          document: this.toName(mutation.key),\n          fieldTransforms: mutation.fieldTransforms.map(transform =>\n            this.toFieldTransform(transform)\n          )\n        }\n      };\n    } else {\n      return fail('Unknown mutation type ' + mutation.type);\n    }\n\n    if (!mutation.precondition.isNone) {\n      result.currentDocument = this.toPrecondition(mutation.precondition);\n    }\n\n    return result;\n  }\n\n  fromMutation(proto: api.Write): Mutation {\n    const precondition = proto.currentDocument\n      ? this.fromPrecondition(proto.currentDocument)\n      : Precondition.NONE;\n\n    if (proto.update) {\n      assertPresent(proto.update.name, 'name');\n      const key = this.fromName(proto.update.name!);\n      const value = this.fromFields(proto.update.fields || {});\n      if (proto.updateMask) {\n        const fieldMask = this.fromDocumentMask(proto.updateMask);\n        return new PatchMutation(key, value, fieldMask, precondition);\n      } else {\n        return new SetMutation(key, value, precondition);\n      }\n    } else if (proto.delete) {\n      const key = this.fromName(proto.delete);\n      return new DeleteMutation(key, precondition);\n    } else if (proto.transform) {\n      const key = this.fromName(proto.transform.document!);\n      const fieldTransforms = proto.transform.fieldTransforms!.map(transform =>\n        this.fromFieldTransform(transform)\n      );\n      assert(\n        precondition.exists === true,\n        'Transforms only support precondition \"exists == true\"'\n      );\n      return new TransformMutation(key, fieldTransforms);\n    } else {\n      return fail('unknown mutation proto: ' + JSON.stringify(proto));\n    }\n  }\n\n  private toPrecondition(precondition: Precondition): api.Precondition {\n    assert(!precondition.isNone, \"Can't serialize an empty precondition\");\n    if (precondition.updateTime !== undefined) {\n      return {\n        updateTime: this.toVersion(precondition.updateTime)\n      };\n    } else if (precondition.exists !== undefined) {\n      return { exists: precondition.exists };\n    } else {\n      return fail('Unknown precondition');\n    }\n  }\n\n  private fromPrecondition(precondition: api.Precondition): Precondition {\n    if (precondition.updateTime !== undefined) {\n      return Precondition.updateTime(this.fromVersion(precondition.updateTime));\n    } else if (precondition.exists !== undefined) {\n      return Precondition.exists(precondition.exists);\n    } else {\n      return Precondition.NONE;\n    }\n  }\n\n  private fromWriteResult(proto: api.WriteResult): MutationResult {\n    // NOTE: Deletes don't have an updateTime.\n    const version = proto.updateTime\n      ? this.fromVersion(proto.updateTime)\n      : null;\n    let transformResults: fieldValue.FieldValue[] | null = null;\n    if (proto.transformResults) {\n      transformResults = proto.transformResults.map(result =>\n        this.fromValue(result)\n      );\n    }\n    return new MutationResult(version, transformResults);\n  }\n\n  fromWriteResults(protos: api.WriteResult[] | undefined): MutationResult[] {\n    return (protos || []).map(proto => this.fromWriteResult(proto));\n  }\n\n  private toFieldTransform(fieldTransform: FieldTransform): api.FieldTransform {\n    assert(\n      fieldTransform.transform instanceof ServerTimestampTransform,\n      'Unknown transform: ' + fieldTransform.transform\n    );\n    return {\n      fieldPath: fieldTransform.field.canonicalString(),\n      setToServerValue: 'REQUEST_TIME'\n    };\n  }\n\n  private fromFieldTransform(proto: api.FieldTransform): FieldTransform {\n    assert(\n      proto.setToServerValue! === 'REQUEST_TIME',\n      'Unknown transform proto: ' + JSON.stringify(proto)\n    );\n    const fieldPath = FieldPath.fromServerFormat(proto.fieldPath!);\n    return new FieldTransform(fieldPath, ServerTimestampTransform.instance);\n  }\n\n  toDocumentsTarget(query: Query): api.DocumentsTarget {\n    return { documents: [this.toQueryPath(query.path)] };\n  }\n\n  fromDocumentsTarget(documentsTarget: api.DocumentsTarget): Query {\n    const count = documentsTarget.documents!.length;\n    assert(\n      count === 1,\n      'DocumentsTarget contained other than 1 document: ' + count\n    );\n    const name = documentsTarget.documents![0];\n    return Query.atPath(this.fromQueryPath(name));\n  }\n\n  toQueryTarget(query: Query): api.QueryTarget {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    const result: api.QueryTarget = { structuredQuery: {} };\n    if (query.path.isEmpty()) {\n      result.parent = this.toQueryPath(ResourcePath.EMPTY_PATH);\n    } else {\n      const path = query.path;\n      assert(\n        path.length % 2 !== 0,\n        'Document queries with filters are not supported.'\n      );\n      result.parent = this.toQueryPath(path.popLast());\n      result.structuredQuery!.from = [{ collectionId: path.lastSegment() }];\n    }\n\n    const where = this.toFilter(query.filters);\n    if (where) {\n      result.structuredQuery!.where = where;\n    }\n\n    const orderBy = this.toOrder(query.orderBy);\n    if (orderBy) {\n      result.structuredQuery!.orderBy = orderBy;\n    }\n\n    const limit = this.toLimit(query.limit);\n    if (limit !== undefined) {\n      result.structuredQuery!.limit = limit;\n    }\n\n    if (query.startAt) {\n      result.structuredQuery!.startAt = this.toCursor(query.startAt);\n    }\n    if (query.endAt) {\n      result.structuredQuery!.endAt = this.toCursor(query.endAt);\n    }\n\n    return result;\n  }\n\n  fromQueryTarget(target: api.QueryTarget): Query {\n    let path = this.fromQueryPath(target.parent!);\n\n    const query = target.structuredQuery!;\n    const fromCount = query.from ? query.from.length : 0;\n    if (fromCount > 0) {\n      assert(\n        fromCount === 1,\n        'StructuredQuery.from with more than one collection is not supported.'\n      );\n      const from = query.from![0];\n      path = path.child(from.collectionId!);\n    }\n\n    let filterBy: Filter[] = [];\n    if (query.where) {\n      filterBy = this.fromFilter(query.where);\n    }\n\n    let orderBy: OrderBy[] = [];\n    if (query.orderBy) {\n      orderBy = this.fromOrder(query.orderBy);\n    }\n\n    let limit: number | null = null;\n    if (query.limit) {\n      limit = query.limit;\n    }\n\n    let startAt: Bound | null = null;\n    if (query.startAt) {\n      startAt = this.fromCursor(query.startAt);\n    }\n\n    let endAt: Bound | null = null;\n    if (query.endAt) {\n      endAt = this.fromCursor(query.endAt);\n    }\n\n    return new Query(path, orderBy, filterBy, limit, startAt, endAt);\n  }\n\n  toListenRequestLabels(\n    queryData: QueryData\n  ): ApiClientObjectMap<string> | null {\n    const value = this.toLabel(queryData.purpose);\n    if (value == null) {\n      return null;\n    } else {\n      return {\n        'goog-listen-tags': value\n      };\n    }\n  }\n\n  private toLabel(purpose: QueryPurpose): string | null {\n    switch (purpose) {\n      case QueryPurpose.Listen:\n        return null;\n      case QueryPurpose.ExistenceFilterMismatch:\n        return 'existence-filter-mismatch';\n      case QueryPurpose.LimboResolution:\n        return 'limbo-document';\n      default:\n        return fail('Unrecognized query purpose: ' + purpose);\n    }\n  }\n\n  toTarget(queryData: QueryData): api.Target {\n    let result: api.Target;\n    const query = queryData.query;\n\n    if (query.isDocumentQuery()) {\n      result = { documents: this.toDocumentsTarget(query) };\n    } else {\n      result = { query: this.toQueryTarget(query) };\n    }\n\n    result.targetId = queryData.targetId;\n\n    if (queryData.resumeToken.length > 0) {\n      result.resumeToken = this.unsafeCastProtoByteString(\n        queryData.resumeToken\n      );\n    }\n\n    return result;\n  }\n\n  private toFilter(filters: Filter[]): api.Filter | undefined {\n    if (filters.length === 0) return;\n    const protos = filters.map(\n      filter =>\n        filter instanceof RelationFilter\n          ? this.toRelationFilter(filter)\n          : this.toUnaryFilter(filter)\n    );\n    if (protos.length === 1) {\n      return protos[0];\n    }\n    return { compositeFilter: { op: 'AND', filters: protos } };\n  }\n\n  private fromFilter(filter: api.Filter | undefined): Filter[] {\n    if (!filter) {\n      return [];\n    } else if (filter.unaryFilter !== undefined) {\n      return [this.fromUnaryFilter(filter)];\n    } else if (filter.fieldFilter !== undefined) {\n      return [this.fromRelationFilter(filter)];\n    } else if (filter.compositeFilter !== undefined) {\n      return filter.compositeFilter.filters!\n        .map(f => this.fromFilter(f))\n        .reduce((accum, current) => accum.concat(current));\n    } else {\n      return fail('Unknown filter: ' + JSON.stringify(filter));\n    }\n  }\n\n  private toOrder(orderBys: OrderBy[]): api.Order[] | undefined {\n    if (orderBys.length === 0) return;\n    return orderBys.map(order => this.toPropertyOrder(order));\n  }\n\n  private fromOrder(orderBys: api.Order[]): OrderBy[] {\n    return orderBys.map(order => this.fromPropertyOrder(order));\n  }\n\n  private toLimit(limit: number | null): number | undefined {\n    if (!typeUtils.isNullOrUndefined(limit)) {\n      return limit!;\n    }\n    return;\n  }\n\n  private toCursor(cursor: Bound): api.Cursor {\n    return {\n      before: cursor.before,\n      values: cursor.position.map(component => this.toValue(component))\n    };\n  }\n\n  private fromCursor(cursor: api.Cursor): Bound {\n    const before = !!cursor.before;\n    const position = cursor.values!.map(component => this.fromValue(component));\n    return new Bound(position, before);\n  }\n\n  // visible for testing\n  toDirection(dir: Direction): api.OrderDirection {\n    return DIRECTIONS[dir.name];\n  }\n\n  // visible for testing\n  fromDirection(dir: api.OrderDirection | undefined): Direction | undefined {\n    switch (dir) {\n      case 'ASCENDING':\n        return Direction.ASCENDING;\n      case 'DESCENDING':\n        return Direction.DESCENDING;\n      default:\n        return undefined;\n    }\n  }\n\n  // visible for testing\n  toOperatorName(op: RelationOp): api.FieldFilterOp {\n    return OPERATORS[op.name];\n  }\n\n  fromOperatorName(op: api.FieldFilterOp): RelationOp {\n    switch (op) {\n      case 'EQUAL':\n        return RelationOp.EQUAL;\n      case 'GREATER_THAN':\n        return RelationOp.GREATER_THAN;\n      case 'GREATER_THAN_OR_EQUAL':\n        return RelationOp.GREATER_THAN_OR_EQUAL;\n      case 'LESS_THAN':\n        return RelationOp.LESS_THAN;\n      case 'LESS_THAN_OR_EQUAL':\n        return RelationOp.LESS_THAN_OR_EQUAL;\n      case 'OPERATOR_UNSPECIFIED':\n        return fail('Unspecified relation');\n      default:\n        return fail('Unknown relation');\n    }\n  }\n\n  toFieldPathReference(path: FieldPath): api.FieldReference {\n    return { fieldPath: path.canonicalString() };\n  }\n\n  fromFieldPathReference(fieldReference: api.FieldReference): FieldPath {\n    return FieldPath.fromServerFormat(fieldReference.fieldPath!);\n  }\n\n  // visible for testing\n  toPropertyOrder(orderBy: OrderBy): api.Order {\n    return {\n      field: this.toFieldPathReference(orderBy.field),\n      direction: this.toDirection(orderBy.dir)\n    };\n  }\n\n  fromPropertyOrder(orderBy: api.Order): OrderBy {\n    return new OrderBy(\n      this.fromFieldPathReference(orderBy.field!),\n      this.fromDirection(orderBy.direction)\n    );\n  }\n\n  // visible for testing\n  toRelationFilter(filter: Filter): api.Filter {\n    if (filter instanceof RelationFilter) {\n      return {\n        fieldFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: this.toOperatorName(filter.op),\n          value: this.toValue(filter.value)\n        }\n      };\n    } else {\n      return fail('Unrecognized filter: ' + JSON.stringify(filter));\n    }\n  }\n\n  fromRelationFilter(filter: api.Filter): Filter {\n    return new RelationFilter(\n      this.fromFieldPathReference(filter.fieldFilter!.field!),\n      this.fromOperatorName(filter.fieldFilter!.op!),\n      this.fromValue(filter.fieldFilter!.value!)\n    );\n  }\n\n  // visible for testing\n  toUnaryFilter(filter: Filter): api.Filter {\n    if (filter instanceof NanFilter) {\n      return {\n        unaryFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: 'IS_NAN'\n        }\n      };\n    } else if (filter instanceof NullFilter) {\n      return {\n        unaryFilter: {\n          field: this.toFieldPathReference(filter.field),\n          op: 'IS_NULL'\n        }\n      };\n    } else {\n      return fail('Unrecognized filter: ' + JSON.stringify(filter));\n    }\n  }\n\n  fromUnaryFilter(filter: api.Filter): Filter {\n    switch (filter.unaryFilter!.op!) {\n      case 'IS_NAN':\n        const nanField = this.fromFieldPathReference(\n          filter.unaryFilter!.field!\n        );\n        return new NanFilter(nanField);\n      case 'IS_NULL':\n        const nullField = this.fromFieldPathReference(\n          filter.unaryFilter!.field!\n        );\n        return new NullFilter(nullField);\n      case 'OPERATOR_UNSPECIFIED':\n        return fail('Unspecified filter');\n      default:\n        return fail('Unknown filter');\n    }\n  }\n\n  toDocumentMask(fieldMask: FieldMask): api.DocumentMask {\n    return {\n      fieldPaths: fieldMask.fields.map(field => field.canonicalString())\n    };\n  }\n\n  fromDocumentMask(proto: api.DocumentMask): FieldMask {\n    const paths = proto.fieldPaths || [];\n    const fields = paths.map(path => FieldPath.fromServerFormat(path));\n    return new FieldMask(fields);\n  }\n}\n\n/**\n * Checks for a specific oneof tag in a protocol buffer message.\n *\n * This intentionally accommodates two distinct cases:\n *\n * 1) Messages containing a type tag: these are the format produced by GRPC in\n * return values. These may contain default-value mappings for all tags in the\n * oneof but the type tag specifies which one was actually set.\n *\n * 2) Messages that don't contain a type tag: these are the format required by\n * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would\n * choke claiming that the tags aren't fields in the Message.\n *\n * Allowing both formats here makes the serializer able to consume the outputs\n * it produces: for all messages it supports, fromX(toX(value)) == value.\n *\n * Note that case 2 suffers from ambiguity: if multiple tags are present\n * without a type tag then the callers are structured in such a way that the\n * first invocation will win. Since we only parse in this mode when parsing\n * the output of a serialize method this works, but it's not a general\n * solution.\n *\n * Unfortunately there is no general solution here because proto3 makes it\n * impossible to distinguish unset from explicitly set fields: both have the\n * default value for the type. Without the type tag but multiple value tags\n * it's possible to have default values for each tag in the oneof and not be\n * able to know which was actually in effect.\n */\nfunction hasTag(obj: {}, type: string, tag: string): boolean {\n  return type === tag || (!type && tag in obj);\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Blob } from '../api/blob';\nimport { GeoPoint } from '../api/geo_point';\nimport { DatabaseId } from '../core/database_info';\nimport { Bound, Direction, NanFilter, NullFilter, OrderBy, Query, RelationFilter, RelationOp } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { QueryPurpose } from '../local/query_data';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport * as fieldValue from '../model/field_value';\nimport { DeleteMutation, FieldMask, FieldTransform, MutationResult, PatchMutation, Precondition, ServerTimestampTransform, SetMutation, TransformMutation } from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as obj from '../util/obj';\nimport * as typeUtils from '../util/types';\nimport { ExistenceFilter } from './existence_filter';\nimport { mapCodeFromRpcCode, mapRpcCodeFromCode } from './rpc_error';\nimport { DocumentWatchChange, ExistenceFilterChange, WatchTargetChange, WatchTargetChangeState } from './watch_change';\nvar DIRECTIONS = (function () {\n    var dirs = {};\n    dirs[Direction.ASCENDING.name] = 'ASCENDING';\n    dirs[Direction.DESCENDING.name] = 'DESCENDING';\n    return dirs;\n})();\nvar OPERATORS = (function () {\n    var ops = {};\n    ops[RelationOp.LESS_THAN.name] = 'LESS_THAN';\n    ops[RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';\n    ops[RelationOp.GREATER_THAN.name] = 'GREATER_THAN';\n    ops[RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';\n    ops[RelationOp.EQUAL.name] = 'EQUAL';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n    assert(!typeUtils.isNullOrUndefined(value), description + ' is missing');\n}\nfunction parseInt64(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return parseInt(value, 10);\n    }\n    else {\n        return fail(\"can't parse \" + value);\n    }\n}\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nvar JsonProtoSerializer = /** @class */ (function () {\n    function JsonProtoSerializer(databaseId, options) {\n        this.databaseId = databaseId;\n        this.options = options;\n    }\n    JsonProtoSerializer.prototype.emptyByteString = function () {\n        if (this.options.useProto3Json) {\n            return '';\n        }\n        else {\n            return new Uint8Array(0);\n        }\n    };\n    JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) {\n        // byteStrings can be either string or UInt8Array, but the typings say\n        // it's always a string. Cast as string to avoid type check failing\n        return byteString;\n    };\n    JsonProtoSerializer.prototype.fromRpcStatus = function (status) {\n        var code = status.code === undefined\n            ? Code.UNKNOWN\n            : mapCodeFromRpcCode(status.code);\n        return new FirestoreError(code, status.message || '');\n    };\n    /**\n     * Returns a value for a Date that's appropriate to put into a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say dates must be. But it's easier and safer\n     * to actually return a Timestamp proto.\n     */\n    JsonProtoSerializer.prototype.toTimestamp = function (timestamp) {\n        return {\n            seconds: timestamp.seconds,\n            nanos: timestamp.nanos\n            // tslint:disable-next-line:no-any\n        };\n    };\n    JsonProtoSerializer.prototype.fromTimestamp = function (date) {\n        // The json interface (for the browser) will return an iso timestamp string,\n        // while the proto js library (for node) will return a\n        // google.protobuf.Timestamp instance.\n        if (typeof date === 'string') {\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(this.options.useProto3Json,\n            //   'The timestamp string format requires Proto3.');\n            return Timestamp.fromISOString(date);\n        }\n        else {\n            assert(!!date, 'Cannot deserialize null or undefined timestamp.');\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(!this.options.useProto3Json,\n            //   'The timestamp instance format requires Proto JS.');\n            var seconds = parseInt64(date.seconds || '0');\n            var nanos = date.nanos || 0;\n            return new Timestamp(seconds, nanos);\n        }\n    };\n    /**\n     * Returns a value for bytes that's appropriate to put in a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say bytes must be. But it should return\n     * an Uint8Array in Node.\n     */\n    JsonProtoSerializer.prototype.toBytes = function (bytes) {\n        if (this.options.useProto3Json) {\n            return bytes.toBase64();\n        }\n        else {\n            // The typings say it's a string, but it needs to be a Uint8Array in Node.\n            return this.unsafeCastProtoByteString(bytes.toUint8Array());\n        }\n    };\n    /**\n     * Parse the blob from the protos into the internal Blob class. Note that the\n     * typings assume all blobs are strings, but they are actually Uint8Arrays\n     * on Node.\n     */\n    JsonProtoSerializer.prototype.fromBlob = function (blob) {\n        if (typeof blob === 'string') {\n            assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');\n            return Blob.fromBase64String(blob);\n        }\n        else {\n            assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');\n            return Blob.fromUint8Array(blob);\n        }\n    };\n    JsonProtoSerializer.prototype.toVersion = function (version) {\n        return this.toTimestamp(version.toTimestamp());\n    };\n    JsonProtoSerializer.prototype.fromVersion = function (version) {\n        assert(!!version, \"Trying to deserialize version that isn't set\");\n        return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n    };\n    JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) {\n        return this.fullyQualifiedPrefixPath(databaseId)\n            .child('documents')\n            .child(path)\n            .canonicalString();\n    };\n    JsonProtoSerializer.prototype.fromResourceName = function (name) {\n        var resource = ResourcePath.fromString(name);\n        assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());\n        return resource;\n    };\n    JsonProtoSerializer.prototype.toName = function (key) {\n        return this.toResourceName(this.databaseId, key.path);\n    };\n    JsonProtoSerializer.prototype.fromName = function (name) {\n        var resource = this.fromResourceName(name);\n        assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            this.databaseId.projectId);\n        assert((!resource.get(3) && !this.databaseId.database) ||\n            resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            this.databaseId.database);\n        return new DocumentKey(this.extractLocalPathFromResourceName(resource));\n    };\n    JsonProtoSerializer.prototype.toQueryPath = function (path) {\n        if (path.length === 0) {\n            // If the path is empty, the backend requires we leave off the /documents\n            // at the end.\n            return this.encodedDatabaseId;\n        }\n        return this.toResourceName(this.databaseId, path);\n    };\n    JsonProtoSerializer.prototype.fromQueryPath = function (name) {\n        var resourceName = this.fromResourceName(name);\n        if (resourceName.length === 4) {\n            return ResourcePath.EMPTY_PATH;\n        }\n        return this.extractLocalPathFromResourceName(resourceName);\n    };\n    Object.defineProperty(JsonProtoSerializer.prototype, \"encodedDatabaseId\", {\n        get: function () {\n            var path = new ResourcePath([\n                'projects',\n                this.databaseId.projectId,\n                'databases',\n                this.databaseId.database\n            ]);\n            return path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) {\n        return new ResourcePath([\n            'projects',\n            databaseId.projectId,\n            'databases',\n            databaseId.database\n        ]);\n    };\n    JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) {\n        assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());\n        return resourceName.popFirst(5);\n    };\n    JsonProtoSerializer.prototype.isValidResourceName = function (path) {\n        // Resource names have at least 4 components (project ID, database ID)\n        return (path.length >= 4 &&\n            path.get(0) === 'projects' &&\n            path.get(2) === 'databases');\n    };\n    JsonProtoSerializer.prototype.toValue = function (val) {\n        if (val instanceof fieldValue.NullValue) {\n            return { nullValue: 'NULL_VALUE' };\n        }\n        else if (val instanceof fieldValue.BooleanValue) {\n            return { booleanValue: val.value() };\n        }\n        else if (val instanceof fieldValue.IntegerValue) {\n            return { integerValue: '' + val.value() };\n        }\n        else if (val instanceof fieldValue.DoubleValue) {\n            var doubleValue = val.value();\n            if (this.options.useProto3Json) {\n                // Proto 3 let's us encode NaN and Infinity as string values as\n                // expected by the backend. This is currently not checked by our unit\n                // tests because they rely on protobuf.js.\n                if (isNaN(doubleValue)) {\n                    return { doubleValue: 'NaN' };\n                }\n                else if (doubleValue === Infinity) {\n                    return { doubleValue: 'Infinity' };\n                }\n                else if (doubleValue === -Infinity) {\n                    return { doubleValue: '-Infinity' };\n                }\n            }\n            return { doubleValue: val.value() };\n        }\n        else if (val instanceof fieldValue.StringValue) {\n            return { stringValue: val.value() };\n        }\n        else if (val instanceof fieldValue.ObjectValue) {\n            return { mapValue: this.toMapValue(val) };\n        }\n        else if (val instanceof fieldValue.ArrayValue) {\n            return { arrayValue: this.toArrayValue(val) };\n        }\n        else if (val instanceof fieldValue.TimestampValue) {\n            return {\n                timestampValue: this.toTimestamp(val.internalValue)\n            };\n        }\n        else if (val instanceof fieldValue.GeoPointValue) {\n            return {\n                geoPointValue: {\n                    latitude: val.value().latitude,\n                    longitude: val.value().longitude\n                }\n            };\n        }\n        else if (val instanceof fieldValue.BlobValue) {\n            return {\n                bytesValue: this.toBytes(val.value())\n            };\n        }\n        else if (val instanceof fieldValue.RefValue) {\n            return {\n                referenceValue: this.toResourceName(val.databaseId, val.key.path)\n            };\n        }\n        else {\n            return fail('Unknown FieldValue ' + JSON.stringify(val));\n        }\n    };\n    JsonProtoSerializer.prototype.fromValue = function (obj) {\n        var _this = this;\n        // tslint:disable-next-line:no-any\n        var type = obj['value_type'];\n        if (hasTag(obj, type, 'nullValue')) {\n            return fieldValue.NullValue.INSTANCE;\n        }\n        else if (hasTag(obj, type, 'booleanValue')) {\n            return fieldValue.BooleanValue.of(obj.booleanValue);\n        }\n        else if (hasTag(obj, type, 'integerValue')) {\n            return new fieldValue.IntegerValue(parseInt64(obj.integerValue));\n        }\n        else if (hasTag(obj, type, 'doubleValue')) {\n            if (this.options.useProto3Json) {\n                // Proto 3 uses the string values 'NaN' and 'Infinity'.\n                if (obj.doubleValue === 'NaN') {\n                    return fieldValue.DoubleValue.NAN;\n                }\n                else if (obj.doubleValue === 'Infinity') {\n                    return fieldValue.DoubleValue.POSITIVE_INFINITY;\n                }\n                else if (obj.doubleValue === '-Infinity') {\n                    return fieldValue.DoubleValue.NEGATIVE_INFINITY;\n                }\n            }\n            return new fieldValue.DoubleValue(obj.doubleValue);\n        }\n        else if (hasTag(obj, type, 'stringValue')) {\n            return new fieldValue.StringValue(obj.stringValue);\n        }\n        else if (hasTag(obj, type, 'mapValue')) {\n            return this.fromFields(obj.mapValue.fields || {});\n        }\n        else if (hasTag(obj, type, 'arrayValue')) {\n            // \"values\" is not present if the array is empty\n            assertPresent(obj.arrayValue, 'arrayValue');\n            var values = obj.arrayValue.values || [];\n            return new fieldValue.ArrayValue(values.map(function (v) { return _this.fromValue(v); }));\n        }\n        else if (hasTag(obj, type, 'timestampValue')) {\n            assertPresent(obj.timestampValue, 'timestampValue');\n            return new fieldValue.TimestampValue(this.fromTimestamp(obj.timestampValue));\n        }\n        else if (hasTag(obj, type, 'geoPointValue')) {\n            assertPresent(obj.geoPointValue, 'geoPointValue');\n            var latitude = obj.geoPointValue.latitude || 0;\n            var longitude = obj.geoPointValue.longitude || 0;\n            return new fieldValue.GeoPointValue(new GeoPoint(latitude, longitude));\n        }\n        else if (hasTag(obj, type, 'bytesValue')) {\n            assertPresent(obj.bytesValue, 'bytesValue');\n            var blob = this.fromBlob(obj.bytesValue);\n            return new fieldValue.BlobValue(blob);\n        }\n        else if (hasTag(obj, type, 'referenceValue')) {\n            assertPresent(obj.referenceValue, 'referenceValue');\n            var resourceName = this.fromResourceName(obj.referenceValue);\n            var dbId = new DatabaseId(resourceName.get(1), resourceName.get(3));\n            var key = new DocumentKey(this.extractLocalPathFromResourceName(resourceName));\n            return new fieldValue.RefValue(dbId, key);\n        }\n        else {\n            return fail('Unknown Value proto ' + JSON.stringify(obj));\n        }\n    };\n    /** Creates an api.Document from key and fields (but no create/update time) */\n    JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) {\n        return {\n            name: this.toName(key),\n            fields: this.toFields(fields)\n        };\n    };\n    JsonProtoSerializer.prototype.toDocument = function (document) {\n        assert(!document.hasLocalMutations, \"Can't serialize documents with mutations.\");\n        return {\n            name: this.toName(document.key),\n            fields: this.toFields(document.data),\n            updateTime: this.toTimestamp(document.version.toTimestamp())\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocument = function (document) {\n        return new Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.toFields = function (fields) {\n        var _this = this;\n        var result = {};\n        fields.forEach(function (key, value) {\n            result[key] = _this.toValue(value);\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromFields = function (object) {\n        var _this = this;\n        // Proto map<string, Value> gets mapped to Object, so cast it.\n        var map = object;\n        var result = fieldValue.ObjectValue.EMPTY;\n        obj.forEach(map, function (key, value) {\n            result = result.set(new FieldPath([key]), _this.fromValue(value));\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.toMapValue = function (map) {\n        return {\n            fields: this.toFields(map)\n        };\n    };\n    JsonProtoSerializer.prototype.toArrayValue = function (array) {\n        var _this = this;\n        var result = [];\n        array.forEach(function (value) {\n            result.push(_this.toValue(value));\n        });\n        return { values: result };\n    };\n    JsonProtoSerializer.prototype.fromFound = function (doc) {\n        assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');\n        assertPresent(doc.found.name, 'doc.found.name');\n        assertPresent(doc.found.updateTime, 'doc.found.updateTime');\n        var key = this.fromName(doc.found.name);\n        var version = this.fromVersion(doc.found.updateTime);\n        var fields = this.fromFields(doc.found.fields || {});\n        return new Document(key, version, fields, { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.fromMissing = function (result) {\n        assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');\n        assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');\n        var key = this.fromName(result.missing);\n        var version = this.fromVersion(result.readTime);\n        return new NoDocument(key, version);\n    };\n    JsonProtoSerializer.prototype.fromMaybeDocument = function (result) {\n        // tslint:disable-next-line:no-any\n        var type = result['result_type'];\n        if (hasTag(result, type, 'found')) {\n            return this.fromFound(result);\n        }\n        else if (hasTag(result, type, 'missing')) {\n            return this.fromMissing(result);\n        }\n        return fail('invalid batch get response: ' + JSON.stringify(result));\n    };\n    JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) {\n        switch (state) {\n            case WatchTargetChangeState.Added:\n                return 'ADD';\n            case WatchTargetChangeState.Current:\n                return 'CURRENT';\n            case WatchTargetChangeState.NoChange:\n                return 'NO_CHANGE';\n            case WatchTargetChangeState.Removed:\n                return 'REMOVE';\n            case WatchTargetChangeState.Reset:\n                return 'RESET';\n            default:\n                return fail('Unknown WatchTargetChangeState: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) {\n        if (watchChange instanceof ExistenceFilterChange) {\n            return {\n                filter: {\n                    count: watchChange.existenceFilter.count,\n                    targetId: watchChange.targetId\n                }\n            };\n        }\n        if (watchChange instanceof DocumentWatchChange) {\n            if (watchChange.newDoc instanceof Document) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentChange: {\n                        document: {\n                            name: this.toName(doc.key),\n                            fields: this.toFields(doc.data),\n                            updateTime: this.toVersion(doc.version)\n                        },\n                        targetIds: watchChange.updatedTargetIds,\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc instanceof NoDocument) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentDelete: {\n                        document: this.toName(doc.key),\n                        readTime: this.toVersion(doc.version),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc === null) {\n                return {\n                    documentRemove: {\n                        document: this.toName(watchChange.key),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n        }\n        if (watchChange instanceof WatchTargetChange) {\n            var cause = undefined;\n            if (watchChange.cause) {\n                cause = {\n                    code: mapRpcCodeFromCode(watchChange.cause.code),\n                    message: watchChange.cause.message\n                };\n            }\n            return {\n                targetChange: {\n                    targetChangeType: this.toWatchTargetChangeState(watchChange.state),\n                    targetIds: watchChange.targetIds,\n                    resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),\n                    cause: cause\n                }\n            };\n        }\n        return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));\n    };\n    JsonProtoSerializer.prototype.fromWatchChange = function (change) {\n        // tslint:disable-next-line:no-any\n        var type = change['change_type'];\n        var watchChange;\n        if (hasTag(change, type, 'targetChange')) {\n            assertPresent(change.targetChange, 'targetChange');\n            // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n            // if unset\n            var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n            var targetIds = change.targetChange.targetIds || [];\n            var resumeToken = change.targetChange.resumeToken || this.emptyByteString();\n            var causeProto = change.targetChange.cause;\n            var cause = causeProto && this.fromRpcStatus(causeProto);\n            watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\n        }\n        else if (hasTag(change, type, 'documentChange')) {\n            assertPresent(change.documentChange, 'documentChange');\n            assertPresent(change.documentChange.document, 'documentChange.name');\n            assertPresent(change.documentChange.document.name, 'documentChange.document.name');\n            assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');\n            var entityChange = change.documentChange;\n            var key = this.fromName(entityChange.document.name);\n            var version = this.fromVersion(entityChange.document.updateTime);\n            var fields = this.fromFields(entityChange.document.fields || {});\n            var doc = new Document(key, version, fields, {\n                hasLocalMutations: false\n            });\n            var updatedTargetIds = entityChange.targetIds || [];\n            var removedTargetIds = entityChange.removedTargetIds || [];\n            watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentDelete')) {\n            assertPresent(change.documentDelete, 'documentDelete');\n            assertPresent(change.documentDelete.document, 'documentDelete.document');\n            var docDelete = change.documentDelete;\n            var key = this.fromName(docDelete.document);\n            var version = docDelete.readTime\n                ? this.fromVersion(docDelete.readTime)\n                : SnapshotVersion.forDeletedDoc();\n            var doc = new NoDocument(key, version);\n            var removedTargetIds = docDelete.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentRemove')) {\n            assertPresent(change.documentRemove, 'documentRemove');\n            assertPresent(change.documentRemove.document, 'documentRemove');\n            var docRemove = change.documentRemove;\n            var key = this.fromName(docRemove.document);\n            var removedTargetIds = docRemove.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n        }\n        else if (hasTag(change, type, 'filter')) {\n            // TODO(dimond): implement existence filter parsing with strategy.\n            assertPresent(change.filter, 'filter');\n            assertPresent(change.filter.targetId, 'filter.targetId');\n            var filter = change.filter;\n            var count = filter.count || 0;\n            var existenceFilter = new ExistenceFilter(count);\n            var targetId = filter.targetId;\n            watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n        }\n        else {\n            return fail('Unknown change type ' + JSON.stringify(change));\n        }\n        return watchChange;\n    };\n    JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) {\n        if (state === 'NO_CHANGE') {\n            return WatchTargetChangeState.NoChange;\n        }\n        else if (state === 'ADD') {\n            return WatchTargetChangeState.Added;\n        }\n        else if (state === 'REMOVE') {\n            return WatchTargetChangeState.Removed;\n        }\n        else if (state === 'CURRENT') {\n            return WatchTargetChangeState.Current;\n        }\n        else if (state === 'RESET') {\n            return WatchTargetChangeState.Reset;\n        }\n        else {\n            return fail('Got unexpected TargetChange.state: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.versionFromListenResponse = function (change) {\n        // We have only reached a consistent snapshot for the entire stream if there\n        // is a read_time set and it applies to all targets (i.e. the list of\n        // targets is empty). The backend is guaranteed to send such responses.\n        // tslint:disable-next-line:no-any\n        var type = change['response_type'];\n        if (!hasTag(change, type, 'targetChange')) {\n            return SnapshotVersion.MIN;\n        }\n        var targetChange = change.targetChange;\n        if (targetChange.targetIds && targetChange.targetIds.length) {\n            return SnapshotVersion.MIN;\n        }\n        if (!targetChange.readTime) {\n            return SnapshotVersion.MIN;\n        }\n        return this.fromVersion(targetChange.readTime);\n    };\n    JsonProtoSerializer.prototype.toMutation = function (mutation) {\n        var _this = this;\n        var result;\n        if (mutation instanceof SetMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.value)\n            };\n        }\n        else if (mutation instanceof DeleteMutation) {\n            result = { delete: this.toName(mutation.key) };\n        }\n        else if (mutation instanceof PatchMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.data),\n                updateMask: this.toDocumentMask(mutation.fieldMask)\n            };\n        }\n        else if (mutation instanceof TransformMutation) {\n            result = {\n                transform: {\n                    document: this.toName(mutation.key),\n                    fieldTransforms: mutation.fieldTransforms.map(function (transform) {\n                        return _this.toFieldTransform(transform);\n                    })\n                }\n            };\n        }\n        else {\n            return fail('Unknown mutation type ' + mutation.type);\n        }\n        if (!mutation.precondition.isNone) {\n            result.currentDocument = this.toPrecondition(mutation.precondition);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromMutation = function (proto) {\n        var _this = this;\n        var precondition = proto.currentDocument\n            ? this.fromPrecondition(proto.currentDocument)\n            : Precondition.NONE;\n        if (proto.update) {\n            assertPresent(proto.update.name, 'name');\n            var key = this.fromName(proto.update.name);\n            var value = this.fromFields(proto.update.fields || {});\n            if (proto.updateMask) {\n                var fieldMask = this.fromDocumentMask(proto.updateMask);\n                return new PatchMutation(key, value, fieldMask, precondition);\n            }\n            else {\n                return new SetMutation(key, value, precondition);\n            }\n        }\n        else if (proto.delete) {\n            var key = this.fromName(proto.delete);\n            return new DeleteMutation(key, precondition);\n        }\n        else if (proto.transform) {\n            var key = this.fromName(proto.transform.document);\n            var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) {\n                return _this.fromFieldTransform(transform);\n            });\n            assert(precondition.exists === true, 'Transforms only support precondition \"exists == true\"');\n            return new TransformMutation(key, fieldTransforms);\n        }\n        else {\n            return fail('unknown mutation proto: ' + JSON.stringify(proto));\n        }\n    };\n    JsonProtoSerializer.prototype.toPrecondition = function (precondition) {\n        assert(!precondition.isNone, \"Can't serialize an empty precondition\");\n        if (precondition.updateTime !== undefined) {\n            return {\n                updateTime: this.toVersion(precondition.updateTime)\n            };\n        }\n        else if (precondition.exists !== undefined) {\n            return { exists: precondition.exists };\n        }\n        else {\n            return fail('Unknown precondition');\n        }\n    };\n    JsonProtoSerializer.prototype.fromPrecondition = function (precondition) {\n        if (precondition.updateTime !== undefined) {\n            return Precondition.updateTime(this.fromVersion(precondition.updateTime));\n        }\n        else if (precondition.exists !== undefined) {\n            return Precondition.exists(precondition.exists);\n        }\n        else {\n            return Precondition.NONE;\n        }\n    };\n    JsonProtoSerializer.prototype.fromWriteResult = function (proto) {\n        var _this = this;\n        // NOTE: Deletes don't have an updateTime.\n        var version = proto.updateTime\n            ? this.fromVersion(proto.updateTime)\n            : null;\n        var transformResults = null;\n        if (proto.transformResults) {\n            transformResults = proto.transformResults.map(function (result) {\n                return _this.fromValue(result);\n            });\n        }\n        return new MutationResult(version, transformResults);\n    };\n    JsonProtoSerializer.prototype.fromWriteResults = function (protos) {\n        var _this = this;\n        return (protos || []).map(function (proto) { return _this.fromWriteResult(proto); });\n    };\n    JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) {\n        assert(fieldTransform.transform instanceof ServerTimestampTransform, 'Unknown transform: ' + fieldTransform.transform);\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    };\n    JsonProtoSerializer.prototype.fromFieldTransform = function (proto) {\n        assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown transform proto: ' + JSON.stringify(proto));\n        var fieldPath = FieldPath.fromServerFormat(proto.fieldPath);\n        return new FieldTransform(fieldPath, ServerTimestampTransform.instance);\n    };\n    JsonProtoSerializer.prototype.toDocumentsTarget = function (query) {\n        return { documents: [this.toQueryPath(query.path)] };\n    };\n    JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) {\n        var count = documentsTarget.documents.length;\n        assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);\n        var name = documentsTarget.documents[0];\n        return Query.atPath(this.fromQueryPath(name));\n    };\n    JsonProtoSerializer.prototype.toQueryTarget = function (query) {\n        // Dissect the path into parent, collectionId, and optional key filter.\n        var result = { structuredQuery: {} };\n        if (query.path.isEmpty()) {\n            result.parent = this.toQueryPath(ResourcePath.EMPTY_PATH);\n        }\n        else {\n            var path = query.path;\n            assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');\n            result.parent = this.toQueryPath(path.popLast());\n            result.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n        }\n        var where = this.toFilter(query.filters);\n        if (where) {\n            result.structuredQuery.where = where;\n        }\n        var orderBy = this.toOrder(query.orderBy);\n        if (orderBy) {\n            result.structuredQuery.orderBy = orderBy;\n        }\n        var limit = this.toLimit(query.limit);\n        if (limit !== undefined) {\n            result.structuredQuery.limit = limit;\n        }\n        if (query.startAt) {\n            result.structuredQuery.startAt = this.toCursor(query.startAt);\n        }\n        if (query.endAt) {\n            result.structuredQuery.endAt = this.toCursor(query.endAt);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromQueryTarget = function (target) {\n        var path = this.fromQueryPath(target.parent);\n        var query = target.structuredQuery;\n        var fromCount = query.from ? query.from.length : 0;\n        if (fromCount > 0) {\n            assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');\n            var from = query.from[0];\n            path = path.child(from.collectionId);\n        }\n        var filterBy = [];\n        if (query.where) {\n            filterBy = this.fromFilter(query.where);\n        }\n        var orderBy = [];\n        if (query.orderBy) {\n            orderBy = this.fromOrder(query.orderBy);\n        }\n        var limit = null;\n        if (query.limit) {\n            limit = query.limit;\n        }\n        var startAt = null;\n        if (query.startAt) {\n            startAt = this.fromCursor(query.startAt);\n        }\n        var endAt = null;\n        if (query.endAt) {\n            endAt = this.fromCursor(query.endAt);\n        }\n        return new Query(path, orderBy, filterBy, limit, startAt, endAt);\n    };\n    JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) {\n        var value = this.toLabel(queryData.purpose);\n        if (value == null) {\n            return null;\n        }\n        else {\n            return {\n                'goog-listen-tags': value\n            };\n        }\n    };\n    JsonProtoSerializer.prototype.toLabel = function (purpose) {\n        switch (purpose) {\n            case QueryPurpose.Listen:\n                return null;\n            case QueryPurpose.ExistenceFilterMismatch:\n                return 'existence-filter-mismatch';\n            case QueryPurpose.LimboResolution:\n                return 'limbo-document';\n            default:\n                return fail('Unrecognized query purpose: ' + purpose);\n        }\n    };\n    JsonProtoSerializer.prototype.toTarget = function (queryData) {\n        var result;\n        var query = queryData.query;\n        if (query.isDocumentQuery()) {\n            result = { documents: this.toDocumentsTarget(query) };\n        }\n        else {\n            result = { query: this.toQueryTarget(query) };\n        }\n        result.targetId = queryData.targetId;\n        if (queryData.resumeToken.length > 0) {\n            result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.toFilter = function (filters) {\n        var _this = this;\n        if (filters.length === 0)\n            return;\n        var protos = filters.map(function (filter) {\n            return filter instanceof RelationFilter\n                ? _this.toRelationFilter(filter)\n                : _this.toUnaryFilter(filter);\n        });\n        if (protos.length === 1) {\n            return protos[0];\n        }\n        return { compositeFilter: { op: 'AND', filters: protos } };\n    };\n    JsonProtoSerializer.prototype.fromFilter = function (filter) {\n        var _this = this;\n        if (!filter) {\n            return [];\n        }\n        else if (filter.unaryFilter !== undefined) {\n            return [this.fromUnaryFilter(filter)];\n        }\n        else if (filter.fieldFilter !== undefined) {\n            return [this.fromRelationFilter(filter)];\n        }\n        else if (filter.compositeFilter !== undefined) {\n            return filter.compositeFilter.filters\n                .map(function (f) { return _this.fromFilter(f); })\n                .reduce(function (accum, current) { return accum.concat(current); });\n        }\n        else {\n            return fail('Unknown filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.toOrder = function (orderBys) {\n        var _this = this;\n        if (orderBys.length === 0)\n            return;\n        return orderBys.map(function (order) { return _this.toPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.fromOrder = function (orderBys) {\n        var _this = this;\n        return orderBys.map(function (order) { return _this.fromPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.toLimit = function (limit) {\n        if (!typeUtils.isNullOrUndefined(limit)) {\n            return limit;\n        }\n        return;\n    };\n    JsonProtoSerializer.prototype.toCursor = function (cursor) {\n        var _this = this;\n        return {\n            before: cursor.before,\n            values: cursor.position.map(function (component) { return _this.toValue(component); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromCursor = function (cursor) {\n        var _this = this;\n        var before = !!cursor.before;\n        var position = cursor.values.map(function (component) { return _this.fromValue(component); });\n        return new Bound(position, before);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toDirection = function (dir) {\n        return DIRECTIONS[dir.name];\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.fromDirection = function (dir) {\n        switch (dir) {\n            case 'ASCENDING':\n                return Direction.ASCENDING;\n            case 'DESCENDING':\n                return Direction.DESCENDING;\n            default:\n                return undefined;\n        }\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toOperatorName = function (op) {\n        return OPERATORS[op.name];\n    };\n    JsonProtoSerializer.prototype.fromOperatorName = function (op) {\n        switch (op) {\n            case 'EQUAL':\n                return RelationOp.EQUAL;\n            case 'GREATER_THAN':\n                return RelationOp.GREATER_THAN;\n            case 'GREATER_THAN_OR_EQUAL':\n                return RelationOp.GREATER_THAN_OR_EQUAL;\n            case 'LESS_THAN':\n                return RelationOp.LESS_THAN;\n            case 'LESS_THAN_OR_EQUAL':\n                return RelationOp.LESS_THAN_OR_EQUAL;\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified relation');\n            default:\n                return fail('Unknown relation');\n        }\n    };\n    JsonProtoSerializer.prototype.toFieldPathReference = function (path) {\n        return { fieldPath: path.canonicalString() };\n    };\n    JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) {\n        return FieldPath.fromServerFormat(fieldReference.fieldPath);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) {\n        return {\n            field: this.toFieldPathReference(orderBy.field),\n            direction: this.toDirection(orderBy.dir)\n        };\n    };\n    JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) {\n        return new OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toRelationFilter = function (filter) {\n        if (filter instanceof RelationFilter) {\n            return {\n                fieldFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: this.toOperatorName(filter.op),\n                    value: this.toValue(filter.value)\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromRelationFilter = function (filter) {\n        return new RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toUnaryFilter = function (filter) {\n        if (filter instanceof NanFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (filter instanceof NullFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) {\n        switch (filter.unaryFilter.op) {\n            case 'IS_NAN':\n                var nanField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NanFilter(nanField);\n            case 'IS_NULL':\n                var nullField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NullFilter(nullField);\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified filter');\n            default:\n                return fail('Unknown filter');\n        }\n    };\n    JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) {\n        return {\n            fieldPaths: fieldMask.fields.map(function (field) { return field.canonicalString(); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocumentMask = function (proto) {\n        var paths = proto.fieldPaths || [];\n        var fields = paths.map(function (path) { return FieldPath.fromServerFormat(path); });\n        return new FieldMask(fields);\n    };\n    return JsonProtoSerializer;\n}());\nexport { JsonProtoSerializer };\n/**\n * Checks for a specific oneof tag in a protocol buffer message.\n *\n * This intentionally accommodates two distinct cases:\n *\n * 1) Messages containing a type tag: these are the format produced by GRPC in\n * return values. These may contain default-value mappings for all tags in the\n * oneof but the type tag specifies which one was actually set.\n *\n * 2) Messages that don't contain a type tag: these are the format required by\n * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would\n * choke claiming that the tags aren't fields in the Message.\n *\n * Allowing both formats here makes the serializer able to consume the outputs\n * it produces: for all messages it supports, fromX(toX(value)) == value.\n *\n * Note that case 2 suffers from ambiguity: if multiple tags are present\n * without a type tag then the callers are structured in such a way that the\n * first invocation will win. Since we only parse in this mode when parsing\n * the output of a serialize method this works, but it's not a general\n * solution.\n *\n * Unfortunately there is no general solution here because proto3 makes it\n * impossible to distinguish unset from explicitly set fields: both have the\n * default value for the type. Without the type tag but multiple value tags\n * it's possible to have default values for each tag in the oneof and not be\n * able to know which was actually in effect.\n */\nfunction hasTag(obj, type, tag) {\n    return type === tag || (!type && tag in obj);\n}\n\n\n"]}