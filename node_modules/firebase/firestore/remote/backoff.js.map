{"version":3,"sources":["src/firestore/remote/backoff.ts","firestore/remote/backoff.js"],"names":["log","LOG_TAG","ExponentialBackoff","initialDelayMs","backoffFactor","maxDelayMs","reset","prototype","currentBaseMs","resetToMax","backoffAndWait","def","delayWithJitterMs","jitterDelayMs","debug","setTimeout","resolve","promise","Math","random"],"mappings":";;;;;;;AAgBA;;IAAYA,G;;AACZ;;;;AAjBA;;;;;;;;;;;;;;;AAmBA,IAAMC,UAAU,oBAAhB;AAEA;;;;;;;;;AASA,IAAAC,qBAAA,aAAA,YAAA;AAGE,aAAAA,kBAAA;AACE;;;;;AAKiBC,kBANnB;AAOE;;;;AAIiBC,iBAXnB;AAYE;;;;;AAKiBC,cAjBnB,EAiBqC;AAXlB,aAAAF,cAAA,GAAAA,cAAA;AAKA,aAAAC,aAAA,GAAAA,aAAA;AAMA,aAAAC,UAAA,GAAAA,UAAA;AAEjB,aAAKC,KAAL;AACD;AAED;;;;;;;AAOAJ,uBAAAK,SAAA,CAAAD,KAAA,GAAA,YAAA;AACE,aAAKE,aAAL,GAAqB,CAArB;AACD,KAFD;AAIA;;;;AAIAN,uBAAAK,SAAA,CAAAE,UAAA,GAAA,YAAA;AACE,aAAKD,aAAL,GAAqB,KAAKH,UAA1B;AACD,KAFD;AAIA;;;;AAIAH,uBAAAK,SAAA,CAAAG,cAAA,GAAA,YAAA;AACE,YAAMC,MAAM,uBAAZ;AAEA;AACA;AACA,YAAMC,oBAAoB,KAAKJ,aAAL,GAAqB,KAAKK,aAAL,EAA/C;AACA,YAAI,KAAKL,aAAL,GAAqB,CAAzB,EAA4B;AAC1BR,gBAAIc,KAAJ,CACEb,OADF,EAEE,qBAAmBW,iBAAnB,GAAoC,MAApC,IACE,kBAAgB,KAAKJ,aAArB,GAAkC,MADpC,CAFF;AAKD;AACDO,mBAAW,YAAA;AACTJ,gBAAIK,OAAJ;AACD,SAFD,EAEGJ,iBAFH;AAIA;AACA;AACA,aAAKJ,aAAL,IAAsB,KAAKJ,aAA3B;AACA,YAAI,KAAKI,aAAL,GAAqB,KAAKL,cAA9B,EAA8C;AAC5C,iBAAKK,aAAL,GAAqB,KAAKL,cAA1B;AACD;AACD,YAAI,KAAKK,aAAL,GAAqB,KAAKH,UAA9B,EAA0C;AACxC,iBAAKG,aAAL,GAAqB,KAAKH,UAA1B;AACD;AAED,eAAOM,IAAIM,OAAX;AACD,KA5BD;AA8BA;AACQf,uBAAAK,SAAA,CAAAM,aAAA,GAAR,YAAA;AACE,eAAO,CAACK,KAAKC,MAAL,KAAgB,GAAjB,IAAwB,KAAKX,aAApC;AACD,KAFO;AAGV,WAAAN,kBAAA;AAlFA,CAAA,EAAA;QCuESA,kB,GAAAA,kB","file":"backoff.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as log from '../util/log';\nimport { Deferred } from '../util/promise';\n\nconst LOG_TAG = 'ExponentialBackoff';\n\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nexport class ExponentialBackoff {\n  private currentBaseMs: number;\n\n  constructor(\n    /**\n       * The initial delay (used as the base delay on the first retry attempt).\n       * Note that jitter will still be applied, so the actual delay could be as\n       * little as 0.5*initialDelayMs.\n       */\n    private readonly initialDelayMs: number,\n    /**\n       * The multiplier to use to determine the extended base delay after each\n       * attempt.\n       */\n    private readonly backoffFactor: number,\n    /**\n       * The maximum base delay after which no further backoff is performed.\n       * Note that jitter will still be applied, so the actual delay could be as\n       * much as 1.5*maxDelayMs.\n       */\n    private readonly maxDelayMs: number\n  ) {\n    this.reset();\n  }\n\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n  reset(): void {\n    this.currentBaseMs = 0;\n  }\n\n  /**\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\n   * RESOURCE_EXHAUSTED error).\n   */\n  resetToMax(): void {\n    this.currentBaseMs = this.maxDelayMs;\n  }\n\n  /**\n   * Returns a promise that resolves after currentDelayMs, and increases the\n   * delay for any subsequent attempts.\n   */\n  backoffAndWait(): Promise<void> {\n    const def = new Deferred<void>();\n\n    // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n    const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n    if (this.currentBaseMs > 0) {\n      log.debug(\n        LOG_TAG,\n        `Backing off for ${delayWithJitterMs} ms ` +\n          `(base delay: ${this.currentBaseMs} ms)`\n      );\n    }\n    setTimeout(() => {\n      def.resolve();\n    }, delayWithJitterMs);\n\n    // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n    this.currentBaseMs *= this.backoffFactor;\n    if (this.currentBaseMs < this.initialDelayMs) {\n      this.currentBaseMs = this.initialDelayMs;\n    }\n    if (this.currentBaseMs > this.maxDelayMs) {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n\n    return def.promise;\n  }\n\n  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n  private jitterDelayMs(): number {\n    return (Math.random() - 0.5) * this.currentBaseMs;\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as log from '../util/log';\nimport { Deferred } from '../util/promise';\nvar LOG_TAG = 'ExponentialBackoff';\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nvar ExponentialBackoff = /** @class */ (function () {\n    function ExponentialBackoff(\n        /**\n           * The initial delay (used as the base delay on the first retry attempt).\n           * Note that jitter will still be applied, so the actual delay could be as\n           * little as 0.5*initialDelayMs.\n           */\n        initialDelayMs, \n        /**\n           * The multiplier to use to determine the extended base delay after each\n           * attempt.\n           */\n        backoffFactor, \n        /**\n           * The maximum base delay after which no further backoff is performed.\n           * Note that jitter will still be applied, so the actual delay could be as\n           * much as 1.5*maxDelayMs.\n           */\n        maxDelayMs) {\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    ExponentialBackoff.prototype.reset = function () {\n        this.currentBaseMs = 0;\n    };\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    ExponentialBackoff.prototype.resetToMax = function () {\n        this.currentBaseMs = this.maxDelayMs;\n    };\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts.\n     */\n    ExponentialBackoff.prototype.backoffAndWait = function () {\n        var def = new Deferred();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n        if (this.currentBaseMs > 0) {\n            log.debug(LOG_TAG, \"Backing off for \" + delayWithJitterMs + \" ms \" +\n                (\"(base delay: \" + this.currentBaseMs + \" ms)\"));\n        }\n        setTimeout(function () {\n            def.resolve();\n        }, delayWithJitterMs);\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n        return def.promise;\n    };\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    ExponentialBackoff.prototype.jitterDelayMs = function () {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    };\n    return ExponentialBackoff;\n}());\nexport { ExponentialBackoff };\n\n\n"]}