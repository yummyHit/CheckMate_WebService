{"version":3,"sources":["src/firestore/remote/datastore.ts","firestore/remote/datastore.js"],"names":["Datastore","databaseInfo","queue","connection","credentials","serializer","initialBackoffDelay","prototype","newPersistentWriteStream","listener","newPersistentWatchStream","commit","mutations","_this","params","writes","map","m","toMutation","invokeRPC","then","response","fromWriteResults","writeResults","lookup","keys","documents","k","toName","docs","forEach","proto","doc","fromMaybeDocument","insert","key","result","get","push","rpcName","request","getToken","token","invoke"],"mappings":";;;;;;;AAmBA;;AAIA;;AAIA;;AAkBA;;;;;AAKA,IAAAA,YAAA,aAAA,YAAA;AACE,aAAAA,SAAA,CACUC,YADV,EAEUC,KAFV,EAGUC,UAHV,EAIUC,WAJV,EAKUC,UALV,EAMUC,mBANV,EAMsC;AAL5B,aAAAL,YAAA,GAAAA,YAAA;AACA,aAAAC,KAAA,GAAAA,KAAA;AACA,aAAAC,UAAA,GAAAA,UAAA;AACA,aAAAC,WAAA,GAAAA,WAAA;AACA,aAAAC,UAAA,GAAAA,UAAA;AACA,aAAAC,mBAAA,GAAAA,mBAAA;AACN;AAEGN,cAAAO,SAAA,CAAAC,wBAAA,GAAP,UACEC,QADF,EAC+B;AAE7B,eAAO,6CACL,KAAKR,YADA,EAEL,KAAKC,KAFA,EAGL,KAAKC,UAHA,EAIL,KAAKC,WAJA,EAKL,KAAKC,UALA,EAMLI,QANK,EAOL,KAAKH,mBAPA,CAAP;AASD,KAZM;AAcAN,cAAAO,SAAA,CAAAG,wBAAA,GAAP,UACED,QADF,EAC+B;AAE7B,eAAO,8CACL,KAAKR,YADA,EAEL,KAAKC,KAFA,EAGL,KAAKC,UAHA,EAIL,KAAKC,WAJA,EAKL,KAAKC,UALA,EAMLI,QANK,EAOL,KAAKH,mBAPA,CAAP;AASD,KAZM;AAcPN,cAAAO,SAAA,CAAAI,MAAA,GAAA,UAAOC,SAAP,EAA4B;AAA5B,YAAAC,QAAA,IAAA;AACE,YAAMC,SAAwB;AAC5BC,oBAAQH,UAAUI,GAAV,CAAc,UAAAC,CAAA,EAAC;AAAI,uBAAAJ,MAAKR,UAAL,CAAgBa,UAAhB,CAA2BD,CAA3B,CAAA;AAA6B,aAAhD;AADoB,SAA9B;AAGA,eAAO,KAAKE,SAAL,CACL,QADK,EAELL,MAFK,EAGLM,IAHK,CAGA,UAACC,QAAD,EAA6B;AAClC,mBAAOR,MAAKR,UAAL,CAAgBiB,gBAAhB,CAAiCD,SAASE,YAA1C,CAAP;AACD,SALM,CAAP;AAMD,KAVD;AAYAvB,cAAAO,SAAA,CAAAiB,MAAA,GAAA,UAAOC,IAAP,EAA0B;AAA1B,YAAAZ,QAAA,IAAA;AACE,YAAMC,SAAmC;AACvCY,uBAAWD,KAAKT,GAAL,CAAS,UAAAW,CAAA,EAAC;AAAI,uBAAAd,MAAKR,UAAL,CAAgBuB,MAAhB,CAAuBD,CAAvB,CAAA;AAAyB,aAAvC;AAD4B,SAAzC;AAGA,eAAO,KAAKR,SAAL,CACL,UADK,EAELL,MAFK,EAGLM,IAHK,CAGA,UAACC,QAAD,EAA0C;AAC/C,gBAAIQ,OAAO,oCAAX;AACAR,qBAASS,OAAT,CAAiB,UAAAC,KAAA,EAAK;AACpB,oBAAMC,MAAMnB,MAAKR,UAAL,CAAgB4B,iBAAhB,CAAkCF,KAAlC,CAAZ;AACAF,uBAAOA,KAAKK,MAAL,CAAYF,IAAIG,GAAhB,EAAqBH,GAArB,CAAP;AACD,aAHD;AAIA,gBAAMI,SAA0B,EAAhC;AACAX,iBAAKK,OAAL,CAAa,UAAAK,GAAA,EAAG;AACd,oBAAMH,MAAMH,KAAKQ,GAAL,CAASF,GAAT,CAAZ;AACA,oCAAO,CAAC,CAACH,GAAT,EAAc,0CAA0CG,GAAxD;AACAC,uBAAOE,IAAP,CAAYN,GAAZ;AACD,aAJD;AAKA,mBAAOI,MAAP;AACD,SAhBM,CAAP;AAiBD,KArBD;AAuBA;AACQpC,cAAAO,SAAA,CAAAY,SAAA,GAAR,UAAkBoB,OAAlB,EAAmCC,OAAnC,EAA+C;AAA/C,YAAA3B,QAAA,IAAA;AACE;AACA,eAAO,KAAKT,WAAL,CAAiBqC,QAAjB,EAA0B,iBAAkB,KAA5C,EAAmDrB,IAAnD,CAAwD,UAAAsB,KAAA,EAAK;AAClE,mBAAO7B,MAAKV,UAAL,CAAgBwC,MAAhB,CAAuBJ,OAAvB,EAAgCC,OAAhC,EAAyCE,KAAzC,CAAP;AACD,SAFM,CAAP;AAGD,KALO;AAMV,WAAA1C,SAAA;AAhFA,CAAA,EAAA,C,CAlDA;;;;;;;;;;;;;;;QC6ESA,S,GAAAA,S","file":"datastore.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { CredentialsProvider } from '../api/credentials';\nimport { DatabaseInfo } from '../core/database_info';\nimport { maybeDocumentMap } from '../model/collections';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation, MutationResult } from '../model/mutation';\nimport { assert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\n\nimport { Connection } from './connection';\nimport {\n  PersistentListenStream,\n  PersistentWriteStream,\n  WatchStreamListener,\n  WriteStreamListener\n} from './persistent_stream';\nimport { JsonProtoSerializer } from './serializer';\n\n// The generated proto interfaces for these class are missing the database\n// field. So we add it here.\n// TODO(b/36015800): Remove this once the api generator is fixed.\ninterface BatchGetDocumentsRequest extends api.BatchGetDocumentsRequest {\n  database?: string;\n}\ninterface CommitRequest extends api.CommitRequest {\n  database?: string;\n}\n\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\nexport class Datastore {\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    private queue: AsyncQueue,\n    private connection: Connection,\n    private credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    private initialBackoffDelay?: number\n  ) {}\n\n  public newPersistentWriteStream(\n    listener: WriteStreamListener\n  ): PersistentWriteStream {\n    return new PersistentWriteStream(\n      this.databaseInfo,\n      this.queue,\n      this.connection,\n      this.credentials,\n      this.serializer,\n      listener,\n      this.initialBackoffDelay\n    );\n  }\n\n  public newPersistentWatchStream(\n    listener: WatchStreamListener\n  ): PersistentListenStream {\n    return new PersistentListenStream(\n      this.databaseInfo,\n      this.queue,\n      this.connection,\n      this.credentials,\n      this.serializer,\n      listener,\n      this.initialBackoffDelay\n    );\n  }\n\n  commit(mutations: Mutation[]): Promise<MutationResult[]> {\n    const params: CommitRequest = {\n      writes: mutations.map(m => this.serializer.toMutation(m))\n    };\n    return this.invokeRPC(\n      'commit',\n      params\n    ).then((response: api.CommitResponse) => {\n      return this.serializer.fromWriteResults(response.writeResults);\n    });\n  }\n\n  lookup(keys: DocumentKey[]): Promise<MaybeDocument[]> {\n    const params: BatchGetDocumentsRequest = {\n      documents: keys.map(k => this.serializer.toName(k))\n    };\n    return this.invokeRPC(\n      'batchGet',\n      params\n    ).then((response: api.BatchGetDocumentsResponse[]) => {\n      let docs = maybeDocumentMap();\n      response.forEach(proto => {\n        const doc = this.serializer.fromMaybeDocument(proto);\n        docs = docs.insert(doc.key, doc);\n      });\n      const result: MaybeDocument[] = [];\n      keys.forEach(key => {\n        const doc = docs.get(key);\n        assert(!!doc, 'Missing entity in write response for ' + key);\n        result.push(doc!);\n      });\n      return result;\n    });\n  }\n\n  /** Gets an auth token and invokes the provided RPC. */\n  private invokeRPC(rpcName: string, request: any): Promise<any> {\n    // TODO(mikelehen): Retry (with backoff) on token failures?\n    return this.credentials.getToken(/*forceRefresh=*/ false).then(token => {\n      return this.connection.invoke(rpcName, request, token);\n    });\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { assert } from '../util/assert';\nimport { PersistentListenStream, PersistentWriteStream } from './persistent_stream';\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\nvar Datastore = /** @class */ (function () {\n    function Datastore(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {\n        this.databaseInfo = databaseInfo;\n        this.queue = queue;\n        this.connection = connection;\n        this.credentials = credentials;\n        this.serializer = serializer;\n        this.initialBackoffDelay = initialBackoffDelay;\n    }\n    Datastore.prototype.newPersistentWriteStream = function (listener) {\n        return new PersistentWriteStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, listener, this.initialBackoffDelay);\n    };\n    Datastore.prototype.newPersistentWatchStream = function (listener) {\n        return new PersistentListenStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, listener, this.initialBackoffDelay);\n    };\n    Datastore.prototype.commit = function (mutations) {\n        var _this = this;\n        var params = {\n            writes: mutations.map(function (m) { return _this.serializer.toMutation(m); })\n        };\n        return this.invokeRPC('commit', params).then(function (response) {\n            return _this.serializer.fromWriteResults(response.writeResults);\n        });\n    };\n    Datastore.prototype.lookup = function (keys) {\n        var _this = this;\n        var params = {\n            documents: keys.map(function (k) { return _this.serializer.toName(k); })\n        };\n        return this.invokeRPC('batchGet', params).then(function (response) {\n            var docs = maybeDocumentMap();\n            response.forEach(function (proto) {\n                var doc = _this.serializer.fromMaybeDocument(proto);\n                docs = docs.insert(doc.key, doc);\n            });\n            var result = [];\n            keys.forEach(function (key) {\n                var doc = docs.get(key);\n                assert(!!doc, 'Missing entity in write response for ' + key);\n                result.push(doc);\n            });\n            return result;\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC. */\n    Datastore.prototype.invokeRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invoke(rpcName, request, token);\n        });\n    };\n    return Datastore;\n}());\nexport { Datastore };\n\n\n"]}