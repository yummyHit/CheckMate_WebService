{"version":3,"sources":["src/firestore/remote/remote_store.ts","firestore/remote/remote_store.js"],"names":["log","objUtils","LOG_TAG","MAX_PENDING_WRITES","ONLINE_ATTEMPTS_BEFORE_FAILURE","RemoteStore","databaseInfo","asyncQueue","localStore","datastore","onlineStateHandler","pendingWrites","lastBatchSeen","listenTargets","pendingTargetResponses","accumulatedWatchChanges","watchStreamOnlineState","Unknown","watchStreamFailures","prototype","start","_this","setupStreams","then","fillWritePipeline","setOnlineStateToHealthy","updateAndBroadcastOnlineState","Healthy","setOnlineStateToUnknown","updateOnlineStateAfterFailure","Failed","onlineState","didChange","watchStream","newPersistentWatchStream","onOpen","onWatchStreamOpen","bind","onClose","onWatchStreamClose","onWatchChange","onWatchStreamChange","writeStream","newPersistentWriteStream","onWriteStreamOpen","onWriteStreamClose","onHandshakeComplete","onWriteHandshakeComplete","onMutationResult","getLastStreamToken","token","lastStreamToken","shutdown","debug","cleanupWatchStreamState","stop","resolve","undefined","listen","queryData","contains","targetId","isOpen","sendWatchRequest","isStarted","startWatchStream","unlisten","sendUnwatchRequest","recordPendingTargetRequest","watch","unwatch","shouldStartWatchStream","isEmpty","forEachNumber","error","watchChange","snapshotVersion","state","Removed","cause","handleTargetError","push","equals","MIN","compareTo","getLastRemoteSnapshotVersion","changes","handleWatchChangeBatch","aggregator","addChanges","remoteEvent","createRemoteEvent","promises","existenceFilters","filter","query","isDocumentQuery","count","key","path","deletedDoc","addDocumentUpdate","promise","remoteDocumentKeys","trackedRemote","targetChanges","mapping","applyToKeySet","documents","size","handleExistenceFilterMismatch","newQueryData","purpose","requestQueryData","ExistenceFilterMismatch","all","change","resumeToken","length","update","syncEngine","applyRemoteEvent","promiseChain","targetIds","forEach","rejectListen","canWriteMutations","nextMutationBatch","batch","commit","outstandingWrites","batchId","startWriteStream","handshakeComplete","writeMutations","mutations","writeHandshake","setLastStreamToken","_i","_a","commitVersion","results","shift","success","from","applySuccessfulWrite","errorHandling","handleWriteError","handleHandshakeError","code","ABORTED","inhibitBackoff","rejectFailedWrite","createTransaction","handleUserChange","user","uid"],"mappings":"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","file":"remote_store.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { DatabaseInfo } from '../core/database_info';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { BatchId, OnlineState, TargetId } from '../core/types';\nimport { LocalStore } from '../local/local_store';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationResult } from '../model/mutation';\nimport {\n  BATCHID_UNKNOWN,\n  MutationBatch,\n  MutationBatchResult\n} from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { Datastore } from './datastore';\nimport { ExistenceFilter } from './existence_filter';\nimport {\n  PersistentListenStream,\n  PersistentWriteStream\n} from './persistent_stream';\nimport { ResetMapping, UpdateMapping } from './remote_event';\nimport { RemoteSyncer } from './remote_syncer';\nimport { isPermanentError } from './rpc_error';\nimport {\n  WatchChange,\n  WatchChangeAggregator,\n  WatchTargetChange,\n  WatchTargetChangeState\n} from './watch_change';\n\nconst LOG_TAG = 'RemoteStore';\n\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\n\n// The RemoteStore notifies an onlineStateHandler with OnlineState.Failed if we\n// fail to connect to the backend. This subsequently triggers get() requests to\n// fail or use cached data, etc. Unfortunately, our connections have\n// historically been subject to various transient failures. So we wait for\n// multiple failures before notifying the onlineStateHandler.\nconst ONLINE_ATTEMPTS_BEFORE_FAILURE = 2;\n\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nexport class RemoteStore {\n  private pendingWrites: MutationBatch[] = [];\n  private lastBatchSeen: BatchId = BATCHID_UNKNOWN;\n\n  /**\n   * A mapping of watched targets that the client cares about tracking and the\n   * user has explicitly called a 'listen' for this target.\n   *\n   * These targets may or may not have been sent to or acknowledged by the\n   * server. On re-establishing the listen stream, these targets should be sent\n   * to the server. The targets removed with unlistens are removed eagerly\n   * without waiting for confirmation from the listen stream.\n   */\n  private listenTargets: { [targetId: number]: QueryData } = {};\n\n  /**\n   * A mapping of targetId to pending acks needed.\n   *\n   * If a targetId is present in this map, then we're waiting for watch to\n   * acknowledge a removal or addition of the target. If a target is not in this\n   * mapping, and it's in the listenTargets map, then we consider the target to\n   * be active.\n   *\n   * We increment the count here every time we issue a request over the stream\n   * to watch or unwatch. We then decrement the count every time we get a target\n   * added or target removed message from the server. Once the count is equal to\n   * 0 we know that the client and server are in the same state (once this state\n   * is reached the targetId is removed from the map to free the memory).\n   */\n  private pendingTargetResponses: { [targetId: number]: number } = {};\n\n  private accumulatedWatchChanges: WatchChange[] = [];\n\n  private watchStream: PersistentListenStream;\n  private writeStream: PersistentWriteStream;\n\n  /**\n   * The online state of the watch stream. The state is set to healthy if and\n   * only if there are messages received by the backend.\n   */\n  private watchStreamOnlineState = OnlineState.Unknown;\n\n  /** A count of consecutive failures to open the stream. */\n  private watchStreamFailures = 0;\n\n  constructor(\n    private databaseInfo: DatabaseInfo,\n    private asyncQueue: AsyncQueue,\n    /**\n     * The local store, used to fill the write pipeline with outbound\n     * mutations and resolve existence filter mismatches.\n     */\n    private localStore: LocalStore,\n    /** The client-side proxy for interacting with the backend. */\n    private datastore: Datastore,\n    private onlineStateHandler: (onlineState: OnlineState) => void\n  ) {}\n\n  /** SyncEngine to notify of watch and write events. */\n  public syncEngine: RemoteSyncer;\n\n  /**\n   * Starts up the remote store, creating streams, restoring state from\n   * LocalStore, etc.\n   */\n  start(): Promise<void> {\n    return this.setupStreams().then(() => {\n      // Resume any writes\n      return this.fillWritePipeline();\n    });\n  }\n\n  private setOnlineStateToHealthy(): void {\n    this.updateAndBroadcastOnlineState(OnlineState.Healthy);\n  }\n\n  private setOnlineStateToUnknown(): void {\n    // The state is set to unknown when a healthy stream is closed (e.g. due to\n    // a token timeout) or when we have no active listens and therefore there's\n    // no need to start the stream. Assuming there is (possibly in the future)\n    // an active listen, then we will eventually move to state Online or Failed,\n    // but we always want to make at least ONLINE_ATTEMPTS_BEFORE_FAILURE\n    // attempts before failing, so we reset the count here.\n    this.watchStreamFailures = 0;\n    this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n  }\n\n  private updateOnlineStateAfterFailure(): void {\n    // The first failure after we are successfully connected moves us to the\n    // 'Unknown' state. We then may make multiple attempts (based on\n    // ONLINE_ATTEMPTS_BEFORE_FAILURE) before we actually report failure.\n    if (this.watchStreamOnlineState === OnlineState.Healthy) {\n      this.setOnlineStateToUnknown();\n    } else {\n      this.watchStreamFailures++;\n      if (this.watchStreamFailures >= ONLINE_ATTEMPTS_BEFORE_FAILURE) {\n        this.updateAndBroadcastOnlineState(OnlineState.Failed);\n      }\n    }\n  }\n\n  private updateAndBroadcastOnlineState(onlineState: OnlineState): void {\n    const didChange = this.watchStreamOnlineState !== onlineState;\n    this.watchStreamOnlineState = onlineState;\n    if (didChange) {\n      this.onlineStateHandler(onlineState);\n    }\n  }\n\n  private setupStreams(): Promise<void> {\n    this.watchStream = this.datastore.newPersistentWatchStream({\n      onOpen: this.onWatchStreamOpen.bind(this),\n      onClose: this.onWatchStreamClose.bind(this),\n      onWatchChange: this.onWatchStreamChange.bind(this)\n    });\n    this.writeStream = this.datastore.newPersistentWriteStream({\n      onOpen: this.onWriteStreamOpen.bind(this),\n      onClose: this.onWriteStreamClose.bind(this),\n      onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n      onMutationResult: this.onMutationResult.bind(this)\n    });\n\n    // Load any saved stream token from persistent storage\n    return this.localStore.getLastStreamToken().then(token => {\n      this.writeStream.lastStreamToken = token;\n    });\n  }\n\n  shutdown(): Promise<void> {\n    log.debug(LOG_TAG, 'RemoteStore shutting down.');\n    this.cleanupWatchStreamState();\n    this.writeStream.stop();\n    this.watchStream.stop();\n\n    return Promise.resolve(undefined);\n  }\n\n  /** Starts new listen for the given query. Uses resume token if provided */\n  listen(queryData: QueryData): void {\n    assert(\n      !objUtils.contains(this.listenTargets, queryData.targetId),\n      'listen called with duplicate targetId!'\n    );\n    // Mark this as something the client is currently listening for.\n    this.listenTargets[queryData.targetId] = queryData;\n    if (this.watchStream.isOpen()) {\n      this.sendWatchRequest(queryData);\n    } else if (!this.watchStream.isStarted()) {\n      // The listen will be sent in onWatchStreamOpen\n      this.startWatchStream();\n    }\n  }\n\n  /** Removes the listen from server */\n  unlisten(targetId: TargetId): void {\n    assert(\n      objUtils.contains(this.listenTargets, targetId),\n      'unlisten called without assigned target ID!'\n    );\n    const queryData = this.listenTargets[targetId];\n    delete this.listenTargets[targetId];\n    if (this.watchStream.isOpen()) {\n      this.sendUnwatchRequest(targetId);\n    }\n  }\n\n  /**\n   * We need to increment the the expected number of pending responses we're due\n   * from watch so we wait for the ack to process any messages from this target.\n   */\n  private sendWatchRequest(queryData: QueryData): void {\n    this.recordPendingTargetRequest(queryData.targetId);\n    this.watchStream.watch(queryData);\n  }\n\n  /**\n   * We need to increment the expected number of pending responses we're due\n   * from watch so we wait for the removal on the server before we process any\n   * messages from this target.\n   */\n  private sendUnwatchRequest(targetId: TargetId): void {\n    this.recordPendingTargetRequest(targetId);\n    this.watchStream.unwatch(targetId);\n  }\n\n  /**\n   * Increment the mapping of how many acks are needed from watch before we can\n   * consider the server to be 'in-sync' with the client's active targets.\n   */\n  private recordPendingTargetRequest(targetId: TargetId): void {\n    // For each request we get we need to record we need a response for it.\n    this.pendingTargetResponses[targetId] =\n      (this.pendingTargetResponses[targetId] || 0) + 1;\n  }\n\n  private startWatchStream(): void {\n    assert(!this.watchStream.isStarted(), \"Can't restart started watch stream\");\n    assert(\n      this.shouldStartWatchStream(),\n      'Tried to start watch stream even though it should not be started'\n    );\n    this.watchStream.start();\n  }\n\n  /**\n   * Returns whether the watch stream should be started because there are\n   * active targets trying to be listened too\n   */\n  private shouldStartWatchStream(): boolean {\n    return !objUtils.isEmpty(this.listenTargets);\n  }\n\n  private cleanupWatchStreamState(): void {\n    // If the connection is closed then we'll never get a snapshot version for\n    // the accumulated changes and so we'll never be able to complete the batch.\n    // When we start up again the server is going to resend these changes\n    // anyway, so just toss the accumulated state.\n    this.accumulatedWatchChanges = [];\n    this.pendingTargetResponses = {};\n  }\n\n  private onWatchStreamOpen(): Promise<void> {\n    // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n    // targets are active\n    objUtils.forEachNumber(this.listenTargets, (targetId, queryData) => {\n      this.sendWatchRequest(queryData);\n    });\n    return Promise.resolve();\n  }\n\n  private onWatchStreamClose(error: FirestoreError | null): Promise<void> {\n    this.cleanupWatchStreamState();\n\n    // If there was an error, retry the connection.\n    if (this.shouldStartWatchStream()) {\n      this.updateOnlineStateAfterFailure();\n      this.startWatchStream();\n    } else {\n      // No need to restart watch stream because there are no active targets.\n      // The online state is set to unknown because there is no active attempt\n      // at establishing a connection\n      this.setOnlineStateToUnknown();\n    }\n    return Promise.resolve();\n  }\n\n  private onWatchStreamChange(\n    watchChange: WatchChange,\n    snapshotVersion: SnapshotVersion\n  ): Promise<void> {\n    // Mark the connection as healthy because we got a message from the server\n    this.setOnlineStateToHealthy();\n\n    if (\n      watchChange instanceof WatchTargetChange &&\n      watchChange.state === WatchTargetChangeState.Removed &&\n      watchChange.cause\n    ) {\n      // There was an error on a target, don't wait for a consistent snapshot\n      // to raise events\n      return this.handleTargetError(watchChange);\n    }\n    // Accumulate watch changes but don't process them if there's no\n    // snapshotVersion or it's older than a previous snapshot we've processed\n    // (can happen after we resume a target using a resume token).\n    this.accumulatedWatchChanges.push(watchChange);\n    if (\n      !snapshotVersion.equals(SnapshotVersion.MIN) &&\n      snapshotVersion.compareTo(\n        this.localStore.getLastRemoteSnapshotVersion()\n      ) >= 0\n    ) {\n      const changes = this.accumulatedWatchChanges;\n      this.accumulatedWatchChanges = [];\n      return this.handleWatchChangeBatch(snapshotVersion, changes);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * Takes a batch of changes from the Datastore, repackages them as a\n   * RemoteEvent, and passes that on to the listener, which is typically the\n   * SyncEngine.\n   */\n  private handleWatchChangeBatch(\n    snapshotVersion: SnapshotVersion,\n    changes: WatchChange[]\n  ): Promise<void> {\n    const aggregator = new WatchChangeAggregator(\n      snapshotVersion,\n      this.listenTargets,\n      this.pendingTargetResponses\n    );\n    aggregator.addChanges(changes);\n    const remoteEvent = aggregator.createRemoteEvent();\n    // Get the new response counts from the aggregator\n    this.pendingTargetResponses = aggregator.pendingTargetResponses;\n\n    const promises: Array<Promise<void>> = [];\n    // Handle existence filters and existence filter mismatches.\n    objUtils.forEachNumber(\n      aggregator.existenceFilters,\n      (targetId: TargetId, filter: ExistenceFilter) => {\n        const queryData = this.listenTargets[targetId];\n        if (!queryData) {\n          // A watched target might have been removed already.\n          return;\n        }\n        const query = queryData.query;\n        if (query.isDocumentQuery()) {\n          if (filter.count === 0) {\n            // The existence filter told us the document does not exist.\n            // We need to deduce that this document does not exist and apply\n            // a deleted document to our updates. Without applying a deleted\n            // document there might be another query that will raise this\n            // document as part of a snapshot until it is resolved,\n            // essentially exposing inconsistency between queries.\n            const key = new DocumentKey(query.path);\n            const deletedDoc = new NoDocument(key, snapshotVersion);\n            remoteEvent.addDocumentUpdate(deletedDoc);\n          } else {\n            assert(\n              filter.count === 1,\n              'Single document existence filter with count: ' + filter.count\n            );\n          }\n        } else {\n          // Not a document query.\n          const promise = this.localStore\n            .remoteDocumentKeys(targetId)\n            .then(trackedRemote => {\n              if (remoteEvent.targetChanges[targetId]) {\n                const mapping = remoteEvent.targetChanges[targetId].mapping;\n                if (mapping !== null) {\n                  if (mapping instanceof UpdateMapping) {\n                    trackedRemote = mapping.applyToKeySet(trackedRemote);\n                  } else {\n                    assert(\n                      mapping instanceof ResetMapping,\n                      'Expected either reset or update mapping but got something else: ' +\n                        mapping\n                    );\n                    trackedRemote = mapping.documents;\n                  }\n                }\n              }\n\n              if (trackedRemote.size !== filter.count) {\n                // Existence filter mismatch, resetting mapping.\n\n                // Make sure the mismatch is exposed in the remote event.\n                remoteEvent.handleExistenceFilterMismatch(targetId);\n\n                // Clear the resume token for the query, since we're in a\n                // known mismatch state.\n                const newQueryData = new QueryData(\n                  query,\n                  targetId,\n                  queryData.purpose\n                );\n                this.listenTargets[targetId] = newQueryData;\n\n                // Cause a hard reset by unwatching and rewatching\n                // immediately, but deliberately don't send a resume token\n                // so that we get a full update.\n                // Make sure we expect that this acks are going to happen.\n                this.sendUnwatchRequest(targetId);\n\n                // Mark the query we send as being on behalf of an existence\n                // filter mismatch, but don't actually retain that in\n                // listenTargets. This ensures that we flag the first\n                // re-listen this way without impacting future listens of\n                // this target (that might happen e.g. on reconnect).\n                const requestQueryData = new QueryData(\n                  query,\n                  targetId,\n                  QueryPurpose.ExistenceFilterMismatch\n                );\n                this.sendWatchRequest(requestQueryData);\n              }\n            });\n          promises.push(promise);\n        }\n      }\n    );\n\n    return Promise.all(promises).then(() => {\n      // Update in-memory resume tokens. LocalStore will update the\n      // persistent view of these when applying the completed RemoteEvent.\n      objUtils.forEachNumber(remoteEvent.targetChanges, (targetId, change) => {\n        if (change.resumeToken.length > 0) {\n          const queryData = this.listenTargets[targetId];\n          // A watched target might have been removed already.\n          if (queryData) {\n            this.listenTargets[targetId] = queryData.update({\n              resumeToken: change.resumeToken,\n              snapshotVersion: change.snapshotVersion\n            });\n          }\n        }\n      });\n\n      // Finally handle remote event\n      return this.syncEngine.applyRemoteEvent(remoteEvent);\n    });\n  }\n\n  /** Handles an error on a target */\n  private handleTargetError(watchChange: WatchTargetChange): Promise<void> {\n    assert(!!watchChange.cause, 'Handling target error without a cause');\n    const error = watchChange.cause!;\n    let promiseChain = Promise.resolve();\n    watchChange.targetIds.forEach(targetId => {\n      promiseChain = promiseChain.then(() => {\n        if (objUtils.contains(this.listenTargets, targetId)) {\n          delete this.listenTargets[targetId];\n          return this.syncEngine.rejectListen(targetId, error);\n        } else {\n          // A watched target might have been removed already.\n          return Promise.resolve();\n        }\n      });\n    });\n    return promiseChain;\n  }\n\n  /**\n   * Notifies that there are new mutations to process in the queue. This is\n   * typically called by SyncEngine after it has sent mutations to LocalStore.\n   *\n   */\n  fillWritePipeline(): Promise<void> {\n    if (!this.canWriteMutations()) {\n      return Promise.resolve();\n    } else {\n      return this.localStore\n        .nextMutationBatch(this.lastBatchSeen)\n        .then(batch => {\n          if (batch === null) {\n            return Promise.resolve();\n          } else {\n            this.commit(batch);\n            return this.fillWritePipeline();\n          }\n        });\n    }\n  }\n\n  /**\n   * Returns true if the backend can accept additional write requests.\n   *\n   * When sending mutations to the write stream (e.g. in fillWritePipeline),\n   * call this method first to check if more mutations can be sent.\n   *\n   * Currently the only thing that can prevent the backend from accepting\n   * write requests is if there are too many requests already outstanding. As\n   * writes complete the backend will be able to accept more.\n   */\n  canWriteMutations(): boolean {\n    return this.pendingWrites.length < MAX_PENDING_WRITES;\n  }\n\n  // For testing\n  outstandingWrites(): number {\n    return this.pendingWrites.length;\n  }\n\n  /**\n   * Given mutations to commit, actually commits them to the Datastore. Note\n   * that this does *not* return a Promise specifically because the AsyncQueue\n   * should not block operations for this.\n   */\n  private commit(batch: MutationBatch): void {\n    assert(\n      this.canWriteMutations(),\n      \"commit called when batches can't be written\"\n    );\n    this.lastBatchSeen = batch.batchId;\n\n    this.pendingWrites.push(batch);\n\n    if (!this.writeStream.isStarted()) {\n      this.startWriteStream();\n    } else if (this.writeStream.handshakeComplete) {\n      this.writeStream.writeMutations(batch.mutations);\n    }\n  }\n\n  private startWriteStream(): void {\n    assert(!this.writeStream.isStarted(), \"Can't restart started write stream\");\n    this.writeStream.start();\n  }\n\n  private onWriteStreamOpen(): Promise<void> {\n    this.writeStream.writeHandshake();\n\n    return Promise.resolve();\n  }\n\n  private onWriteHandshakeComplete(): Promise<void> {\n    // Record the stream token.\n    return this.localStore\n      .setLastStreamToken(this.writeStream.lastStreamToken)\n      .then(() => {\n        // Drain any pending writes.\n        //\n        // Note that at this point pendingWrites contains mutations that\n        // have already been accepted by fillWritePipeline/commitBatch. If\n        // the pipeline is full, canWriteMutations will be false, despite\n        // the fact that we actually need to send mutations over.\n        //\n        // This also means that this method indirectly respects the limits\n        // imposed by canWriteMutations since writes can't be added to the\n        // pendingWrites array when canWriteMutations is false. If the\n        // limits imposed by canWriteMutations actually protect us from\n        // DOSing ourselves then those limits won't be exceeded here and\n        // we'll continue to make progress.\n        for (const batch of this.pendingWrites) {\n          this.writeStream.writeMutations(batch.mutations);\n        }\n      });\n  }\n\n  private onMutationResult(\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ): Promise<void> {\n    // This is a response to a write containing mutations and should be\n    // correlated to the first pending write.\n    assert(\n      this.pendingWrites.length > 0,\n      'Got result for empty pending writes'\n    );\n    const batch = this.pendingWrites.shift()!;\n    const success = MutationBatchResult.from(\n      batch,\n      commitVersion,\n      results,\n      this.writeStream.lastStreamToken\n    );\n    return this.syncEngine.applySuccessfulWrite(success).then(() => {\n      // It's possible that with the completion of this mutation another\n      // slot has freed up.\n      return this.fillWritePipeline();\n    });\n  }\n\n  private onWriteStreamClose(error?: FirestoreError): Promise<void> {\n    // Ignore close if there are no pending writes.\n    if (this.pendingWrites.length > 0) {\n      assert(\n        !!error,\n        'We have pending writes, but the write stream closed without an error'\n      );\n      // A promise that is resolved after we processed the error\n      let errorHandling: Promise<void>;\n      if (this.writeStream.handshakeComplete) {\n        // This error affects the actual write.\n        errorHandling = this.handleWriteError(error!);\n      } else {\n        // If there was an error before the handshake has finished, it's\n        // possible that the server is unable to process the stream token\n        // we're sending. (Perhaps it's too old?)\n        errorHandling = this.handleHandshakeError(error!);\n      }\n\n      return errorHandling.then(() => {\n        // The write stream might have been started by refilling the write\n        // pipeline for failed writes\n        if (this.pendingWrites.length > 0 && !this.writeStream.isStarted()) {\n          this.startWriteStream();\n        }\n      });\n    } else {\n      // No pending writes, nothing to do\n      return Promise.resolve();\n    }\n  }\n\n  private handleHandshakeError(error: FirestoreError): Promise<void> {\n    // Reset the token if it's a permanent error or the error code is\n    // ABORTED, signaling the write stream is no longer valid.\n    if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n      log.debug(\n        LOG_TAG,\n        'RemoteStore error before completed handshake; resetting stream token: ',\n        this.writeStream.lastStreamToken\n      );\n      this.writeStream.lastStreamToken = emptyByteString();\n\n      return this.localStore.setLastStreamToken(emptyByteString());\n    } else {\n      // Some other error, don't reset stream token. Our stream logic will\n      // just retry with exponential backoff.\n      return Promise.resolve();\n    }\n  }\n\n  private handleWriteError(error: FirestoreError): Promise<void> {\n    if (isPermanentError(error.code)) {\n      // This was a permanent error, the request itself was the problem\n      // so it's not going to succeed if we resend it.\n      const batch = this.pendingWrites.shift()!;\n\n      // In this case it's also unlikely that the server itself is melting\n      // down -- this was just a bad request so inhibit backoff on the next\n      // restart.\n      this.writeStream.inhibitBackoff();\n\n      return this.syncEngine\n        .rejectFailedWrite(batch.batchId, error)\n        .then(() => {\n          // It's possible that with the completion of this mutation\n          // another slot has freed up.\n          return this.fillWritePipeline();\n        });\n    } else {\n      // Transient error, just let the retry logic kick in.\n      return Promise.resolve();\n    }\n  }\n\n  createTransaction(): Transaction {\n    return new Transaction(this.datastore);\n  }\n\n  handleUserChange(user: User): Promise<void> {\n    log.debug(LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n\n    // Clear pending writes because those are per-user. Watched targets\n    // persist across users so don't clear those.\n    this.lastBatchSeen = BATCHID_UNKNOWN;\n    this.pendingWrites = [];\n\n    // Stop the streams. They promise not to call us back.\n    this.watchStream.stop();\n    this.writeStream.stop();\n\n    this.cleanupWatchStreamState();\n\n    // Create new streams (but note they're not started yet).\n    return this.setupStreams()\n      .then(() => {\n        // If there are any watchedTargets, properly handle the stream\n        // restart now that RemoteStore is ready to handle them.\n        if (this.shouldStartWatchStream()) {\n          this.startWatchStream();\n        }\n\n        // Resume any writes\n        return this.fillWritePipeline();\n      })\n      .then(() => {\n        // User change moves us back to the unknown state because we might\n        // not want to re-open the stream\n        this.setOnlineStateToUnknown();\n      });\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { OnlineState } from '../core/types';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { BATCHID_UNKNOWN, MutationBatchResult } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { Code } from '../util/error';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\nimport { PromiseImpl as Promise } from '../../utils/promise';\nimport { ResetMapping, UpdateMapping } from './remote_event';\nimport { isPermanentError } from './rpc_error';\nimport { WatchChangeAggregator, WatchTargetChange, WatchTargetChangeState } from './watch_change';\nvar LOG_TAG = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nvar MAX_PENDING_WRITES = 10;\n// The RemoteStore notifies an onlineStateHandler with OnlineState.Failed if we\n// fail to connect to the backend. This subsequently triggers get() requests to\n// fail or use cached data, etc. Unfortunately, our connections have\n// historically been subject to various transient failures. So we wait for\n// multiple failures before notifying the onlineStateHandler.\nvar ONLINE_ATTEMPTS_BEFORE_FAILURE = 2;\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nvar RemoteStore = /** @class */ (function () {\n    function RemoteStore(databaseInfo, asyncQueue, \n        /**\n         * The local store, used to fill the write pipeline with outbound\n         * mutations and resolve existence filter mismatches.\n         */\n        localStore, \n        /** The client-side proxy for interacting with the backend. */\n        datastore, onlineStateHandler) {\n        this.databaseInfo = databaseInfo;\n        this.asyncQueue = asyncQueue;\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.onlineStateHandler = onlineStateHandler;\n        this.pendingWrites = [];\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = {};\n        /**\n         * A mapping of targetId to pending acks needed.\n         *\n         * If a targetId is present in this map, then we're waiting for watch to\n         * acknowledge a removal or addition of the target. If a target is not in this\n         * mapping, and it's in the listenTargets map, then we consider the target to\n         * be active.\n         *\n         * We increment the count here every time we issue a request over the stream\n         * to watch or unwatch. We then decrement the count every time we get a target\n         * added or target removed message from the server. Once the count is equal to\n         * 0 we know that the client and server are in the same state (once this state\n         * is reached the targetId is removed from the map to free the memory).\n         */\n        this.pendingTargetResponses = {};\n        this.accumulatedWatchChanges = [];\n        /**\n         * The online state of the watch stream. The state is set to healthy if and\n         * only if there are messages received by the backend.\n         */\n        this.watchStreamOnlineState = OnlineState.Unknown;\n        /** A count of consecutive failures to open the stream. */\n        this.watchStreamFailures = 0;\n    }\n    /**\n     * Starts up the remote store, creating streams, restoring state from\n     * LocalStore, etc.\n     */\n    RemoteStore.prototype.start = function () {\n        var _this = this;\n        return this.setupStreams().then(function () {\n            // Resume any writes\n            return _this.fillWritePipeline();\n        });\n    };\n    RemoteStore.prototype.setOnlineStateToHealthy = function () {\n        this.updateAndBroadcastOnlineState(OnlineState.Healthy);\n    };\n    RemoteStore.prototype.setOnlineStateToUnknown = function () {\n        // The state is set to unknown when a healthy stream is closed (e.g. due to\n        // a token timeout) or when we have no active listens and therefore there's\n        // no need to start the stream. Assuming there is (possibly in the future)\n        // an active listen, then we will eventually move to state Online or Failed,\n        // but we always want to make at least ONLINE_ATTEMPTS_BEFORE_FAILURE\n        // attempts before failing, so we reset the count here.\n        this.watchStreamFailures = 0;\n        this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n    };\n    RemoteStore.prototype.updateOnlineStateAfterFailure = function () {\n        // The first failure after we are successfully connected moves us to the\n        // 'Unknown' state. We then may make multiple attempts (based on\n        // ONLINE_ATTEMPTS_BEFORE_FAILURE) before we actually report failure.\n        if (this.watchStreamOnlineState === OnlineState.Healthy) {\n            this.setOnlineStateToUnknown();\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= ONLINE_ATTEMPTS_BEFORE_FAILURE) {\n                this.updateAndBroadcastOnlineState(OnlineState.Failed);\n            }\n        }\n    };\n    RemoteStore.prototype.updateAndBroadcastOnlineState = function (onlineState) {\n        var didChange = this.watchStreamOnlineState !== onlineState;\n        this.watchStreamOnlineState = onlineState;\n        if (didChange) {\n            this.onlineStateHandler(onlineState);\n        }\n    };\n    RemoteStore.prototype.setupStreams = function () {\n        var _this = this;\n        this.watchStream = this.datastore.newPersistentWatchStream({\n            onOpen: this.onWatchStreamOpen.bind(this),\n            onClose: this.onWatchStreamClose.bind(this),\n            onWatchChange: this.onWatchStreamChange.bind(this)\n        });\n        this.writeStream = this.datastore.newPersistentWriteStream({\n            onOpen: this.onWriteStreamOpen.bind(this),\n            onClose: this.onWriteStreamClose.bind(this),\n            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n            onMutationResult: this.onMutationResult.bind(this)\n        });\n        // Load any saved stream token from persistent storage\n        return this.localStore.getLastStreamToken().then(function (token) {\n            _this.writeStream.lastStreamToken = token;\n        });\n    };\n    RemoteStore.prototype.shutdown = function () {\n        log.debug(LOG_TAG, 'RemoteStore shutting down.');\n        this.cleanupWatchStreamState();\n        this.writeStream.stop();\n        this.watchStream.stop();\n        return Promise.resolve(undefined);\n    };\n    /** Starts new listen for the given query. Uses resume token if provided */\n    RemoteStore.prototype.listen = function (queryData) {\n        assert(!objUtils.contains(this.listenTargets, queryData.targetId), 'listen called with duplicate targetId!');\n        // Mark this as something the client is currently listening for.\n        this.listenTargets[queryData.targetId] = queryData;\n        if (this.watchStream.isOpen()) {\n            this.sendWatchRequest(queryData);\n        }\n        else if (!this.watchStream.isStarted()) {\n            // The listen will be sent in onWatchStreamOpen\n            this.startWatchStream();\n        }\n    };\n    /** Removes the listen from server */\n    RemoteStore.prototype.unlisten = function (targetId) {\n        assert(objUtils.contains(this.listenTargets, targetId), 'unlisten called without assigned target ID!');\n        var queryData = this.listenTargets[targetId];\n        delete this.listenTargets[targetId];\n        if (this.watchStream.isOpen()) {\n            this.sendUnwatchRequest(targetId);\n        }\n    };\n    /**\n     * We need to increment the the expected number of pending responses we're due\n     * from watch so we wait for the ack to process any messages from this target.\n     */\n    RemoteStore.prototype.sendWatchRequest = function (queryData) {\n        this.recordPendingTargetRequest(queryData.targetId);\n        this.watchStream.watch(queryData);\n    };\n    /**\n     * We need to increment the expected number of pending responses we're due\n     * from watch so we wait for the removal on the server before we process any\n     * messages from this target.\n     */\n    RemoteStore.prototype.sendUnwatchRequest = function (targetId) {\n        this.recordPendingTargetRequest(targetId);\n        this.watchStream.unwatch(targetId);\n    };\n    /**\n     * Increment the mapping of how many acks are needed from watch before we can\n     * consider the server to be 'in-sync' with the client's active targets.\n     */\n    RemoteStore.prototype.recordPendingTargetRequest = function (targetId) {\n        // For each request we get we need to record we need a response for it.\n        this.pendingTargetResponses[targetId] =\n            (this.pendingTargetResponses[targetId] || 0) + 1;\n    };\n    RemoteStore.prototype.startWatchStream = function () {\n        assert(!this.watchStream.isStarted(), \"Can't restart started watch stream\");\n        assert(this.shouldStartWatchStream(), 'Tried to start watch stream even though it should not be started');\n        this.watchStream.start();\n    };\n    /**\n     * Returns whether the watch stream should be started because there are\n     * active targets trying to be listened too\n     */\n    RemoteStore.prototype.shouldStartWatchStream = function () {\n        return !objUtils.isEmpty(this.listenTargets);\n    };\n    RemoteStore.prototype.cleanupWatchStreamState = function () {\n        // If the connection is closed then we'll never get a snapshot version for\n        // the accumulated changes and so we'll never be able to complete the batch.\n        // When we start up again the server is going to resend these changes\n        // anyway, so just toss the accumulated state.\n        this.accumulatedWatchChanges = [];\n        this.pendingTargetResponses = {};\n    };\n    RemoteStore.prototype.onWatchStreamOpen = function () {\n        var _this = this;\n        // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n        // targets are active\n        objUtils.forEachNumber(this.listenTargets, function (targetId, queryData) {\n            _this.sendWatchRequest(queryData);\n        });\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWatchStreamClose = function (error) {\n        this.cleanupWatchStreamState();\n        // If there was an error, retry the connection.\n        if (this.shouldStartWatchStream()) {\n            this.updateOnlineStateAfterFailure();\n            this.startWatchStream();\n        }\n        else {\n            // No need to restart watch stream because there are no active targets.\n            // The online state is set to unknown because there is no active attempt\n            // at establishing a connection\n            this.setOnlineStateToUnknown();\n        }\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWatchStreamChange = function (watchChange, snapshotVersion) {\n        // Mark the connection as healthy because we got a message from the server\n        this.setOnlineStateToHealthy();\n        if (watchChange instanceof WatchTargetChange &&\n            watchChange.state === WatchTargetChangeState.Removed &&\n            watchChange.cause) {\n            // There was an error on a target, don't wait for a consistent snapshot\n            // to raise events\n            return this.handleTargetError(watchChange);\n        }\n        // Accumulate watch changes but don't process them if there's no\n        // snapshotVersion or it's older than a previous snapshot we've processed\n        // (can happen after we resume a target using a resume token).\n        this.accumulatedWatchChanges.push(watchChange);\n        if (!snapshotVersion.equals(SnapshotVersion.MIN) &&\n            snapshotVersion.compareTo(this.localStore.getLastRemoteSnapshotVersion()) >= 0) {\n            var changes = this.accumulatedWatchChanges;\n            this.accumulatedWatchChanges = [];\n            return this.handleWatchChangeBatch(snapshotVersion, changes);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    /**\n     * Takes a batch of changes from the Datastore, repackages them as a\n     * RemoteEvent, and passes that on to the listener, which is typically the\n     * SyncEngine.\n     */\n    RemoteStore.prototype.handleWatchChangeBatch = function (snapshotVersion, changes) {\n        var _this = this;\n        var aggregator = new WatchChangeAggregator(snapshotVersion, this.listenTargets, this.pendingTargetResponses);\n        aggregator.addChanges(changes);\n        var remoteEvent = aggregator.createRemoteEvent();\n        // Get the new response counts from the aggregator\n        this.pendingTargetResponses = aggregator.pendingTargetResponses;\n        var promises = [];\n        // Handle existence filters and existence filter mismatches.\n        objUtils.forEachNumber(aggregator.existenceFilters, function (targetId, filter) {\n            var queryData = _this.listenTargets[targetId];\n            if (!queryData) {\n                // A watched target might have been removed already.\n                return;\n            }\n            var query = queryData.query;\n            if (query.isDocumentQuery()) {\n                if (filter.count === 0) {\n                    // The existence filter told us the document does not exist.\n                    // We need to deduce that this document does not exist and apply\n                    // a deleted document to our updates. Without applying a deleted\n                    // document there might be another query that will raise this\n                    // document as part of a snapshot until it is resolved,\n                    // essentially exposing inconsistency between queries.\n                    var key = new DocumentKey(query.path);\n                    var deletedDoc = new NoDocument(key, snapshotVersion);\n                    remoteEvent.addDocumentUpdate(deletedDoc);\n                }\n                else {\n                    assert(filter.count === 1, 'Single document existence filter with count: ' + filter.count);\n                }\n            }\n            else {\n                // Not a document query.\n                var promise = _this.localStore\n                    .remoteDocumentKeys(targetId)\n                    .then(function (trackedRemote) {\n                    if (remoteEvent.targetChanges[targetId]) {\n                        var mapping = remoteEvent.targetChanges[targetId].mapping;\n                        if (mapping !== null) {\n                            if (mapping instanceof UpdateMapping) {\n                                trackedRemote = mapping.applyToKeySet(trackedRemote);\n                            }\n                            else {\n                                assert(mapping instanceof ResetMapping, 'Expected either reset or update mapping but got something else: ' +\n                                    mapping);\n                                trackedRemote = mapping.documents;\n                            }\n                        }\n                    }\n                    if (trackedRemote.size !== filter.count) {\n                        // Existence filter mismatch, resetting mapping.\n                        // Make sure the mismatch is exposed in the remote event.\n                        remoteEvent.handleExistenceFilterMismatch(targetId);\n                        // Clear the resume token for the query, since we're in a\n                        // known mismatch state.\n                        var newQueryData = new QueryData(query, targetId, queryData.purpose);\n                        _this.listenTargets[targetId] = newQueryData;\n                        // Cause a hard reset by unwatching and rewatching\n                        // immediately, but deliberately don't send a resume token\n                        // so that we get a full update.\n                        // Make sure we expect that this acks are going to happen.\n                        _this.sendUnwatchRequest(targetId);\n                        // Mark the query we send as being on behalf of an existence\n                        // filter mismatch, but don't actually retain that in\n                        // listenTargets. This ensures that we flag the first\n                        // re-listen this way without impacting future listens of\n                        // this target (that might happen e.g. on reconnect).\n                        var requestQueryData = new QueryData(query, targetId, QueryPurpose.ExistenceFilterMismatch);\n                        _this.sendWatchRequest(requestQueryData);\n                    }\n                });\n                promises.push(promise);\n            }\n        });\n        return Promise.all(promises).then(function () {\n            // Update in-memory resume tokens. LocalStore will update the\n            // persistent view of these when applying the completed RemoteEvent.\n            objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                if (change.resumeToken.length > 0) {\n                    var queryData = _this.listenTargets[targetId];\n                    // A watched target might have been removed already.\n                    if (queryData) {\n                        _this.listenTargets[targetId] = queryData.update({\n                            resumeToken: change.resumeToken,\n                            snapshotVersion: change.snapshotVersion\n                        });\n                    }\n                }\n            });\n            // Finally handle remote event\n            return _this.syncEngine.applyRemoteEvent(remoteEvent);\n        });\n    };\n    /** Handles an error on a target */\n    RemoteStore.prototype.handleTargetError = function (watchChange) {\n        var _this = this;\n        assert(!!watchChange.cause, 'Handling target error without a cause');\n        var error = watchChange.cause;\n        var promiseChain = Promise.resolve();\n        watchChange.targetIds.forEach(function (targetId) {\n            promiseChain = promiseChain.then(function () {\n                if (objUtils.contains(_this.listenTargets, targetId)) {\n                    delete _this.listenTargets[targetId];\n                    return _this.syncEngine.rejectListen(targetId, error);\n                }\n                else {\n                    // A watched target might have been removed already.\n                    return Promise.resolve();\n                }\n            });\n        });\n        return promiseChain;\n    };\n    /**\n     * Notifies that there are new mutations to process in the queue. This is\n     * typically called by SyncEngine after it has sent mutations to LocalStore.\n     *\n     */\n    RemoteStore.prototype.fillWritePipeline = function () {\n        var _this = this;\n        if (!this.canWriteMutations()) {\n            return Promise.resolve();\n        }\n        else {\n            return this.localStore\n                .nextMutationBatch(this.lastBatchSeen)\n                .then(function (batch) {\n                if (batch === null) {\n                    return Promise.resolve();\n                }\n                else {\n                    _this.commit(batch);\n                    return _this.fillWritePipeline();\n                }\n            });\n        }\n    };\n    /**\n     * Returns true if the backend can accept additional write requests.\n     *\n     * When sending mutations to the write stream (e.g. in fillWritePipeline),\n     * call this method first to check if more mutations can be sent.\n     *\n     * Currently the only thing that can prevent the backend from accepting\n     * write requests is if there are too many requests already outstanding. As\n     * writes complete the backend will be able to accept more.\n     */\n    RemoteStore.prototype.canWriteMutations = function () {\n        return this.pendingWrites.length < MAX_PENDING_WRITES;\n    };\n    // For testing\n    RemoteStore.prototype.outstandingWrites = function () {\n        return this.pendingWrites.length;\n    };\n    /**\n     * Given mutations to commit, actually commits them to the Datastore. Note\n     * that this does *not* return a Promise specifically because the AsyncQueue\n     * should not block operations for this.\n     */\n    RemoteStore.prototype.commit = function (batch) {\n        assert(this.canWriteMutations(), \"commit called when batches can't be written\");\n        this.lastBatchSeen = batch.batchId;\n        this.pendingWrites.push(batch);\n        if (!this.writeStream.isStarted()) {\n            this.startWriteStream();\n        }\n        else if (this.writeStream.handshakeComplete) {\n            this.writeStream.writeMutations(batch.mutations);\n        }\n    };\n    RemoteStore.prototype.startWriteStream = function () {\n        assert(!this.writeStream.isStarted(), \"Can't restart started write stream\");\n        this.writeStream.start();\n    };\n    RemoteStore.prototype.onWriteStreamOpen = function () {\n        this.writeStream.writeHandshake();\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWriteHandshakeComplete = function () {\n        var _this = this;\n        // Record the stream token.\n        return this.localStore\n            .setLastStreamToken(this.writeStream.lastStreamToken)\n            .then(function () {\n            // Drain any pending writes.\n            //\n            // Note that at this point pendingWrites contains mutations that\n            // have already been accepted by fillWritePipeline/commitBatch. If\n            // the pipeline is full, canWriteMutations will be false, despite\n            // the fact that we actually need to send mutations over.\n            //\n            // This also means that this method indirectly respects the limits\n            // imposed by canWriteMutations since writes can't be added to the\n            // pendingWrites array when canWriteMutations is false. If the\n            // limits imposed by canWriteMutations actually protect us from\n            // DOSing ourselves then those limits won't be exceeded here and\n            // we'll continue to make progress.\n            for (var _i = 0, _a = _this.pendingWrites; _i < _a.length; _i++) {\n                var batch = _a[_i];\n                _this.writeStream.writeMutations(batch.mutations);\n            }\n        });\n    };\n    RemoteStore.prototype.onMutationResult = function (commitVersion, results) {\n        var _this = this;\n        // This is a response to a write containing mutations and should be\n        // correlated to the first pending write.\n        assert(this.pendingWrites.length > 0, 'Got result for empty pending writes');\n        var batch = this.pendingWrites.shift();\n        var success = MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);\n        return this.syncEngine.applySuccessfulWrite(success).then(function () {\n            // It's possible that with the completion of this mutation another\n            // slot has freed up.\n            return _this.fillWritePipeline();\n        });\n    };\n    RemoteStore.prototype.onWriteStreamClose = function (error) {\n        var _this = this;\n        // Ignore close if there are no pending writes.\n        if (this.pendingWrites.length > 0) {\n            assert(!!error, 'We have pending writes, but the write stream closed without an error');\n            // A promise that is resolved after we processed the error\n            var errorHandling = void 0;\n            if (this.writeStream.handshakeComplete) {\n                // This error affects the actual write.\n                errorHandling = this.handleWriteError(error);\n            }\n            else {\n                // If there was an error before the handshake has finished, it's\n                // possible that the server is unable to process the stream token\n                // we're sending. (Perhaps it's too old?)\n                errorHandling = this.handleHandshakeError(error);\n            }\n            return errorHandling.then(function () {\n                // The write stream might have been started by refilling the write\n                // pipeline for failed writes\n                if (_this.pendingWrites.length > 0 && !_this.writeStream.isStarted()) {\n                    _this.startWriteStream();\n                }\n            });\n        }\n        else {\n            // No pending writes, nothing to do\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.handleHandshakeError = function (error) {\n        // Reset the token if it's a permanent error or the error code is\n        // ABORTED, signaling the write stream is no longer valid.\n        if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n            log.debug(LOG_TAG, 'RemoteStore error before completed handshake; resetting stream token: ', this.writeStream.lastStreamToken);\n            this.writeStream.lastStreamToken = emptyByteString();\n            return this.localStore.setLastStreamToken(emptyByteString());\n        }\n        else {\n            // Some other error, don't reset stream token. Our stream logic will\n            // just retry with exponential backoff.\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.handleWriteError = function (error) {\n        var _this = this;\n        if (isPermanentError(error.code)) {\n            // This was a permanent error, the request itself was the problem\n            // so it's not going to succeed if we resend it.\n            var batch = this.pendingWrites.shift();\n            // In this case it's also unlikely that the server itself is melting\n            // down -- this was just a bad request so inhibit backoff on the next\n            // restart.\n            this.writeStream.inhibitBackoff();\n            return this.syncEngine\n                .rejectFailedWrite(batch.batchId, error)\n                .then(function () {\n                // It's possible that with the completion of this mutation\n                // another slot has freed up.\n                return _this.fillWritePipeline();\n            });\n        }\n        else {\n            // Transient error, just let the retry logic kick in.\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.createTransaction = function () {\n        return new Transaction(this.datastore);\n    };\n    RemoteStore.prototype.handleUserChange = function (user) {\n        var _this = this;\n        log.debug(LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n        // Clear pending writes because those are per-user. Watched targets\n        // persist across users so don't clear those.\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        this.pendingWrites = [];\n        // Stop the streams. They promise not to call us back.\n        this.watchStream.stop();\n        this.writeStream.stop();\n        this.cleanupWatchStreamState();\n        // Create new streams (but note they're not started yet).\n        return this.setupStreams()\n            .then(function () {\n            // If there are any watchedTargets, properly handle the stream\n            // restart now that RemoteStore is ready to handle them.\n            if (_this.shouldStartWatchStream()) {\n                _this.startWatchStream();\n            }\n            // Resume any writes\n            return _this.fillWritePipeline();\n        })\n            .then(function () {\n            // User change moves us back to the unknown state because we might\n            // not want to re-open the stream\n            _this.setOnlineStateToUnknown();\n        });\n    };\n    return RemoteStore;\n}());\nexport { RemoteStore };\n\n\n"]}