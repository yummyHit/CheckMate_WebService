{"version":3,"sources":["src/firestore/platform_node/grpc_connection.ts","firestore/platform_node/grpc_connection.js"],"names":["log","SDK_VERSION","dynamicRequire","require","grpc","grpcVersion","version","util","LOG_TAG","X_GOOG_API_CLIENT_VALUE","process","versions","node","createHeaders","databaseInfo","token","type","channelCredentials","ssl","credentials","createSsl","createInsecure","callCredentials","createFromMetadataGenerator","context","cb","metadata","Metadata","header","authHeaders","hasOwnProperty","set","databaseId","projectId","database","combineChannelCredentials","GrpcConnection","builder","cachedStub","protos","loadObject","ns","firestore","google","v1beta1","prototype","sameToken","tokenA","tokenB","valueA","valueB","getStub","debug","stub","Firestore","host","invoke","rpcName","request","callback","grpcError","value","JSON","stringify","code","message","undefined","openStream","grpcStream","closed","close","remoteEnded","stream","sendFn","msg","inspect","depth","write","e","error","closeFn","err","callOnClose","end","on","callOnMessage","setTimeout","status","details","callOnOpen"],"mappings":"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","file":"grpc_connection.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// TODO(dimond): The following imports have been replaced with require\n// statements to not let the google closure compiler try to resolve them at\n// compile time.\n// import * as grpc from 'grpc';\n// import * as protobufjs from 'protobufjs';\n// import * as util from 'util';\n\nimport firebase from '../../app';\nconst SDK_VERSION = firebase.SDK_VERSION;\n// Temporary type definition until types work again (see above)\nexport type GrpcMetadataCallback = any;\n\n// Trick the TS compiler & Google closure compiler into executing normal require\n// statements, not using goog.require to import modules at compile time\nconst dynamicRequire = require;\nconst grpc = dynamicRequire('grpc');\nconst grpcVersion = dynamicRequire('grpc/package.json').version;\nconst util = dynamicRequire('util');\n\nimport { Token } from '../api/credentials';\nimport { DatabaseInfo } from '../core/database_info';\nimport { Connection, Stream } from '../remote/connection';\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { mapCodeFromRpcCode } from '../remote/rpc_error';\nimport { assert } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AnyJs } from '../util/misc';\nimport { NodeCallback, nodePromise } from '../util/node_api';\nimport { ProtobufProtoBuilder } from './load_protos';\n\nconst LOG_TAG = 'Connection';\n\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions\n  .node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\n\nfunction createHeaders(databaseInfo: DatabaseInfo, token: Token | null): {} {\n  assert(\n    token === null || token.type === 'OAuth',\n    'If provided, token must be OAuth'\n  );\n\n  const channelCredentials = databaseInfo.ssl\n    ? grpc.credentials.createSsl()\n    : grpc.credentials.createInsecure();\n\n  const callCredentials = grpc.credentials.createFromMetadataGenerator(\n    (context: { serviceUrl: string }, cb: GrpcMetadataCallback) => {\n      const metadata = new grpc.Metadata();\n      if (token) {\n        for (const header in token.authHeaders) {\n          if (token.authHeaders.hasOwnProperty(header)) {\n            metadata.set(header, token.authHeaders[header]);\n          }\n        }\n      }\n      metadata.set('x-goog-api-client', X_GOOG_API_CLIENT_VALUE);\n      // This header is used to improve routing and project isolation by the\n      // backend.\n      metadata.set(\n        'google-cloud-resource-prefix',\n        `projects/${databaseInfo.databaseId.projectId}/` +\n          `databases/${databaseInfo.databaseId.database}`\n      );\n      cb(null, metadata);\n    }\n  );\n\n  return grpc.credentials.combineChannelCredentials(\n    channelCredentials,\n    callCredentials\n  );\n}\n\ninterface CachedStub {\n  // The type of these stubs is dynamically generated by the GRPC runtime\n  // from the protocol buffer.\n  // tslint:disable-next-line:no-any\n  stub: any;\n\n  token: Token | null;\n}\n\n/** GRPC errors expose a code property. */\ninterface GrpcError extends Error {\n  code: number;\n}\n\n/** GRPC status information. */\ninterface GrpcStatus {\n  code: number;\n  details: string;\n}\n\n/**\n * A Connection implemented by GRPC-Node.\n */\nexport class GrpcConnection implements Connection {\n  // tslint:disable-next-line:no-any\n  private firestore: any;\n\n  // We cache stubs for the most-recently-used token.\n  private cachedStub: CachedStub | null = null;\n\n  constructor(\n    builder: ProtobufProtoBuilder,\n    private databaseInfo: DatabaseInfo\n  ) {\n    const protos = grpc.loadObject(builder.ns);\n    this.firestore = protos.google.firestore.v1beta1;\n  }\n\n  private sameToken(tokenA: Token | null, tokenB: Token | null): boolean {\n    const valueA = tokenA && tokenA.authHeaders['Authorization'];\n    const valueB = tokenB && tokenB.authHeaders['Authorization'];\n    return valueA === valueB;\n  }\n\n  // tslint:disable-next-line:no-any\n  private getStub(token: Token | null): any {\n    if (!this.cachedStub || !this.sameToken(this.cachedStub.token, token)) {\n      log.debug(LOG_TAG, 'Creating datastore stubs.');\n      const credentials = createHeaders(this.databaseInfo, token);\n      this.cachedStub = {\n        stub: new this.firestore.Firestore(this.databaseInfo.host, credentials),\n        token: token\n      };\n    }\n    return this.cachedStub.stub;\n  }\n\n  invoke(rpcName: string, request: any, token: Token | null): Promise<any> {\n    const stub = this.getStub(token);\n    return nodePromise((callback: NodeCallback<AnyJs>) => {\n      return stub[rpcName](request, (grpcError?: GrpcError, value?: AnyJs) => {\n        if (grpcError) {\n          log.debug(\n            LOG_TAG,\n            'RPC \"' +\n              rpcName +\n              '\" failed with error ' +\n              JSON.stringify(grpcError)\n          );\n          callback(\n            new FirestoreError(\n              mapCodeFromRpcCode(grpcError.code),\n              grpcError.message\n            )\n          );\n        } else {\n          callback(undefined, value);\n        }\n      });\n    });\n  }\n\n  // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\n  openStream(rpcName: string, token: Token | null): Stream<any, any> {\n    const stub = this.getStub(token);\n    const grpcStream = stub[rpcName]();\n\n    let closed = false;\n    let close: (err?: Error) => void;\n    let remoteEnded = false;\n\n    const stream = new StreamBridge({\n      sendFn: (msg: any) => {\n        if (!closed) {\n          log.debug(\n            LOG_TAG,\n            'GRPC stream sending:',\n            util.inspect(msg, { depth: 100 })\n          );\n          try {\n            grpcStream.write(msg);\n          } catch (e) {\n            // This probably means we didn't conform to the proto.  Make sure to\n            // log the message we sent.\n            log.error(\n              LOG_TAG,\n              'Failure sending: ',\n              util.inspect(msg, { depth: 100 })\n            );\n            log.error(LOG_TAG, 'Error: ', e);\n            throw e;\n          }\n        } else {\n          log.debug(\n            LOG_TAG,\n            'Not sending because gRPC stream is closed:',\n            util.inspect(msg, { depth: 100 })\n          );\n        }\n      },\n      closeFn: () => {\n        close();\n      }\n    });\n\n    close = (err?: FirestoreError) => {\n      if (!closed) {\n        closed = true;\n        stream.callOnClose(err);\n        grpcStream.end();\n      }\n    };\n\n    grpcStream.on('data', (msg: {}) => {\n      if (!closed) {\n        log.debug(\n          LOG_TAG,\n          'GRPC stream received: ',\n          util.inspect(msg, { depth: 100 })\n        );\n        stream.callOnMessage(msg);\n      }\n    });\n\n    grpcStream.on('end', () => {\n      log.debug(LOG_TAG, 'GRPC stream ended.');\n      // The server closed the remote end.  Close our side too (which will\n      // trigger the 'finish' event).\n      remoteEnded = true;\n      grpcStream.end();\n    });\n\n    grpcStream.on('finish', () => {\n      // This means we've closed the write side of the stream.  We either did\n      // this because the StreamBridge was close()ed or because we got an 'end'\n      // event from the grpcStream.\n\n      // TODO(mikelehen): This is a hack because of weird grpc-node behavior\n      // (https://github.com/grpc/grpc/issues/7705).  The stream may be finished\n      // because we called end() because we got an 'end' event because there was\n      // an error.  Now that we've called end(), GRPC should deliver the error,\n      // but it may take some time (e.g. 700ms). So we delay our close handling\n      // in case we receive such an error.\n      if (remoteEnded) {\n        setTimeout(close, 2500);\n      } else {\n        close();\n      }\n    });\n\n    grpcStream.on('error', (grpcError: GrpcError) => {\n      log.debug(LOG_TAG, 'GRPC stream error:', grpcError);\n      const code = mapCodeFromRpcCode(grpcError.code);\n      close(new FirestoreError(code, grpcError.message));\n    });\n\n    grpcStream.on('status', (status: GrpcStatus) => {\n      if (!closed) {\n        log.debug(LOG_TAG, 'GRPC stream received status:', status);\n        if (status.code === 0) {\n          // all good\n        } else {\n          const code = mapCodeFromRpcCode(status.code);\n          close(new FirestoreError(code, status.details));\n        }\n      }\n    });\n\n    log.debug(LOG_TAG, 'Opening GRPC stream');\n    // TODO(dimond): Since grpc has no explicit open status (or does it?) we\n    // simulate an onOpen in the next loop after the stream had it's listeners\n    // registered\n    setTimeout(() => {\n      stream.callOnOpen();\n    }, 0);\n\n    return stream;\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(dimond): The following imports have been replaced with require\n// statements to not let the google closure compiler try to resolve them at\n// compile time.\n// import * as grpc from 'grpc';\n// import * as protobufjs from 'protobufjs';\n// import * as util from 'util';\nimport firebase from '../../app';\nvar SDK_VERSION = firebase.SDK_VERSION;\n// Trick the TS compiler & Google closure compiler into executing normal require\n// statements, not using goog.require to import modules at compile time\nvar dynamicRequire = require;\nvar grpc = dynamicRequire('grpc');\nvar grpcVersion = dynamicRequire('grpc/package.json').version;\nvar util = dynamicRequire('util');\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { mapCodeFromRpcCode } from '../remote/rpc_error';\nimport { assert } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { nodePromise } from '../util/node_api';\nvar LOG_TAG = 'Connection';\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nvar X_GOOG_API_CLIENT_VALUE = \"gl-node/\" + process.versions\n    .node + \" fire/\" + SDK_VERSION + \" grpc/\" + grpcVersion;\nfunction createHeaders(databaseInfo, token) {\n    assert(token === null || token.type === 'OAuth', 'If provided, token must be OAuth');\n    var channelCredentials = databaseInfo.ssl\n        ? grpc.credentials.createSsl()\n        : grpc.credentials.createInsecure();\n    var callCredentials = grpc.credentials.createFromMetadataGenerator(function (context, cb) {\n        var metadata = new grpc.Metadata();\n        if (token) {\n            for (var header in token.authHeaders) {\n                if (token.authHeaders.hasOwnProperty(header)) {\n                    metadata.set(header, token.authHeaders[header]);\n                }\n            }\n        }\n        metadata.set('x-goog-api-client', X_GOOG_API_CLIENT_VALUE);\n        // This header is used to improve routing and project isolation by the\n        // backend.\n        metadata.set('google-cloud-resource-prefix', \"projects/\" + databaseInfo.databaseId.projectId + \"/\" +\n            (\"databases/\" + databaseInfo.databaseId.database));\n        cb(null, metadata);\n    });\n    return grpc.credentials.combineChannelCredentials(channelCredentials, callCredentials);\n}\n/**\n * A Connection implemented by GRPC-Node.\n */\nvar GrpcConnection = /** @class */ (function () {\n    function GrpcConnection(builder, databaseInfo) {\n        this.databaseInfo = databaseInfo;\n        // We cache stubs for the most-recently-used token.\n        this.cachedStub = null;\n        var protos = grpc.loadObject(builder.ns);\n        this.firestore = protos.google.firestore.v1beta1;\n    }\n    GrpcConnection.prototype.sameToken = function (tokenA, tokenB) {\n        var valueA = tokenA && tokenA.authHeaders['Authorization'];\n        var valueB = tokenB && tokenB.authHeaders['Authorization'];\n        return valueA === valueB;\n    };\n    // tslint:disable-next-line:no-any\n    GrpcConnection.prototype.getStub = function (token) {\n        if (!this.cachedStub || !this.sameToken(this.cachedStub.token, token)) {\n            log.debug(LOG_TAG, 'Creating datastore stubs.');\n            var credentials = createHeaders(this.databaseInfo, token);\n            this.cachedStub = {\n                stub: new this.firestore.Firestore(this.databaseInfo.host, credentials),\n                token: token\n            };\n        }\n        return this.cachedStub.stub;\n    };\n    GrpcConnection.prototype.invoke = function (rpcName, request, token) {\n        var stub = this.getStub(token);\n        return nodePromise(function (callback) {\n            return stub[rpcName](request, function (grpcError, value) {\n                if (grpcError) {\n                    log.debug(LOG_TAG, 'RPC \"' +\n                        rpcName +\n                        '\" failed with error ' +\n                        JSON.stringify(grpcError));\n                    callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));\n                }\n                else {\n                    callback(undefined, value);\n                }\n            });\n        });\n    };\n    // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\n    GrpcConnection.prototype.openStream = function (rpcName, token) {\n        var stub = this.getStub(token);\n        var grpcStream = stub[rpcName]();\n        var closed = false;\n        var close;\n        var remoteEnded = false;\n        var stream = new StreamBridge({\n            sendFn: function (msg) {\n                if (!closed) {\n                    log.debug(LOG_TAG, 'GRPC stream sending:', util.inspect(msg, { depth: 100 }));\n                    try {\n                        grpcStream.write(msg);\n                    }\n                    catch (e) {\n                        // This probably means we didn't conform to the proto.  Make sure to\n                        // log the message we sent.\n                        log.error(LOG_TAG, 'Failure sending: ', util.inspect(msg, { depth: 100 }));\n                        log.error(LOG_TAG, 'Error: ', e);\n                        throw e;\n                    }\n                }\n                else {\n                    log.debug(LOG_TAG, 'Not sending because gRPC stream is closed:', util.inspect(msg, { depth: 100 }));\n                }\n            },\n            closeFn: function () {\n                close();\n            }\n        });\n        close = function (err) {\n            if (!closed) {\n                closed = true;\n                stream.callOnClose(err);\n                grpcStream.end();\n            }\n        };\n        grpcStream.on('data', function (msg) {\n            if (!closed) {\n                log.debug(LOG_TAG, 'GRPC stream received: ', util.inspect(msg, { depth: 100 }));\n                stream.callOnMessage(msg);\n            }\n        });\n        grpcStream.on('end', function () {\n            log.debug(LOG_TAG, 'GRPC stream ended.');\n            // The server closed the remote end.  Close our side too (which will\n            // trigger the 'finish' event).\n            remoteEnded = true;\n            grpcStream.end();\n        });\n        grpcStream.on('finish', function () {\n            // This means we've closed the write side of the stream.  We either did\n            // this because the StreamBridge was close()ed or because we got an 'end'\n            // event from the grpcStream.\n            // TODO(mikelehen): This is a hack because of weird grpc-node behavior\n            // (https://github.com/grpc/grpc/issues/7705).  The stream may be finished\n            // because we called end() because we got an 'end' event because there was\n            // an error.  Now that we've called end(), GRPC should deliver the error,\n            // but it may take some time (e.g. 700ms). So we delay our close handling\n            // in case we receive such an error.\n            if (remoteEnded) {\n                setTimeout(close, 2500);\n            }\n            else {\n                close();\n            }\n        });\n        grpcStream.on('error', function (grpcError) {\n            log.debug(LOG_TAG, 'GRPC stream error:', grpcError);\n            var code = mapCodeFromRpcCode(grpcError.code);\n            close(new FirestoreError(code, grpcError.message));\n        });\n        grpcStream.on('status', function (status) {\n            if (!closed) {\n                log.debug(LOG_TAG, 'GRPC stream received status:', status);\n                if (status.code === 0) {\n                    // all good\n                }\n                else {\n                    var code = mapCodeFromRpcCode(status.code);\n                    close(new FirestoreError(code, status.details));\n                }\n            }\n        });\n        log.debug(LOG_TAG, 'Opening GRPC stream');\n        // TODO(dimond): Since grpc has no explicit open status (or does it?) we\n        // simulate an onOpen in the next loop after the stream had it's listeners\n        // registered\n        setTimeout(function () {\n            stream.callOnOpen();\n        }, 0);\n        return stream;\n    };\n    return GrpcConnection;\n}());\nexport { GrpcConnection };\n\n\n"]}