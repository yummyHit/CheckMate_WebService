{"version":3,"sources":["src/firestore/local/memory_remote_document_cache.ts","firestore/local/memory_remote_document_cache.js"],"names":["MemoryRemoteDocumentCache","docs","prototype","addEntry","transaction","maybeDocument","insert","key","resolve","removeEntry","documentKey","remove","getEntry","get","getDocumentsMatchingQuery","query","results","prefix","path","child","iterator","getIteratorFrom","hasNext","_a","getNext","maybeDoc","value","isPrefixOf","matches"],"mappings":";;;;;;;AAiBA;;AAKA;;AACA;;AAKA;;AA5BA;;;;;;;;;;;;;;;AA+BA,IAAAA,4BAAA,aAAA,YAAA;AAAA,aAAAA,yBAAA,GAAA;AACU,aAAAC,IAAA,GAAO,oCAAP;AA8CT;AA5CCD,8BAAAE,SAAA,CAAAC,QAAA,GAAA,UACEC,WADF,EAEEC,aAFF,EAE8B;AAE5B,aAAKJ,IAAL,GAAY,KAAKA,IAAL,CAAUK,MAAV,CAAiBD,cAAcE,GAA/B,EAAoCF,aAApC,CAAZ;AACA,eAAO,wCAAmBG,OAAnB,EAAP;AACD,KAND;AAQAR,8BAAAE,SAAA,CAAAO,WAAA,GAAA,UACEL,WADF,EAEEM,WAFF,EAE0B;AAExB,aAAKT,IAAL,GAAY,KAAKA,IAAL,CAAUU,MAAV,CAAiBD,WAAjB,CAAZ;AACA,eAAO,wCAAmBF,OAAnB,EAAP;AACD,KAND;AAQAR,8BAAAE,SAAA,CAAAU,QAAA,GAAA,UACER,WADF,EAEEM,WAFF,EAE0B;AAExB,eAAO,wCAAmBF,OAAnB,CAA2B,KAAKP,IAAL,CAAUY,GAAV,CAAcH,WAAd,CAA3B,CAAP;AACD,KALD;AAOAV,8BAAAE,SAAA,CAAAY,yBAAA,GAAA,UACEV,WADF,EAEEW,KAFF,EAEc;AAEZ,YAAIC,UAAU,+BAAd;AAEA;AACA;AACA,YAAMC,SAAS,8BAAgBF,MAAMG,IAAN,CAAWC,KAAX,CAAiB,EAAjB,CAAhB,CAAf;AACA,YAAMC,WAAW,KAAKnB,IAAL,CAAUoB,eAAV,CAA0BJ,MAA1B,CAAjB;AACA,eAAOG,SAASE,OAAT,EAAP,EAA2B;AACnB,gBAAAC,KAAAH,SAAAI,OAAA,EAAA;AAAA,gBAAEjB,MAAAgB,GAAAhB,GAAF;AAAA,gBAAOkB,WAAAF,GAAAG,KAAP;AACN,gBAAI,CAACX,MAAMG,IAAN,CAAWS,UAAX,CAAsBpB,IAAIW,IAA1B,CAAL,EAAsC;AACpC;AACD;AACD,gBAAIO,0CAAgCV,MAAMa,OAAN,CAAcH,QAAd,CAApC,EAA6D;AAC3DT,0BAAUA,QAAQV,MAAR,CAAemB,SAASlB,GAAxB,EAA6BkB,QAA7B,CAAV;AACD;AACF;AACD,eAAO,wCAAmBjB,OAAnB,CAA2BQ,OAA3B,CAAP;AACD,KApBD;AAqBF,WAAAhB,yBAAA;AA/CA,CAAA,EAAA;QCsBSA,yB,GAAAA,yB","file":"memory_remote_document_cache.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport {\n  DocumentMap,\n  documentMap,\n  maybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\nexport class MemoryRemoteDocumentCache implements RemoteDocumentCache {\n  private docs = maybeDocumentMap();\n\n  addEntry(\n    transaction: PersistenceTransaction,\n    maybeDocument: MaybeDocument\n  ): PersistencePromise<void> {\n    this.docs = this.docs.insert(maybeDocument.key, maybeDocument);\n    return PersistencePromise.resolve();\n  }\n\n  removeEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<void> {\n    this.docs = this.docs.remove(documentKey);\n    return PersistencePromise.resolve();\n  }\n\n  getEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    return PersistencePromise.resolve(this.docs.get(documentKey));\n  }\n\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    let results = documentMap();\n\n    // Documents are ordered by key, so we can use a prefix scan to narrow down\n    // the documents we need to match the query against.\n    const prefix = new DocumentKey(query.path.child(''));\n    const iterator = this.docs.getIteratorFrom(prefix);\n    while (iterator.hasNext()) {\n      const { key, value: maybeDoc } = iterator.getNext();\n      if (!query.path.isPrefixOf(key.path)) {\n        break;\n      }\n      if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n        results = results.insert(maybeDoc.key, maybeDoc);\n      }\n    }\n    return PersistencePromise.resolve(results);\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { PersistencePromise } from './persistence_promise';\nvar MemoryRemoteDocumentCache = /** @class */ (function () {\n    function MemoryRemoteDocumentCache() {\n        this.docs = maybeDocumentMap();\n    }\n    MemoryRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        this.docs = this.docs.insert(maybeDocument.key, maybeDocument);\n        return PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        this.docs = this.docs.remove(documentKey);\n        return PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        return PersistencePromise.resolve(this.docs.get(documentKey));\n    };\n    MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var prefix = new DocumentKey(query.path.child(''));\n        var iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            var _a = iterator.getNext(), key = _a.key, maybeDoc = _a.value;\n            if (!query.path.isPrefixOf(key.path)) {\n                break;\n            }\n            if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        }\n        return PersistencePromise.resolve(results);\n    };\n    return MemoryRemoteDocumentCache;\n}());\nexport { MemoryRemoteDocumentCache };\n\n\n"]}