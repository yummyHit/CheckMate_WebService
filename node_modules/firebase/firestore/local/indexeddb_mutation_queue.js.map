{"version":3,"sources":["src/firestore/local/indexeddb_mutation_queue.ts","firestore/local/indexeddb_mutation_queue.js"],"names":["EncodedResourcePath","IndexedDbMutationQueue","userId","serializer","garbageCollector","forUser","user","uid","isUnauthenticated","prototype","start","transaction","_this","loadNextBatchIdFromDb","next","nextBatchId","mutationQueuesStore","get","metadata","lastAcknowledgedBatchId","checkEmpty","empty","put","resolve","txn","maxBatchId","mutationsStore","iterate","reverse","key","batch","control","batchId","done","nextUser","skip","range","IDBKeyRange","bound","keyForBatchId","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","value","getNextBatchId","getHighestAcknowledgedBatchId","acknowledgeBatch","streamToken","lastStreamToken","validateStreamToken","getLastStreamToken","setLastStreamToken","addMutationBatch","localWriteTime","mutations","dbBatch","toDbMutationBatch","promises","_i","mutations_1","length","mutation","encodedPath","encode","path","indexKey","documentMutationsStore","PLACEHOLDER","waitFor","lookupMutationBatch","fromDbMutationBatch","getNextMutationBatchAfterBatchId","lowerBound","foundBatch","getAllMutationBatches","loadAll","dbBatches","map","getAllMutationBatchesThroughBatchId","getAllMutationBatchesAffectingDocumentKey","documentKey","indexPrefix","prefixForPath","indexStart","results","_","userID","batchID","decode","equals","mutationKey","push","getAllMutationBatchesAffectingQuery","query","isDocumentQuery","queryPath","immediateChildrenLength","encodedQueryPath","uniqueBatchIDs","isPrefixOf","add","forEach","removeMutationBatches","batches","indexTxn","_loop_1","only","this_1","numDeleted","removePromise","delete","_a","addPotentialGarbageKey","batches_1","performConsistencyCheck","startRange","prefixForUser","danglingMutationReferences","p","canonicalString","setGarbageCollector","gc","containsKey","keysOnly","keyPath","token","getStore","store"],"mappings":"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","file":"indexeddb_mutation_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { Query } from '../core/query';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { immediatePredecessor, primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { GarbageCollector } from './garbage_collector';\nimport {\n  DbDocumentMutation,\n  DbDocumentMutationKey,\n  DbMutationBatch,\n  DbMutationBatchKey,\n  DbMutationQueue,\n  DbMutationQueueKey\n} from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbStore, SimpleDbTransaction } from './simple_db';\n\n/** A mutation queue for a specific user, backed by IndexedDB. */\nexport class IndexedDbMutationQueue implements MutationQueue {\n  /**\n   * Next value to use when assigning sequential IDs to each mutation batch.\n   *\n   * NOTE: There can only be one IndexedDbMutationQueue for a given db at a\n   * time, hence it is safe to track nextBatchID as an instance-level property.\n   * Should we ever relax this constraint we'll need to revisit this.\n   */\n  private nextBatchId: BatchId;\n\n  /**\n   * A write-through cache copy of the metadata describing the current queue.\n   */\n  private metadata: DbMutationQueue;\n\n  private garbageCollector: GarbageCollector | null = null;\n\n  constructor(\n    /**\n       * The normalized userId (e.g. null UID => \"\" userId) used to store /\n       * retrieve mutations.\n       */\n    private userId: string,\n    private serializer: LocalSerializer\n  ) {}\n\n  /**\n   * Creates a new mutation queue for the given user.\n   * @param user The user for which to create a mutation queue.\n   * @param serializer The serializer to use when persisting to IndexedDb.\n   */\n  static forUser(user: User, serializer: LocalSerializer) {\n    // TODO(mcg): Figure out what constraints there are on userIDs\n    // In particular, are there any reserved characters? are empty ids allowed?\n    // For the moment store these together in the same mutations table assuming\n    // that empty userIDs aren't allowed.\n    assert(user.uid !== '', 'UserID must not be an empty string.');\n    const userId = user.isUnauthenticated() ? '' : user.uid!;\n    return new IndexedDbMutationQueue(userId, serializer);\n  }\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction)\n      .next(nextBatchId => {\n        this.nextBatchId = nextBatchId;\n        return mutationQueuesStore(transaction).get(this.userId);\n      })\n      .next((metadata: DbMutationQueue | null) => {\n        if (!metadata) {\n          metadata = new DbMutationQueue(\n            this.userId,\n            BATCHID_UNKNOWN,\n            /*lastStreamToken=*/ ''\n          );\n        }\n        this.metadata = metadata;\n\n        // On restart, nextBatchId may end up lower than\n        // lastAcknowledgedBatchId since it's computed from the queue\n        // contents, and there may be no mutations in the queue. In this\n        // case, we need to reset lastAcknowledgedBatchId (which is safe\n        // since the queue must be empty).\n        if (this.metadata.lastAcknowledgedBatchId >= this.nextBatchId) {\n          return this.checkEmpty(transaction).next(empty => {\n            assert(\n              empty,\n              'Reset nextBatchID is only possible when the queue is empty'\n            );\n\n            this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n            return mutationQueuesStore(transaction).put(this.metadata);\n          });\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n  }\n\n  /**\n   * Returns one larger than the largest batch ID that has been stored. If there\n   * are no mutations returns 0. Note that batch IDs are global.\n   */\n  static loadNextBatchIdFromDb(\n    txn: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    let maxBatchId = BATCHID_UNKNOWN;\n    return mutationsStore(txn)\n      .iterate({ reverse: true }, (key, batch, control) => {\n        const [userId, batchId] = key;\n        if (batchId > maxBatchId) {\n          maxBatchId = batch.batchId;\n        }\n\n        if (userId === '') {\n          // We can't compute a predecessor for the empty string, since it\n          // is lexographically first. That also means that no other\n          // userIds can come before this one, so we can just exit early.\n          control.done();\n        } else {\n          const nextUser = immediatePredecessor(userId);\n          control.skip([nextUser]);\n        }\n      })\n      .next(() => maxBatchId + 1);\n  }\n\n  checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean> {\n    let empty = true;\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(Number.NEGATIVE_INFINITY),\n      this.keyForBatchId(Number.POSITIVE_INFINITY)\n    );\n    return mutationsStore(transaction)\n      .iterate({ range }, (key, value, control) => {\n        empty = false;\n        control.done();\n      })\n      .next(() => empty);\n  }\n\n  getNextBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.nextBatchId);\n  }\n\n  getHighestAcknowledgedBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n  }\n\n  acknowledgeBatch(\n    transaction: PersistenceTransaction,\n    batch: MutationBatch,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    const batchId = batch.batchId;\n    assert(\n      batchId > this.metadata.lastAcknowledgedBatchId,\n      'Mutation batchIDs must be acknowledged in order'\n    );\n\n    this.metadata.lastAcknowledgedBatchId = batchId;\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n\n    return mutationQueuesStore(transaction).put(this.metadata);\n  }\n\n  getLastStreamToken(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<ProtoByteString> {\n    return PersistencePromise.resolve(this.metadata.lastStreamToken);\n  }\n\n  setLastStreamToken(\n    transaction: PersistenceTransaction,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n    return mutationQueuesStore(transaction).put(this.metadata);\n  }\n\n  addMutationBatch(\n    transaction: PersistenceTransaction,\n    localWriteTime: Timestamp,\n    mutations: Mutation[]\n  ): PersistencePromise<MutationBatch> {\n    const batchId = this.nextBatchId;\n    this.nextBatchId++;\n    const batch = new MutationBatch(batchId, localWriteTime, mutations);\n\n    const dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n\n    return mutationsStore(transaction)\n      .put(dbBatch)\n      .next(() => {\n        const promises: Array<PersistencePromise<void>> = [];\n        for (const mutation of mutations) {\n          const encodedPath = EncodedResourcePath.encode(mutation.key.path);\n          const indexKey = DbDocumentMutation.key(\n            this.userId,\n            mutation.key.path,\n            batchId\n          );\n          documentMutationsStore(transaction).put(\n            indexKey,\n            DbDocumentMutation.PLACEHOLDER\n          );\n        }\n        return PersistencePromise.waitFor(promises);\n      })\n      .next(() => {\n        return batch;\n      });\n  }\n\n  lookupMutationBatch(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    return mutationsStore(transaction)\n      .get(this.keyForBatchId(batchId))\n      .next(\n        dbBatch =>\n          dbBatch ? this.serializer.fromDbMutationBatch(dbBatch) : null\n      );\n  }\n\n  getNextMutationBatchAfterBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    const range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));\n    let foundBatch: MutationBatch | null = null;\n    return mutationsStore(transaction)\n      .iterate({ range }, (key, dbBatch, control) => {\n        if (dbBatch.userId === this.userId) {\n          assert(\n            dbBatch.batchId > batchId,\n            'Should have found mutation after ' + batchId\n          );\n          foundBatch = this.serializer.fromDbMutationBatch(dbBatch);\n        }\n        control.done();\n      })\n      .next(() => foundBatch);\n  }\n\n  getAllMutationBatches(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<MutationBatch[]> {\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(BATCHID_UNKNOWN),\n      this.keyForBatchId(Number.POSITIVE_INFINITY)\n    );\n    return mutationsStore(transaction)\n      .loadAll(range)\n      .next(dbBatches =>\n        dbBatches.map(dbBatch => this.serializer.fromDbMutationBatch(dbBatch))\n      );\n  }\n\n  getAllMutationBatchesThroughBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch[]> {\n    const range = IDBKeyRange.bound(\n      this.keyForBatchId(BATCHID_UNKNOWN),\n      this.keyForBatchId(batchId)\n    );\n    return mutationsStore(transaction)\n      .loadAll(range)\n      .next(dbBatches =>\n        dbBatches.map(dbBatch => this.serializer.fromDbMutationBatch(dbBatch))\n      );\n  }\n\n  getAllMutationBatchesAffectingDocumentKey(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MutationBatch[]> {\n    // Scan the document-mutation index starting with a prefix starting with\n    // the given documentKey.\n    const indexPrefix = DbDocumentMutation.prefixForPath(\n      this.userId,\n      documentKey.path\n    );\n    const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n\n    const results: MutationBatch[] = [];\n    return documentMutationsStore(transaction)\n      .iterate({ range: indexStart }, (indexKey, _, control) => {\n        const [userID, encodedPath, batchID] = indexKey;\n\n        // Only consider rows matching exactly the specific key of\n        // interest. Note that because we order by path first, and we\n        // order terminators before path separators, we'll encounter all\n        // the index rows for documentKey contiguously. In particular, all\n        // the rows for documentKey will occur before any rows for\n        // documents nested in a subcollection beneath documentKey so we\n        // can stop as soon as we hit any such row.\n        const path = EncodedResourcePath.decode(encodedPath);\n        if (userID !== this.userId || !documentKey.path.equals(path)) {\n          control.done();\n          return;\n        }\n        const mutationKey = this.keyForBatchId(batchID);\n        // Look up the mutation batch in the store.\n        // PORTING NOTE: because iteration is callback driven in the web,\n        // we just look up the key instead of keeping an open iterator\n        // like iOS.\n        return mutationsStore(transaction)\n          .get(mutationKey)\n          .next(dbBatch => {\n            if (dbBatch === null) {\n              fail(\n                'Dangling document-mutation reference found: ' +\n                  indexKey +\n                  ' which points to ' +\n                  mutationKey\n              );\n            }\n            results.push(this.serializer.fromDbMutationBatch(dbBatch!));\n          });\n      })\n      .next(() => results);\n  }\n\n  getAllMutationBatchesAffectingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<MutationBatch[]> {\n    assert(\n      !query.isDocumentQuery(),\n      \"Document queries shouldn't go down this path\"\n    );\n\n    const queryPath = query.path;\n    const immediateChildrenLength = queryPath.length + 1;\n\n    // TODO(mcg): Actually implement a single-collection query\n    //\n    // This is actually executing an ancestor query, traversing the whole\n    // subtree below the collection which can be horrifically inefficient for\n    // some structures. The right way to solve this is to implement the full\n    // value index, but that's not in the cards in the near future so this is\n    // the best we can do for the moment.\n    //\n    // Since we don't yet index the actual properties in the mutations, our\n    // current approach is to just return all mutation batches that affect\n    // documents in the collection being queried.\n    const indexPrefix = DbDocumentMutation.prefixForPath(\n      this.userId,\n      queryPath\n    );\n    const encodedQueryPath = indexPrefix[1];\n    const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n\n    // Collect up unique batchIDs encountered during a scan of the index. Use a\n    // SortedSet to accumulate batch IDs so they can be traversed in order in a\n    // scan of the main table.\n    let uniqueBatchIDs = new SortedSet<BatchId>(primitiveComparator);\n    return documentMutationsStore(transaction)\n      .iterate({ range: indexStart }, (indexKey, _, control) => {\n        const [userID, encodedPath, batchID] = indexKey;\n        const path = EncodedResourcePath.decode(encodedPath);\n        if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\n          control.done();\n          return;\n        }\n        // Rows with document keys more than one segment longer than the\n        // query path can't be matches. For example, a query on 'rooms'\n        // can't match the document /rooms/abc/messages/xyx.\n        // TODO(mcg): we'll need a different scanner when we implement\n        // ancestor queries.\n        if (path.length !== immediateChildrenLength) {\n          return;\n        }\n        uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n      })\n      .next(() => {\n        const results: MutationBatch[] = [];\n        const promises: Array<PersistencePromise<void>> = [];\n        // TODO(rockwood): Implement this using iterate.\n        uniqueBatchIDs.forEach(batchID => {\n          const mutationKey = this.keyForBatchId(batchID);\n          promises.push(\n            mutationsStore(transaction)\n              .get(mutationKey)\n              .next(mutation => {\n                if (mutation === null) {\n                  fail(\n                    'Dangling document-mutation reference found, ' +\n                      'which points to ' +\n                      mutationKey\n                  );\n                }\n                results.push(this.serializer.fromDbMutationBatch(mutation!));\n              })\n          );\n        });\n        return PersistencePromise.waitFor(promises).next(() => results);\n      });\n  }\n\n  removeMutationBatches(\n    transaction: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<void> {\n    const txn = mutationsStore(transaction);\n    const indexTxn = documentMutationsStore(transaction);\n    const promises: Array<PersistencePromise<void>> = [];\n\n    for (const batch of batches) {\n      const range = IDBKeyRange.only(this.keyForBatchId(batch.batchId));\n      let numDeleted = 0;\n      const removePromise = txn.iterate({ range }, (key, value, control) => {\n        numDeleted++;\n        return control.delete();\n      });\n      promises.push(\n        removePromise.next(() => {\n          assert(\n            numDeleted === 1,\n            'Dangling document-mutation reference found: Missing batch ' +\n              batch.batchId\n          );\n        })\n      );\n      for (const mutation of batch.mutations) {\n        const indexKey = DbDocumentMutation.key(\n          this.userId,\n          mutation.key.path,\n          batch.batchId\n        );\n        promises.push(indexTxn.delete(indexKey));\n        if (this.garbageCollector !== null) {\n          this.garbageCollector.addPotentialGarbageKey(mutation.key);\n        }\n      }\n    }\n    return PersistencePromise.waitFor(promises);\n  }\n\n  performConsistencyCheck(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    return this.checkEmpty(txn).next(empty => {\n      if (!empty) {\n        return PersistencePromise.resolve();\n      }\n\n      // Verify that there are no entries in the documentMutations index if\n      // the queue is empty.\n      const startRange = IDBKeyRange.lowerBound(\n        DbDocumentMutation.prefixForUser(this.userId)\n      );\n      const danglingMutationReferences: ResourcePath[] = [];\n      return documentMutationsStore(txn)\n        .iterate({ range: startRange }, (key, _, control) => {\n          const userID = key[0];\n          if (userID !== this.userId) {\n            control.done();\n            return;\n          } else {\n            const path = EncodedResourcePath.decode(key[1]);\n            danglingMutationReferences.push(path);\n          }\n        })\n        .next(() => {\n          assert(\n            danglingMutationReferences.length === 0,\n            'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' +\n              danglingMutationReferences.map(p => p.canonicalString())\n          );\n        });\n    });\n  }\n\n  setGarbageCollector(gc: GarbageCollector | null): void {\n    this.garbageCollector = gc;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);\n    const encodedPath = indexKey[1];\n    const startRange = IDBKeyRange.lowerBound(indexKey);\n    let containsKey = false;\n    return documentMutationsStore(txn)\n      .iterate({ range: startRange, keysOnly: true }, (key, _, control) => {\n        const [userID, keyPath, batchID] = key;\n        if (userID === this.userId && keyPath === encodedPath) {\n          containsKey = true;\n        }\n        control.done();\n      })\n      .next(() => containsKey);\n  }\n\n  /**\n   * Creates a [userId, batchId] key for use with the DbMutationQueue object\n   * store.\n   */\n  private keyForBatchId(batchId: BatchId): DbMutationBatchKey {\n    return [this.userId, batchId];\n  }\n}\n\nfunction validateStreamToken(token: ProtoByteString): string {\n  assert(\n    typeof token === 'string',\n    'Persisting non-string stream token not supported.'\n  );\n  return token as string;\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbMutationBatchKey, DbMutationBatch> {\n  return getStore<DbMutationBatchKey, DbMutationBatch>(\n    txn,\n    DbMutationBatch.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbDocumentMutationKey, DbDocumentMutation> {\n  return getStore<DbDocumentMutationKey, DbDocumentMutation>(\n    txn,\n    DbDocumentMutation.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbMutationQueueKey, DbMutationQueue> {\n  return getStore<DbMutationQueueKey, DbMutationQueue>(\n    txn,\n    DbMutationQueue.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore<KeyType extends IDBValidKey, ValueType>(\n  txn: PersistenceTransaction,\n  store: string\n): SimpleDbStore<KeyType, ValueType> {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store<KeyType, ValueType>(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { immediatePredecessor, primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbDocumentMutation, DbMutationBatch, DbMutationQueue } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\n/** A mutation queue for a specific user, backed by IndexedDB. */\nvar IndexedDbMutationQueue = /** @class */ (function () {\n    function IndexedDbMutationQueue(\n        /**\n           * The normalized userId (e.g. null UID => \"\" userId) used to store /\n           * retrieve mutations.\n           */\n        userId, serializer) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.garbageCollector = null;\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user The user for which to create a mutation queue.\n     * @param serializer The serializer to use when persisting to IndexedDb.\n     */\n    IndexedDbMutationQueue.forUser = function (user, serializer) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        assert(user.uid !== '', 'UserID must not be an empty string.');\n        var userId = user.isUnauthenticated() ? '' : user.uid;\n        return new IndexedDbMutationQueue(userId, serializer);\n    };\n    IndexedDbMutationQueue.prototype.start = function (transaction) {\n        var _this = this;\n        return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction)\n            .next(function (nextBatchId) {\n            _this.nextBatchId = nextBatchId;\n            return mutationQueuesStore(transaction).get(_this.userId);\n        })\n            .next(function (metadata) {\n            if (!metadata) {\n                metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, \n                /*lastStreamToken=*/ '');\n            }\n            _this.metadata = metadata;\n            // On restart, nextBatchId may end up lower than\n            // lastAcknowledgedBatchId since it's computed from the queue\n            // contents, and there may be no mutations in the queue. In this\n            // case, we need to reset lastAcknowledgedBatchId (which is safe\n            // since the queue must be empty).\n            if (_this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId) {\n                return _this.checkEmpty(transaction).next(function (empty) {\n                    assert(empty, 'Reset nextBatchID is only possible when the queue is empty');\n                    _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n                    return mutationQueuesStore(transaction).put(_this.metadata);\n                });\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns one larger than the largest batch ID that has been stored. If there\n     * are no mutations returns 0. Note that batch IDs are global.\n     */\n    IndexedDbMutationQueue.loadNextBatchIdFromDb = function (txn) {\n        var maxBatchId = BATCHID_UNKNOWN;\n        return mutationsStore(txn)\n            .iterate({ reverse: true }, function (key, batch, control) {\n            var userId = key[0], batchId = key[1];\n            if (batchId > maxBatchId) {\n                maxBatchId = batch.batchId;\n            }\n            if (userId === '') {\n                // We can't compute a predecessor for the empty string, since it\n                // is lexographically first. That also means that no other\n                // userIds can come before this one, so we can just exit early.\n                control.done();\n            }\n            else {\n                var nextUser = immediatePredecessor(userId);\n                control.skip([nextUser]);\n            }\n        })\n            .next(function () { return maxBatchId + 1; });\n    };\n    IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {\n        var empty = true;\n        var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, value, control) {\n            empty = false;\n            control.done();\n        })\n            .next(function () { return empty; });\n    };\n    IndexedDbMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.nextBatchId);\n    };\n    IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n    };\n    IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        this.metadata.lastAcknowledgedBatchId = batchId;\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return PersistencePromise.resolve(this.metadata.lastStreamToken);\n    };\n    IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        var _this = this;\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        var batch = new MutationBatch(batchId, localWriteTime, mutations);\n        var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n        return mutationsStore(transaction)\n            .put(dbBatch)\n            .next(function () {\n            var promises = [];\n            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n                var mutation = mutations_1[_i];\n                var encodedPath = EncodedResourcePath.encode(mutation.key.path);\n                var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);\n                documentMutationsStore(transaction).put(indexKey, DbDocumentMutation.PLACEHOLDER);\n            }\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            return batch;\n        });\n    };\n    IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        var _this = this;\n        return mutationsStore(transaction)\n            .get(this.keyForBatchId(batchId))\n            .next(function (dbBatch) {\n            return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;\n        });\n    };\n    IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var _this = this;\n        var range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));\n        var foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, dbBatch, control) {\n            if (dbBatch.userId === _this.userId) {\n                assert(dbBatch.batchId > batchId, 'Should have found mutation after ' + batchId);\n                foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);\n            }\n            control.done();\n        })\n            .next(function () { return foundBatch; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        var results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            var path = EncodedResourcePath.decode(encodedPath);\n            if (userID !== _this.userId || !documentKey.path.equals(path)) {\n                control.done();\n                return;\n            }\n            var mutationKey = _this.keyForBatchId(batchID);\n            // Look up the mutation batch in the store.\n            // PORTING NOTE: because iteration is callback driven in the web,\n            // we just look up the key instead of keeping an open iterator\n            // like iOS.\n            return mutationsStore(transaction)\n                .get(mutationKey)\n                .next(function (dbBatch) {\n                if (dbBatch === null) {\n                    fail('Dangling document-mutation reference found: ' +\n                        indexKey +\n                        ' which points to ' +\n                        mutationKey);\n                }\n                results.push(_this.serializer.fromDbMutationBatch(dbBatch));\n            });\n        })\n            .next(function () { return results; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        assert(!query.isDocumentQuery(), \"Document queries shouldn't go down this path\");\n        var queryPath = query.path;\n        var immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);\n        var encodedQueryPath = indexPrefix[1];\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        var uniqueBatchIDs = new SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            var path = EncodedResourcePath.decode(encodedPath);\n            if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(function () {\n            var results = [];\n            var promises = [];\n            // TODO(rockwood): Implement this using iterate.\n            uniqueBatchIDs.forEach(function (batchID) {\n                var mutationKey = _this.keyForBatchId(batchID);\n                promises.push(mutationsStore(transaction)\n                    .get(mutationKey)\n                    .next(function (mutation) {\n                    if (mutation === null) {\n                        fail('Dangling document-mutation reference found, ' +\n                            'which points to ' +\n                            mutationKey);\n                    }\n                    results.push(_this.serializer.fromDbMutationBatch(mutation));\n                }));\n            });\n            return PersistencePromise.waitFor(promises).next(function () { return results; });\n        });\n    };\n    IndexedDbMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var txn = mutationsStore(transaction);\n        var indexTxn = documentMutationsStore(transaction);\n        var promises = [];\n        var _loop_1 = function (batch) {\n            var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));\n            var numDeleted = 0;\n            var removePromise = txn.iterate({ range: range }, function (key, value, control) {\n                numDeleted++;\n                return control.delete();\n            });\n            promises.push(removePromise.next(function () {\n                assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' +\n                    batch.batchId);\n            }));\n            for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {\n                var mutation = _a[_i];\n                var indexKey = DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);\n                promises.push(indexTxn.delete(indexKey));\n                if (this_1.garbageCollector !== null) {\n                    this_1.garbageCollector.addPotentialGarbageKey(mutation.key);\n                }\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            _loop_1(batch);\n        }\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        var _this = this;\n        return this.checkEmpty(txn).next(function (empty) {\n            if (!empty) {\n                return PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));\n            var danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, function (key, _, control) {\n                var userID = key[0];\n                if (userID !== _this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    var path = EncodedResourcePath.decode(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(function () {\n                assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' +\n                    danglingMutationReferences.map(function (p) { return p.canonicalString(); }));\n            });\n        });\n    };\n    IndexedDbMutationQueue.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {\n        var _this = this;\n        var indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);\n        var encodedPath = indexKey[1];\n        var startRange = IDBKeyRange.lowerBound(indexKey);\n        var containsKey = false;\n        return documentMutationsStore(txn)\n            .iterate({ range: startRange, keysOnly: true }, function (key, _, control) {\n            var userID = key[0], keyPath = key[1], batchID = key[2];\n            if (userID === _this.userId && keyPath === encodedPath) {\n                containsKey = true;\n            }\n            control.done();\n        })\n            .next(function () { return containsKey; });\n    };\n    /**\n     * Creates a [userId, batchId] key for use with the DbMutationQueue object\n     * store.\n     */\n    IndexedDbMutationQueue.prototype.keyForBatchId = function (batchId) {\n        return [this.userId, batchId];\n    };\n    return IndexedDbMutationQueue;\n}());\nexport { IndexedDbMutationQueue };\nfunction validateStreamToken(token) {\n    assert(typeof token === 'string', 'Persisting non-string stream token not supported.');\n    return token;\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatch.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, DbDocumentMutation.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueue.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore(txn, store) {\n    if (txn instanceof SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n\n"]}