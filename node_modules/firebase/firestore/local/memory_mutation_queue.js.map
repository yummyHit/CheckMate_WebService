{"version":3,"sources":["src/firestore/local/memory_mutation_queue.ts","firestore/local/memory_mutation_queue.js"],"names":["MemoryMutationQueue","mutationQueue","nextBatchId","highestAcknowledgedBatchId","lastStreamToken","garbageCollector","batchesByDocumentKey","compareByKey","prototype","start","transaction","length","resolve","checkEmpty","getNextBatchId","getHighestAcknowledgedBatchId","acknowledgeBatch","batch","streamToken","batchId","batchIndex","indexOfExistingBatchId","check","isTombstone","getLastStreamToken","setLastStreamToken","addMutationBatch","localWriteTime","mutations","prior","push","_i","mutations_1","mutation","add","key","lookupMutationBatch","findMutationBatch","getNextMutationBatchAfterBatchId","size","Math","max","rawIndex","indexOfBatchId","index","getAllMutationBatches","getAllLiveMutationBatchesBeforeIndex","getAllMutationBatchesThroughBatchId","count","endIndex","getAllMutationBatchesAffectingDocumentKey","documentKey","_this","end","Number","POSITIVE_INFINITY","result","forEachInRange","ref","equals","targetOrBatchId","getAllMutationBatchesAffectingQuery","query","prefix","path","immediateChildrenPathLength","startPath","isDocumentKey","child","uniqueBatchIDs","forEachWhile","rowKeyPath","isPrefixOf","forEach","removeMutationBatches","batches","batchCount","firstBatchId","queueCount","startIndex","queueIndex","length_1","splice","i","toTombstone","references","batches_1","_a","_b","addPotentialGarbageKey","delete","setGarbageCollector","containsKey","txn","firstRef","firstAfterOrEqual","performConsistencyCheck","isEmpty","action"],"mappings":"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","file":"memory_mutation_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { DocReference } from './reference_set';\n\nexport class MemoryMutationQueue implements MutationQueue {\n  /**\n   * The set of all mutations that have been sent but not yet been applied to\n   * the backend.\n   */\n  private mutationQueue: MutationBatch[] = [];\n\n  /** Next value to use when assigning sequential IDs to each mutation batch. */\n  private nextBatchId: BatchId = 1;\n\n  /** The highest acknowledged mutation in the queue. */\n  private highestAcknowledgedBatchId: BatchId = BATCHID_UNKNOWN;\n\n  /** The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   */\n  private lastStreamToken: ProtoByteString = emptyByteString();\n\n  /** The garbage collector to notify about potential garbage keys. */\n  private garbageCollector: GarbageCollector | null = null;\n\n  /** An ordered mapping between documents and the mutations batch IDs. */\n  private batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    // NOTE: The queue may be shutdown / started multiple times, since we\n    // maintain the queue for the duration of the app session in case a user\n    // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n    // accommodate tests that expect as much), we reset nextBatchId and\n    // highestAcknowledgedBatchId if the queue is empty.\n    if (this.mutationQueue.length === 0) {\n      this.nextBatchId = 1;\n      this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n    }\n    assert(\n      this.highestAcknowledgedBatchId < this.nextBatchId,\n      'highestAcknowledgedBatchId must be less than the nextBatchId'\n    );\n    return PersistencePromise.resolve();\n  }\n\n  checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean> {\n    return PersistencePromise.resolve(this.mutationQueue.length === 0);\n  }\n\n  getNextBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.nextBatchId);\n  }\n\n  getHighestAcknowledgedBatchId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n  }\n\n  acknowledgeBatch(\n    transaction: PersistenceTransaction,\n    batch: MutationBatch,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    const batchId = batch.batchId;\n    assert(\n      batchId > this.highestAcknowledgedBatchId,\n      'Mutation batchIDs must be acknowledged in order'\n    );\n\n    const batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');\n\n    // Verify that the batch in the queue is the one to be acknowledged.\n    const check = this.mutationQueue[batchIndex];\n    assert(\n      batchId === check.batchId,\n      'Queue ordering failure: expected batch ' +\n        batchId +\n        ', got batch ' +\n        check.batchId\n    );\n    assert(\n      !check.isTombstone(),\n      \"Can't acknowledge a previously removed batch\"\n    );\n\n    this.highestAcknowledgedBatchId = batchId;\n    this.lastStreamToken = streamToken;\n    return PersistencePromise.resolve();\n  }\n\n  getLastStreamToken(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<ProtoByteString> {\n    return PersistencePromise.resolve(this.lastStreamToken);\n  }\n\n  setLastStreamToken(\n    transaction: PersistenceTransaction,\n    streamToken: ProtoByteString\n  ): PersistencePromise<void> {\n    this.lastStreamToken = streamToken;\n    return PersistencePromise.resolve();\n  }\n\n  addMutationBatch(\n    transaction: PersistenceTransaction,\n    localWriteTime: Timestamp,\n    mutations: Mutation[]\n  ): PersistencePromise<MutationBatch> {\n    assert(mutations.length !== 0, 'Mutation batches should not be empty');\n\n    const batchId = this.nextBatchId;\n    this.nextBatchId++;\n\n    if (this.mutationQueue.length > 0) {\n      const prior = this.mutationQueue[this.mutationQueue.length - 1];\n      assert(\n        prior.batchId < batchId,\n        'Mutation batchIDs must be monotonically increasing order'\n      );\n    }\n\n    const batch = new MutationBatch(batchId, localWriteTime, mutations);\n    this.mutationQueue.push(batch);\n\n    // Track references by document key.\n    for (const mutation of mutations) {\n      this.batchesByDocumentKey = this.batchesByDocumentKey.add(\n        new DocReference(mutation.key, batchId)\n      );\n    }\n\n    return PersistencePromise.resolve(batch);\n  }\n\n  lookupMutationBatch(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    return PersistencePromise.resolve(this.findMutationBatch(batchId));\n  }\n\n  getNextMutationBatchAfterBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    const size = this.mutationQueue.length;\n\n    // All batches with batchId <= this.highestAcknowledgedBatchId have been\n    // acknowledged so the first unacknowledged batch after batchID will have a\n    // batchID larger than both of these values.\n    batchId = Math.max(batchId + 1, this.highestAcknowledgedBatchId);\n\n    // The requested batchId may still be out of range so normalize it to the\n    // start of the queue.\n    const rawIndex = this.indexOfBatchId(batchId);\n    let index = rawIndex < 0 ? 0 : rawIndex;\n\n    // Finally return the first non-tombstone batch.\n    for (; index < size; index++) {\n      const batch = this.mutationQueue[index];\n      if (!batch.isTombstone()) {\n        return PersistencePromise.resolve(batch);\n      }\n    }\n    return PersistencePromise.resolve(null);\n  }\n\n  getAllMutationBatches(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<MutationBatch[]> {\n    return PersistencePromise.resolve(\n      this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length)\n    );\n  }\n\n  getAllMutationBatchesThroughBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch[]> {\n    const count = this.mutationQueue.length;\n\n    let endIndex = this.indexOfBatchId(batchId);\n    if (endIndex < 0) {\n      endIndex = 0;\n    } else if (endIndex >= count) {\n      endIndex = count;\n    } else {\n      // The endIndex is in the queue so increment to pull everything in the\n      // queue including it.\n      endIndex++;\n    }\n\n    return PersistencePromise.resolve(\n      this.getAllLiveMutationBatchesBeforeIndex(endIndex)\n    );\n  }\n\n  getAllMutationBatchesAffectingDocumentKey(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MutationBatch[]> {\n    const start = new DocReference(documentKey, 0);\n    const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n    const result: MutationBatch[] = [];\n    this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n      assert(\n        documentKey.equals(ref.key),\n        \"Should only iterate over a single key's batches\"\n      );\n      const batch = this.findMutationBatch(ref.targetOrBatchId);\n      assert(\n        batch !== null,\n        'Batches in the index must exist in the main table'\n      );\n      result.push(batch!);\n    });\n\n    return PersistencePromise.resolve(result);\n  }\n\n  getAllMutationBatchesAffectingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<MutationBatch[]> {\n    // Use the query path as a prefix for testing if a document matches the\n    // query.\n    const prefix = query.path;\n    const immediateChildrenPathLength = prefix.length + 1;\n\n    // Construct a document reference for actually scanning the index. Unlike\n    // the prefix the document key in this reference must have an even number of\n    // segments. The empty segment can be used a suffix of the query path\n    // because it precedes all other segments in an ordered traversal.\n    let startPath = prefix;\n    if (!DocumentKey.isDocumentKey(startPath)) {\n      startPath = startPath.child('');\n    }\n\n    const start = new DocReference(new DocumentKey(startPath), 0);\n\n    // Find unique batchIDs referenced by all documents potentially matching the\n    // query.\n    let uniqueBatchIDs = new SortedSet<number>(primitiveComparator);\n\n    this.batchesByDocumentKey.forEachWhile(ref => {\n      const rowKeyPath = ref.key.path;\n      if (!prefix.isPrefixOf(rowKeyPath)) {\n        return false;\n      } else {\n        // Rows with document keys more than one segment longer than the query\n        // path can't be matches. For example, a query on 'rooms' can't match\n        // the document /rooms/abc/messages/xyx.\n        // TODO(mcg): we'll need a different scanner when we implement\n        // ancestor queries.\n        if (rowKeyPath.length === immediateChildrenPathLength) {\n          uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n        }\n        return true;\n      }\n    }, start);\n\n    // Construct an array of matching batches, sorted by batchID to ensure that\n    // multiple mutations affecting the same document key are applied in order.\n    const result: MutationBatch[] = [];\n    uniqueBatchIDs.forEach(batchId => {\n      const batch = this.findMutationBatch(batchId);\n      if (batch !== null) {\n        result.push(batch);\n      }\n    });\n    return PersistencePromise.resolve(result);\n  }\n\n  removeMutationBatches(\n    transaction: PersistenceTransaction,\n    batches: MutationBatch[]\n  ): PersistencePromise<void> {\n    const batchCount = batches.length;\n    assert(batchCount > 0, 'Should not remove mutations when none exist.');\n\n    const firstBatchId = batches[0].batchId;\n    const queueCount = this.mutationQueue.length;\n\n    // Find the position of the first batch for removal. This need not be the\n    // first entry in the queue.\n    const startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n    assert(\n      this.mutationQueue[startIndex].batchId === firstBatchId,\n      'Removed batches must exist in the queue'\n    );\n\n    // Check that removed batches are contiguous (while excluding tombstones).\n    let batchIndex = 1;\n    let queueIndex = startIndex + 1;\n    while (batchIndex < batchCount && queueIndex < queueCount) {\n      const batch = this.mutationQueue[queueIndex];\n      if (batch.isTombstone()) {\n        queueIndex++;\n        continue;\n      }\n\n      assert(\n        batch.batchId === batches[batchIndex].batchId,\n        'Removed batches must be contiguous in the queue'\n      );\n      batchIndex++;\n      queueIndex++;\n    }\n\n    // Only actually remove batches if removing at the front of the queue.\n    // Previously rejected batches may have left tombstones in the queue, so\n    // expand the removal range to include any tombstones.\n    if (startIndex === 0) {\n      for (; queueIndex < queueCount; queueIndex++) {\n        const batch = this.mutationQueue[queueIndex];\n        if (!batch.isTombstone()) {\n          break;\n        }\n      }\n      const length = queueIndex - startIndex;\n      this.mutationQueue.splice(startIndex, length);\n    } else {\n      // Mark the tombstones\n      for (let i = startIndex; i < queueIndex; i++) {\n        this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n      }\n    }\n\n    let references = this.batchesByDocumentKey;\n    for (const batch of batches) {\n      const batchId = batch.batchId;\n      for (const mutation of batch.mutations) {\n        const key = mutation.key;\n        if (this.garbageCollector !== null) {\n          this.garbageCollector.addPotentialGarbageKey(key);\n        }\n\n        const ref = new DocReference(key, batchId);\n        references = references.delete(ref);\n      }\n    }\n    this.batchesByDocumentKey = references;\n    return PersistencePromise.resolve();\n  }\n\n  setGarbageCollector(garbageCollector: GarbageCollector | null): void {\n    this.garbageCollector = garbageCollector;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const ref = new DocReference(key, 0);\n    const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n    return PersistencePromise.resolve(key.equals(firstRef && firstRef.key));\n  }\n\n  performConsistencyCheck(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    if (this.mutationQueue.length === 0) {\n      assert(\n        this.batchesByDocumentKey.isEmpty(),\n        'Document leak -- detected dangling mutation references when queue is empty.'\n      );\n    }\n    return PersistencePromise.resolve();\n  }\n\n  /**\n   * A private helper that collects all the mutations batches in the queue up to\n   * but not including the given endIndex. All tombstones in the queue are\n   * excluded.\n   */\n  private getAllLiveMutationBatchesBeforeIndex(\n    endIndex: number\n  ): MutationBatch[] {\n    const result: MutationBatch[] = [];\n\n    for (let i = 0; i < endIndex; i++) {\n      const batch = this.mutationQueue[i];\n      if (!batch.isTombstone()) {\n        result.push(batch);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Finds the index of the given batchId in the mutation queue and asserts that\n   * the resulting index is within the bounds of the queue.\n   *\n   * @param batchId The batchId to search for\n   * @param action A description of what the caller is doing, phrased in passive\n   * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n   */\n  private indexOfExistingBatchId(batchId: BatchId, action: string): number {\n    const index = this.indexOfBatchId(batchId);\n    assert(\n      index >= 0 && index < this.mutationQueue.length,\n      'Batches must exist to be ' + action\n    );\n    return index;\n  }\n\n  /**\n   * Finds the index of the given batchId in the mutation queue. This operation\n   * is O(1).\n   *\n   * @return The computed index of the batch with the given batchId, based on\n   * the state of the queue. Note this index can be negative if the requested\n   * batchId has already been remvoed from the queue or past the end of the\n   * queue if the batchId is larger than the last added batch.\n   */\n  private indexOfBatchId(batchId: BatchId): number {\n    if (this.mutationQueue.length === 0) {\n      // As an index this is past the end of the queue\n      return 0;\n    }\n\n    // Examine the front of the queue to figure out the difference between the\n    // batchId and indexes in the array. Note that since the queue is ordered\n    // by batchId, if the first batch has a larger batchId then the requested\n    // batchId doesn't exist in the queue.\n    const firstBatchId = this.mutationQueue[0].batchId;\n    return batchId - firstBatchId;\n  }\n\n  /**\n   * A version of lookupMutationBatch that doesn't return a promise, this makes\n   * other functions that uses this code easier to read and more efficent.\n   */\n  private findMutationBatch(batchId: BatchId): MutationBatch | null {\n    const index = this.indexOfBatchId(batchId);\n    if (index < 0 || index >= this.mutationQueue.length) {\n      return null;\n    }\n\n    const batch = this.mutationQueue[index];\n    assert(batch.batchId === batchId, 'If found batch must match');\n    return batch.isTombstone() ? null : batch;\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DocumentKey } from '../model/document_key';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PersistencePromise } from './persistence_promise';\nimport { DocReference } from './reference_set';\nvar MemoryMutationQueue = /** @class */ (function () {\n    function MemoryMutationQueue() {\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** The highest acknowledged mutation in the queue. */\n        this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        /** The last received stream token from the server, used to acknowledge which\n         * responses the client has processed. Stream tokens are opaque checkpoint\n         * markers whose only real value is their inclusion in the next request.\n         */\n        this.lastStreamToken = emptyByteString();\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n    }\n    MemoryMutationQueue.prototype.start = function (transaction) {\n        // NOTE: The queue may be shutdown / started multiple times, since we\n        // maintain the queue for the duration of the app session in case a user\n        // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n        // accommodate tests that expect as much), we reset nextBatchId and\n        // highestAcknowledgedBatchId if the queue is empty.\n        if (this.mutationQueue.length === 0) {\n            this.nextBatchId = 1;\n            this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        }\n        assert(this.highestAcknowledgedBatchId < this.nextBatchId, 'highestAcknowledgedBatchId must be less than the nextBatchId');\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.checkEmpty = function (transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\n    };\n    MemoryMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.nextBatchId);\n    };\n    MemoryMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n    };\n    MemoryMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.highestAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        var batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');\n        // Verify that the batch in the queue is the one to be acknowledged.\n        var check = this.mutationQueue[batchIndex];\n        assert(batchId === check.batchId, 'Queue ordering failure: expected batch ' +\n            batchId +\n            ', got batch ' +\n            check.batchId);\n        assert(!check.isTombstone(), \"Can't acknowledge a previously removed batch\");\n        this.highestAcknowledgedBatchId = batchId;\n        this.lastStreamToken = streamToken;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return PersistencePromise.resolve(this.lastStreamToken);\n    };\n    MemoryMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.lastStreamToken = streamToken;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        assert(mutations.length !== 0, 'Mutation batches should not be empty');\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            var prior = this.mutationQueue[this.mutationQueue.length - 1];\n            assert(prior.batchId < batchId, 'Mutation batchIDs must be monotonically increasing order');\n        }\n        var batch = new MutationBatch(batchId, localWriteTime, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key.\n        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n            var mutation = mutations_1[_i];\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\n        }\n        return PersistencePromise.resolve(batch);\n    };\n    MemoryMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\n    };\n    MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var size = this.mutationQueue.length;\n        // All batches with batchId <= this.highestAcknowledgedBatchId have been\n        // acknowledged so the first unacknowledged batch after batchID will have a\n        // batchID larger than both of these values.\n        batchId = Math.max(batchId + 1, this.highestAcknowledgedBatchId);\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        var rawIndex = this.indexOfBatchId(batchId);\n        var index = rawIndex < 0 ? 0 : rawIndex;\n        // Finally return the first non-tombstone batch.\n        for (; index < size; index++) {\n            var batch = this.mutationQueue[index];\n            if (!batch.isTombstone()) {\n                return PersistencePromise.resolve(batch);\n            }\n        }\n        return PersistencePromise.resolve(null);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var count = this.mutationQueue.length;\n        var endIndex = this.indexOfBatchId(batchId);\n        if (endIndex < 0) {\n            endIndex = 0;\n        }\n        else if (endIndex >= count) {\n            endIndex = count;\n        }\n        else {\n            // The endIndex is in the queue so increment to pull everything in the\n            // queue including it.\n            endIndex++;\n        }\n        return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(endIndex));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        var start = new DocReference(documentKey, 0);\n        var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n        var result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {\n            assert(documentKey.equals(ref.key), \"Should only iterate over a single key's batches\");\n            var batch = _this.findMutationBatch(ref.targetOrBatchId);\n            assert(batch !== null, 'Batches in the index must exist in the main table');\n            result.push(batch);\n        });\n        return PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        var prefix = query.path;\n        var immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        var startPath = prefix;\n        if (!DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        var start = new DocReference(new DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        var uniqueBatchIDs = new SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(function (ref) {\n            var rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        var result = [];\n        uniqueBatchIDs.forEach(function (batchId) {\n            var batch = _this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var batchCount = batches.length;\n        assert(batchCount > 0, 'Should not remove mutations when none exist.');\n        var firstBatchId = batches[0].batchId;\n        var queueCount = this.mutationQueue.length;\n        // Find the position of the first batch for removal. This need not be the\n        // first entry in the queue.\n        var startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n        assert(this.mutationQueue[startIndex].batchId === firstBatchId, 'Removed batches must exist in the queue');\n        // Check that removed batches are contiguous (while excluding tombstones).\n        var batchIndex = 1;\n        var queueIndex = startIndex + 1;\n        while (batchIndex < batchCount && queueIndex < queueCount) {\n            var batch = this.mutationQueue[queueIndex];\n            if (batch.isTombstone()) {\n                queueIndex++;\n                continue;\n            }\n            assert(batch.batchId === batches[batchIndex].batchId, 'Removed batches must be contiguous in the queue');\n            batchIndex++;\n            queueIndex++;\n        }\n        // Only actually remove batches if removing at the front of the queue.\n        // Previously rejected batches may have left tombstones in the queue, so\n        // expand the removal range to include any tombstones.\n        if (startIndex === 0) {\n            for (; queueIndex < queueCount; queueIndex++) {\n                var batch = this.mutationQueue[queueIndex];\n                if (!batch.isTombstone()) {\n                    break;\n                }\n            }\n            var length_1 = queueIndex - startIndex;\n            this.mutationQueue.splice(startIndex, length_1);\n        }\n        else {\n            // Mark the tombstones\n            for (var i = startIndex; i < queueIndex; i++) {\n                this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n            }\n        }\n        var references = this.batchesByDocumentKey;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            var batchId = batch.batchId;\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                if (this.garbageCollector !== null) {\n                    this.garbageCollector.addPotentialGarbageKey(key);\n                }\n                var ref = new DocReference(key, batchId);\n                references = references.delete(ref);\n            }\n        }\n        this.batchesByDocumentKey = references;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    MemoryMutationQueue.prototype.containsKey = function (txn, key) {\n        var ref = new DocReference(key, 0);\n        var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(key.equals(firstRef && firstRef.key));\n    };\n    MemoryMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        if (this.mutationQueue.length === 0) {\n            assert(this.batchesByDocumentKey.isEmpty(), 'Document leak -- detected dangling mutation references when queue is empty.');\n        }\n        return PersistencePromise.resolve();\n    };\n    /**\n     * A private helper that collects all the mutations batches in the queue up to\n     * but not including the given endIndex. All tombstones in the queue are\n     * excluded.\n     */\n    MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function (endIndex) {\n        var result = [];\n        for (var i = 0; i < endIndex; i++) {\n            var batch = this.mutationQueue[i];\n            if (!batch.isTombstone()) {\n                result.push(batch);\n            }\n        }\n        return result;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId The batchId to search for\n     * @param action A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    MemoryMutationQueue.prototype.indexOfExistingBatchId = function (batchId, action) {\n        var index = this.indexOfBatchId(batchId);\n        assert(index >= 0 && index < this.mutationQueue.length, 'Batches must exist to be ' + action);\n        return index;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @return The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been remvoed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    MemoryMutationQueue.prototype.indexOfBatchId = function (batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        var firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    };\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficent.\n     */\n    MemoryMutationQueue.prototype.findMutationBatch = function (batchId) {\n        var index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        var batch = this.mutationQueue[index];\n        assert(batch.batchId === batchId, 'If found batch must match');\n        return batch.isTombstone() ? null : batch;\n    };\n    return MemoryMutationQueue;\n}());\nexport { MemoryMutationQueue };\n\n\n"]}