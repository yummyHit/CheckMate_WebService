{"version":3,"sources":["src/firestore/local/eager_garbage_collector.ts","firestore/local/eager_garbage_collector.js"],"names":["EagerGarbageCollector","isEager","sources","potentialGarbage","prototype","addGarbageSource","garbageSource","push","setGarbageCollector","removeGarbageSource","splice","indexOf","addPotentialGarbageKey","key","add","collectGarbage","txn","_this","promises","garbageKeys","forEach","hasRefsPromise","documentHasAnyReferences","next","hasRefs","resolve","waitFor","initial","map","source","containsKey","reduce","promise","nextPromise","result"],"mappings":";;;;;;;AAgBA;;AAOA;;AAEA;;;;;;;;;AAzBA;;;;;;;;;;;;;;;AAkCA,IAAAA,wBAAA,aAAA,YAAA;AAAA,aAAAA,qBAAA,GAAA;AACW,aAAAC,OAAA,GAAU,IAAV;AAET;;;AAGQ,aAAAC,OAAA,GAA2B,EAA3B;AAER;;;;AAIQ,aAAAC,gBAAA,GAAmC,kCAAnC;AAyDT;AAvDCH,0BAAAI,SAAA,CAAAC,gBAAA,GAAA,UAAiBC,aAAjB,EAA6C;AAC3C,aAAKJ,OAAL,CAAaK,IAAb,CAAkBD,aAAlB;AACAA,sBAAcE,mBAAd,CAAkC,IAAlC;AACD,KAHD;AAKAR,0BAAAI,SAAA,CAAAK,mBAAA,GAAA,UAAoBH,aAApB,EAAgD;AAC9C,aAAKJ,OAAL,CAAaQ,MAAb,CAAoB,KAAKR,OAAL,CAAaS,OAAb,CAAqBL,aAArB,CAApB,EAAyD,CAAzD;AACAA,sBAAcE,mBAAd,CAAkC,IAAlC;AACD,KAHD;AAKAR,0BAAAI,SAAA,CAAAQ,sBAAA,GAAA,UAAuBC,GAAvB,EAAuC;AACrC,aAAKV,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBW,GAAtB,CAA0BD,GAA1B,CAAxB;AACD,KAFD;AAIAb,0BAAAI,SAAA,CAAAW,cAAA,GAAA,UACEC,GADF,EACoC;AADpC,YAAAC,QAAA,IAAA;AAGE,YAAMC,WAA4C,EAAlD;AACA,YAAIC,cAAc,kCAAlB;AAEA,aAAKhB,gBAAL,CAAsBiB,OAAtB,CAA8B,UAAAP,GAAA,EAAG;AAC/B,gBAAMQ,iBAAiBJ,MAAKK,wBAAL,CAA8BN,GAA9B,EAAmCH,GAAnC,CAAvB;AACAK,qBAASX,IAAT,CACEc,eAAeE,IAAf,CAAoB,UAAAC,OAAA,EAAO;AACzB;AACA,oBAAI,CAACA,OAAL,EAAc;AACZL,kCAAcA,YAAYL,GAAZ,CAAgBD,GAAhB,CAAd;AACD;AACD,uBAAO,wCAAmBY,OAAnB,EAAP;AACD,aAND,CADF;AASD,SAXD;AAaA;AACA,aAAKtB,gBAAL,GAAwB,kCAAxB;AACA,eAAO,wCAAmBuB,OAAnB,CAA2BR,QAA3B,EAAqCK,IAArC,CAA0C,YAAA;AAAM,mBAAAJ,WAAA;AAAW,SAA3D,CAAP;AACD,KAtBD;AAwBAnB,0BAAAI,SAAA,CAAAkB,wBAAA,GAAA,UACEN,GADF,EAEEH,GAFF,EAEkB;AAEhB,YAAMc,UAAU,wCAAmBF,OAAnB,CAA2B,KAA3B,CAAhB;AACA,eAAO,KAAKvB,OAAL,CACJ0B,GADI,CACA,UAAAC,MAAA,EAAM;AAAI,mBAAA,YAAA;AAAM,uBAAAA,OAAOC,WAAP,CAAmBd,GAAnB,EAAwBH,GAAxB,CAAA;AAA4B,aAAlC;AAAkC,SAD5C,EAEJkB,MAFI,CAEgC,UAACC,OAAD,EAAUC,WAAV,EAAqB;AACxD,mBAAOD,QAAQT,IAAR,CAAa,UAAAW,MAAA,EAAM;AACxB,oBAAIA,MAAJ,EAAY;AACV,2BAAO,wCAAmBT,OAAnB,CAA2B,IAA3B,CAAP;AACD,iBAFD,MAEO;AACL,2BAAOQ,aAAP;AACD;AACF,aANM,CAAP;AAOD,SAVI,EAUFN,OAVE,CAAP;AAWD,KAhBD;AAiBF,WAAA3B,qBAAA;AArEA,CAAA,EAAA;QCmDSA,qB,GAAAA,qB","file":"eager_garbage_collector.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DocumentKeySet, documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { GarbageSource } from './garbage_source';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\n\n/**\n * A garbage collector implementation that eagerly collects documents as soon as\n * they're no longer referenced in any of its registered GarbageSources.\n *\n * This implementation keeps track of a set of keys that are potentially garbage\n * without keeping an exact reference count. During collectGarbage, the\n * collector verifies that all potential garbage keys actually have no\n * references by consulting its list of garbage sources.\n */\nexport class EagerGarbageCollector implements GarbageCollector {\n  readonly isEager = true;\n\n  /**\n   * The garbage collectible sources to double-check during garbage collection.\n   */\n  private sources: GarbageSource[] = [];\n\n  /**\n   * A set of potentially garbage keys.\n   * PORTING NOTE: This would be a mutable set if Javascript had one.\n   */\n  private potentialGarbage: DocumentKeySet = documentKeySet();\n\n  addGarbageSource(garbageSource: GarbageSource): void {\n    this.sources.push(garbageSource);\n    garbageSource.setGarbageCollector(this);\n  }\n\n  removeGarbageSource(garbageSource: GarbageSource): void {\n    this.sources.splice(this.sources.indexOf(garbageSource), 1);\n    garbageSource.setGarbageCollector(null);\n  }\n\n  addPotentialGarbageKey(key: DocumentKey): void {\n    this.potentialGarbage = this.potentialGarbage.add(key);\n  }\n\n  collectGarbage(\n    txn: PersistenceTransaction | null\n  ): PersistencePromise<DocumentKeySet> {\n    const promises: Array<PersistencePromise<void>> = [];\n    let garbageKeys = documentKeySet();\n\n    this.potentialGarbage.forEach(key => {\n      const hasRefsPromise = this.documentHasAnyReferences(txn, key);\n      promises.push(\n        hasRefsPromise.next(hasRefs => {\n          // If there are no references, get the key.\n          if (!hasRefs) {\n            garbageKeys = garbageKeys.add(key);\n          }\n          return PersistencePromise.resolve();\n        })\n      );\n    });\n\n    // Clear locally retained potential keys and returned confirmed garbage.\n    this.potentialGarbage = documentKeySet();\n    return PersistencePromise.waitFor(promises).next(() => garbageKeys);\n  }\n\n  documentHasAnyReferences(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const initial = PersistencePromise.resolve(false);\n    return this.sources\n      .map(source => () => source.containsKey(txn, key))\n      .reduce<PersistencePromise<boolean>>((promise, nextPromise) => {\n        return promise.next(result => {\n          if (result) {\n            return PersistencePromise.resolve(true);\n          } else {\n            return nextPromise();\n          }\n        });\n      }, initial);\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A garbage collector implementation that eagerly collects documents as soon as\n * they're no longer referenced in any of its registered GarbageSources.\n *\n * This implementation keeps track of a set of keys that are potentially garbage\n * without keeping an exact reference count. During collectGarbage, the\n * collector verifies that all potential garbage keys actually have no\n * references by consulting its list of garbage sources.\n */\nvar EagerGarbageCollector = /** @class */ (function () {\n    function EagerGarbageCollector() {\n        this.isEager = true;\n        /**\n         * The garbage collectible sources to double-check during garbage collection.\n         */\n        this.sources = [];\n        /**\n         * A set of potentially garbage keys.\n         * PORTING NOTE: This would be a mutable set if Javascript had one.\n         */\n        this.potentialGarbage = documentKeySet();\n    }\n    EagerGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        this.sources.push(garbageSource);\n        garbageSource.setGarbageCollector(this);\n    };\n    EagerGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        this.sources.splice(this.sources.indexOf(garbageSource), 1);\n        garbageSource.setGarbageCollector(null);\n    };\n    EagerGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        this.potentialGarbage = this.potentialGarbage.add(key);\n    };\n    EagerGarbageCollector.prototype.collectGarbage = function (txn) {\n        var _this = this;\n        var promises = [];\n        var garbageKeys = documentKeySet();\n        this.potentialGarbage.forEach(function (key) {\n            var hasRefsPromise = _this.documentHasAnyReferences(txn, key);\n            promises.push(hasRefsPromise.next(function (hasRefs) {\n                // If there are no references, get the key.\n                if (!hasRefs) {\n                    garbageKeys = garbageKeys.add(key);\n                }\n                return PersistencePromise.resolve();\n            }));\n        });\n        // Clear locally retained potential keys and returned confirmed garbage.\n        this.potentialGarbage = documentKeySet();\n        return PersistencePromise.waitFor(promises).next(function () { return garbageKeys; });\n    };\n    EagerGarbageCollector.prototype.documentHasAnyReferences = function (txn, key) {\n        var initial = PersistencePromise.resolve(false);\n        return this.sources\n            .map(function (source) { return function () { return source.containsKey(txn, key); }; })\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (result) {\n                    return PersistencePromise.resolve(true);\n                }\n                else {\n                    return nextPromise();\n                }\n            });\n        }, initial);\n    };\n    return EagerGarbageCollector;\n}());\nexport { EagerGarbageCollector };\n\n\n"]}