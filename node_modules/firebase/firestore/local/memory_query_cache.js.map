{"version":3,"sources":["src/firestore/local/memory_query_cache.ts","firestore/local/memory_query_cache.js"],"names":["MemoryQueryCache","queries","q","canonicalId","lastRemoteSnapshotVersion","MIN","highestTargetId","references","prototype","start","transaction","resolve","getLastRemoteSnapshotVersion","getHighestTargetId","setLastRemoteSnapshotVersion","snapshotVersion","addQueryData","queryData","set","query","targetId","removeQueryData","delete","removeReferencesForId","getQueryData","get","addMatchingKeys","txn","keys","addReferences","removeMatchingKeys","removeReferences","removeMatchingKeysForTargetId","getMatchingKeysForTargetId","matchingKeys","referencesForId","setGarbageCollector","gc","containsKey","key"],"mappings":"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","file":"memory_query_cache.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetId } from '../core/types';\nimport { DocumentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { ObjectMap } from '../util/obj_map';\nimport { SortedSet } from '../util/sorted_set';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { QueryData } from './query_data';\nimport { ReferenceSet } from './reference_set';\n\nexport class MemoryQueryCache implements QueryCache {\n  /**\n   * Maps a query to the data about that query\n   */\n  private queries = new ObjectMap<Query, QueryData>(q => q.canonicalId());\n\n  /** The last received snapshot version. */\n  private lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n  /** The highest numbered target ID encountered. */\n  private highestTargetId: TargetId = 0;\n  /**\n   * A ordered bidirectional mapping between documents and the remote target\n   * IDs.\n   */\n  private references = new ReferenceSet();\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    // Nothing to do.\n    return PersistencePromise.resolve();\n  }\n\n  getLastRemoteSnapshotVersion(): SnapshotVersion {\n    return this.lastRemoteSnapshotVersion;\n  }\n\n  getHighestTargetId(): TargetId {\n    return this.highestTargetId;\n  }\n\n  setLastRemoteSnapshotVersion(\n    transaction: PersistenceTransaction,\n    snapshotVersion: SnapshotVersion\n  ): PersistencePromise<void> {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    return PersistencePromise.resolve();\n  }\n\n  addQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    this.queries.set(queryData.query, queryData);\n    const targetId = queryData.targetId;\n    if (targetId > this.highestTargetId) {\n      this.highestTargetId = targetId;\n    }\n    return PersistencePromise.resolve();\n  }\n\n  removeQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    this.queries.delete(queryData.query);\n    this.references.removeReferencesForId(queryData.targetId);\n    return PersistencePromise.resolve();\n  }\n\n  getQueryData(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<QueryData | null> {\n    const queryData = this.queries.get(query) || null;\n    return PersistencePromise.resolve(queryData);\n  }\n\n  addMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.addReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  }\n\n  removeMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.removeReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  }\n\n  removeMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.removeReferencesForId(targetId);\n    return PersistencePromise.resolve();\n  }\n\n  getMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<DocumentKeySet> {\n    const matchingKeys = this.references.referencesForId(targetId);\n    return PersistencePromise.resolve(matchingKeys);\n  }\n\n  setGarbageCollector(gc: GarbageCollector | null): void {\n    this.references.setGarbageCollector(gc);\n  }\n\n  containsKey(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    return this.references.containsKey(txn, key);\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ObjectMap } from '../util/obj_map';\nimport { PersistencePromise } from './persistence_promise';\nimport { ReferenceSet } from './reference_set';\nvar MemoryQueryCache = /** @class */ (function () {\n    function MemoryQueryCache() {\n        /**\n         * Maps a query to the data about that query\n         */\n        this.queries = new ObjectMap(function (q) { return q.canonicalId(); });\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new ReferenceSet();\n    }\n    MemoryQueryCache.prototype.start = function (transaction) {\n        // Nothing to do.\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    MemoryQueryCache.prototype.getHighestTargetId = function () {\n        return this.highestTargetId;\n    };\n    MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        this.queries.set(queryData.query, queryData);\n        var targetId = queryData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.highestTargetId = targetId;\n        }\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        this.queries.delete(queryData.query);\n        this.references.removeReferencesForId(queryData.targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getQueryData = function (transaction, query) {\n        var queryData = this.queries.get(query) || null;\n        return PersistencePromise.resolve(queryData);\n    };\n    MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var matchingKeys = this.references.referencesForId(targetId);\n        return PersistencePromise.resolve(matchingKeys);\n    };\n    MemoryQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.references.setGarbageCollector(gc);\n    };\n    MemoryQueryCache.prototype.containsKey = function (txn, key) {\n        return this.references.containsKey(txn, key);\n    };\n    return MemoryQueryCache;\n}());\nexport { MemoryQueryCache };\n\n\n"]}