{"version":3,"sources":["src/firestore/local/indexeddb_schema.ts","firestore/local/indexeddb_schema.js"],"names":["createOrUpgradeDb","SCHEMA_VERSION","db","oldVersion","createObjectStore","DbMutationQueue","store","keyPath","DbMutationBatch","targetDocumentsStore","DbTargetDocument","createIndex","documentTargetsIndex","documentTargetsKeyPath","unique","targetStore","DbTarget","queryTargetsIndexName","queryTargetsKeyPath","DbDocumentMutation","DbRemoteDocument","DbOwner","DbTargetGlobal","DbTimestamp","seconds","nanos","ownerId","leaseTimestampMs","userId","lastAcknowledgedBatchId","lastStreamToken","batchId","localWriteTimeMs","mutations","prefixForUser","prefixForPath","path","key","PLACEHOLDER","DbNoDocument","readTime","noDocument","document","targetId","canonicalId","resumeToken","lastListenSequenceNumber","query","highestTargetId","highestListenSequenceNumber","lastRemoteSnapshotVersion","ALL_STORES"],"mappings":"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","file":"indexeddb_schema.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { BatchId } from '../core/types';\nimport { TargetId } from '../core/types';\nimport { ResourcePath } from '../model/path';\nimport { assert } from '../util/assert';\n\nimport { encode, EncodedResourcePath } from './encoded_resource_path';\n\nexport const SCHEMA_VERSION = 1;\n\n/** Performs database creation and (in the future) upgrades between versions. */\nexport function createOrUpgradeDb(db: IDBDatabase, oldVersion: number): void {\n  assert(oldVersion === 0, 'Unexpected upgrade from version ' + oldVersion);\n\n  db.createObjectStore(DbMutationQueue.store, {\n    keyPath: DbMutationQueue.keyPath\n  });\n\n  // TODO(mikelehen): Get rid of \"as any\" if/when TypeScript fixes their\n  // types. https://github.com/Microsoft/TypeScript/issues/14322\n  db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbMutationBatch.store,\n    { keyPath: DbMutationBatch.keyPath as any }\n  );\n\n  const targetDocumentsStore = db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbTargetDocument.store,\n    { keyPath: DbTargetDocument.keyPath as any }\n  );\n  targetDocumentsStore.createIndex(\n    DbTargetDocument.documentTargetsIndex,\n    DbTargetDocument.documentTargetsKeyPath,\n    { unique: true }\n  );\n\n  const targetStore = db.createObjectStore(DbTarget.store, {\n    keyPath: DbTarget.keyPath\n  });\n  // NOTE: This is unique only because the TargetId is the suffix.\n  targetStore.createIndex(\n    DbTarget.queryTargetsIndexName,\n    DbTarget.queryTargetsKeyPath,\n    { unique: true }\n  );\n\n  // NOTE: keys for these stores are specified explicitly rather than using a\n  // keyPath.\n  db.createObjectStore(DbDocumentMutation.store);\n  db.createObjectStore(DbRemoteDocument.store);\n  db.createObjectStore(DbOwner.store);\n  db.createObjectStore(DbTargetGlobal.store);\n}\n\n/**\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\n */\nexport class DbTimestamp {\n  constructor(public seconds: number, public nanos: number) {}\n}\n\n// The key for the singleton object in the 'owner' store is 'owner'.\nexport type DbOwnerKey = 'owner';\n\n/**\n * A singleton object to be stored in the 'owner' store in IndexedDb.\n *\n * A given database can be owned by a single tab at a given time. That tab\n * must validate that it is still the owner before every write operation and\n * should regularly write an updated timestamp to prevent other tabs from\n * \"stealing\" ownership of the db.\n */\nexport class DbOwner {\n  /** Name of the IndexedDb object store. */\n  static store = 'owner';\n\n  constructor(public ownerId: string, public leaseTimestampMs: number) {}\n}\n\n/** Object keys in the 'mutationQueues' store are userId strings. */\nexport type DbMutationQueueKey = string;\n\n/**\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\n *\n * Each user gets a single queue of MutationBatches to apply to the server.\n * DbMutationQueue tracks the metadata about the queue.\n */\nexport class DbMutationQueue {\n  /** Name of the IndexedDb object store.  */\n  static store = 'mutationQueues';\n\n  /** Keys are automatically assigned via the userId property. */\n  static keyPath = 'userId';\n\n  constructor(\n    /**\n       * The normalized user ID to which this queue belongs.\n       */\n    public userId: string,\n    /**\n       * An identifier for the highest numbered batch that has been acknowledged\n       * by the server. All MutationBatches in this queue with batchIds less\n       * than or equal to this value are considered to have been acknowledged by\n       * the server.\n       */\n    public lastAcknowledgedBatchId: number,\n    /**\n       * A stream token that was previously sent by the server.\n       *\n       * See StreamingWriteRequest in datastore.proto for more details about\n       * usage.\n       *\n       * After sending this token, earlier tokens may not be used anymore so\n       * only a single stream token is retained.\n       */\n    public lastStreamToken: string\n  ) {}\n}\n\n/** keys in the 'mutations' object store are [userId, batchId] pairs. */\nexport type DbMutationBatchKey = [string, BatchId];\n\n/**\n * An object to be stored in the 'mutations' store in IndexedDb.\n *\n * Represents a batch of user-level mutations intended to be sent to the server\n * in a single write. Each user-level batch gets a separate DbMutationBatch\n * with a new batchId.\n */\nexport class DbMutationBatch {\n  /** Name of the IndexedDb object store.  */\n  static store = 'mutations';\n\n  /** Keys are automatically assigned via the userId, batchId properties. */\n  static keyPath = ['userId', 'batchId'];\n\n  constructor(\n    /**\n       * The normalized user ID to which this batch belongs.\n       */\n    public userId: string,\n    /**\n       * An identifier for this batch, allocated by the mutation queue in a\n       * monotonically increasing manner.\n       */\n    public batchId: BatchId,\n    /**\n       * The local write time of the batch, stored as milliseconds since the\n       * epoch.\n       */\n    public localWriteTimeMs: number,\n    /**\n       * A list of mutations to apply. All mutations will be applied atomically.\n       *\n       * Mutations are serialized via JsonProtoSerializer.toMutation().\n       */\n    public mutations: api.Write[]\n  ) {}\n}\n\n/**\n * The key for a db document mutation, which is made up of a userID, path, and\n * batchId. Note that the path must be serialized into a form that indexedDB can\n * sort.\n */\nexport type DbDocumentMutationKey = [string, EncodedResourcePath, BatchId];\n\n/**\n * An object to be stored in the 'documentMutations' store in IndexedDb.\n *\n * A manually maintained index of all the mutation batches that affect a given\n * document key. The rows in this table are references based on the contents of\n * DbMutationBatch.mutations.\n */\nexport class DbDocumentMutation {\n  static store = 'documentMutations';\n\n  /**\n   * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n   * over all of a user's document mutations.\n   */\n  static prefixForUser(userId: string): [string] {\n    return [userId];\n  }\n\n  /**\n   * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n   * index to iterate over all at document mutations for a given path or lower.\n   */\n  static prefixForPath(\n    userId: string,\n    path: ResourcePath\n  ): [string, EncodedResourcePath] {\n    return [userId, encode(path)];\n  }\n\n  /**\n   * Creates a full index key of [userId, encodedPath, batchId] for inserting\n   * and deleting into the DbDocumentMutations index.\n   */\n  static key(\n    userId: string,\n    path: ResourcePath,\n    batchId: BatchId\n  ): DbDocumentMutationKey {\n    return [userId, encode(path), batchId];\n  }\n\n  /**\n   * Because we store all the useful information for this store in the key,\n   * there is no useful information to store as the value. The raw (unencoded)\n   * path cannot be stored because IndexedDb doesn't store prototype\n   * information.\n   */\n  static PLACEHOLDER = new DbDocumentMutation();\n\n  private constructor() {}\n}\n\n/**\n * A key in the 'remoteDocuments' object store is a string array containing the\n * segments that make up the path.\n */\nexport type DbRemoteDocumentKey = string[];\n\n/**\n * Represents the known absence of a document at a particular version.\n * Stored in IndexedDb as part of a DbRemoteDocument object.\n */\nexport class DbNoDocument {\n  constructor(public path: string[], public readTime: DbTimestamp) {}\n}\n\n/**\n * An object to be stored in the 'remoteDocuments' store in IndexedDb. It\n * represents either a cached document (if it exists) or a cached \"no-document\"\n * (if it is known to not exist).\n *\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\n * be made more general if necessary.\n */\nexport class DbRemoteDocument {\n  static store = 'remoteDocuments';\n\n  constructor(\n    /**\n       * Set to an instance of a DbNoDocument if it is known that no document\n       * exists.\n       */\n    public noDocument: DbNoDocument | null,\n    /**\n       * Set to an instance of a Document if there's a cached version of the\n       * document.\n       */\n    public document: api.Document | null\n  ) {}\n}\n\n/**\n * A key in the 'targets' object store is a targetId of the query.\n */\nexport type DbTargetKey = TargetId;\n\n/**\n * The persisted type for a query nested with in the 'targets' store in\n * IndexedDb. We use the proto definitions for these two kinds of queries in\n * order to avoid writing extra serialization logic.\n */\nexport type DbQuery = api.QueryTarget | api.DocumentsTarget;\n\n/**\n * An object to be stored in the 'targets' store in IndexedDb.\n *\n * This is based on and should be kept in sync with the proto used in the iOS\n * client.\n *\n * Each query the client listens to against the server is tracked on disk so\n * that the query can be efficiently resumed on restart.\n */\nexport class DbTarget {\n  static store = 'targets';\n\n  /** Keys are automatically assigned via the targetId property. */\n  static keyPath = 'targetId';\n\n  /** The name of the queryTargets index. */\n  static queryTargetsIndexName = 'queryTargetsIndex';\n\n  /**\n   * The index of all canonicalIds to the targets that they match. This is not\n   * a unique mapping because canonicalId does not promise a unique name for all\n   * possible queries, so we append the targetId to make the mapping unique.\n   */\n  static queryTargetsKeyPath = ['canonicalId', 'targetId'];\n\n  constructor(\n    /**\n       * An auto-generated sequential numeric identifier for the query.\n       *\n       * Queries are stored using their canonicalId as the key, but these\n       * canonicalIds can be quite long so we additionally assign a unique\n       * queryId which can be used by referenced data structures (e.g.\n       * indexes) to minimize the on-disk cost.\n       */\n    public targetId: TargetId,\n    /**\n       * The canonical string representing this query. This is not unique.\n       */\n    public canonicalId: string,\n    /**\n       * The last readTime received from the Watch Service for this query.\n       *\n       * This is the same value as TargetChange.read_time in the protos.\n       */\n    public readTime: DbTimestamp,\n    /**\n       * An opaque, server-assigned token that allows watching a query to be\n       * resumed after disconnecting without retransmitting all the data\n       * that matches the query. The resume token essentially identifies a\n       * point in time from which the server should resume sending results.\n       *\n       * This is related to the snapshotVersion in that the resumeToken\n       * effectively also encodes that value, but the resumeToken is opaque\n       * and sometimes encodes additional information.\n       *\n       * A consequence of this is that the resumeToken should be used when\n       * asking the server to reason about where this client is in the watch\n       * stream, but the client should use the snapshotVersion for its own\n       * purposes.\n       *\n       * This is the same value as TargetChange.resume_token in the protos.\n       */\n    public resumeToken: string,\n    /**\n       * A sequence number representing the last time this query was\n       * listened to, used for garbage collection purposes.\n       *\n       * Conventionally this would be a timestamp value, but device-local\n       * clocks are unreliable and they must be able to create new listens\n       * even while disconnected. Instead this should be a monotonically\n       * increasing number that's incremented on each listen call.\n       *\n       * This is different from the queryId since the queryId is an\n       * immutable identifier assigned to the Query on first use while\n       * lastListenSequenceNumber is updated every time the query is\n       * listened to.\n       */\n    public lastListenSequenceNumber: number,\n    /**\n       * The query for this target.\n       *\n       * Because canonical ids are not unique we must store the actual query. We\n       * use the proto to have an object we can persist without having to\n       * duplicate translation logic to and from a `Query` object.\n       */\n    public query: DbQuery\n  ) {}\n}\n\n/**\n * The key for a DbTargetDocument, containing a targetId and an encoded resource\n * path.\n */\nexport type DbTargetDocumentKey = [TargetId, EncodedResourcePath];\n\n/**\n * An object representing an association between a target and a document.\n * Stored in the targetDocument object store to store the documents tracked by a\n * particular target.\n */\nexport class DbTargetDocument {\n  /** Name of the IndexedDb object store.  */\n  static store = 'targetDocuments';\n\n  /** Keys are automatically assigned via the targetId, path properties. */\n  static keyPath = ['targetId', 'path'];\n\n  /** The index name for the reverse index. */\n  static documentTargetsIndex = 'documentTargetsIndex';\n\n  /** We also need to create the reverse index for these properties. */\n  static documentTargetsKeyPath = ['path', 'targetId'];\n\n  constructor(\n    /**\n       * The targetId identifying a target.\n       */\n    public targetId: TargetId,\n    /**\n       * The path to the document, as encoded in the key.\n       */\n    public path: EncodedResourcePath\n  ) {}\n}\n\n/**\n * The type to represent the single allowed key for the DbTargetGlobal store.\n */\nexport type DbTargetGlobalKey = typeof DbTargetGlobal.key;\n\n/**\n * A record of global state tracked across all Targets, tracked separately\n * to avoid the need for extra indexes.\n *\n * This should be kept in-sync with the proto used in the iOS client.\n */\nexport class DbTargetGlobal {\n  /**\n   * The key string used for the single object that exists in the\n   * DbTargetGlobal store.\n   */\n  static key = 'targetGlobalKey';\n  static store = 'targetGlobal';\n\n  constructor(\n    /**\n       * The highest numbered target id across all targets.\n       *\n       * See DbTarget.targetId.\n       */\n    public highestTargetId: TargetId,\n    /**\n       * The highest numbered lastListenSequenceNumber across all targets.\n       *\n       * See DbTarget.lastListenSequenceNumber.\n       */\n    public highestListenSequenceNumber: number,\n    /**\n       * A global snapshot version representing the last consistent snapshot we\n       * received from the backend. This is monotonically increasing and any\n       * snapshots received from the backend prior to this version (e.g. for\n       * targets resumed with a resumeToken) should be suppressed (buffered)\n       * until the backend has caught up to this snapshot version again. This\n       * prevents our cache from ever going backwards in time.\n       */\n    public lastRemoteSnapshotVersion: DbTimestamp\n  ) {}\n}\n\n/**\n * The list of all IndexedDB stored used by the SDK. This is used when creating\n * transactions so that access across all stores is done atomically.\n */\nexport const ALL_STORES = [\n  DbMutationQueue.store,\n  DbMutationBatch.store,\n  DbDocumentMutation.store,\n  DbRemoteDocument.store,\n  DbTarget.store,\n  DbOwner.store,\n  DbTargetGlobal.store,\n  DbTargetDocument.store\n];\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { encode } from './encoded_resource_path';\nexport var SCHEMA_VERSION = 1;\n/** Performs database creation and (in the future) upgrades between versions. */\nexport function createOrUpgradeDb(db, oldVersion) {\n    assert(oldVersion === 0, 'Unexpected upgrade from version ' + oldVersion);\n    db.createObjectStore(DbMutationQueue.store, {\n        keyPath: DbMutationQueue.keyPath\n    });\n    // TODO(mikelehen): Get rid of \"as any\" if/when TypeScript fixes their\n    // types. https://github.com/Microsoft/TypeScript/issues/14322\n    db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbMutationBatch.store, { keyPath: DbMutationBatch.keyPath });\n    var targetDocumentsStore = db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbTargetDocument.store, { keyPath: DbTargetDocument.keyPath });\n    targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });\n    var targetStore = db.createObjectStore(DbTarget.store, {\n        keyPath: DbTarget.keyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });\n    // NOTE: keys for these stores are specified explicitly rather than using a\n    // keyPath.\n    db.createObjectStore(DbDocumentMutation.store);\n    db.createObjectStore(DbRemoteDocument.store);\n    db.createObjectStore(DbOwner.store);\n    db.createObjectStore(DbTargetGlobal.store);\n}\n/**\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\n */\nvar DbTimestamp = /** @class */ (function () {\n    function DbTimestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n    }\n    return DbTimestamp;\n}());\nexport { DbTimestamp };\n/**\n * A singleton object to be stored in the 'owner' store in IndexedDb.\n *\n * A given database can be owned by a single tab at a given time. That tab\n * must validate that it is still the owner before every write operation and\n * should regularly write an updated timestamp to prevent other tabs from\n * \"stealing\" ownership of the db.\n */\nvar DbOwner = /** @class */ (function () {\n    function DbOwner(ownerId, leaseTimestampMs) {\n        this.ownerId = ownerId;\n        this.leaseTimestampMs = leaseTimestampMs;\n    }\n    /** Name of the IndexedDb object store. */\n    DbOwner.store = 'owner';\n    return DbOwner;\n}());\nexport { DbOwner };\n/**\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\n *\n * Each user gets a single queue of MutationBatches to apply to the server.\n * DbMutationQueue tracks the metadata about the queue.\n */\nvar DbMutationQueue = /** @class */ (function () {\n    function DbMutationQueue(\n        /**\n           * The normalized user ID to which this queue belongs.\n           */\n        userId, \n        /**\n           * An identifier for the highest numbered batch that has been acknowledged\n           * by the server. All MutationBatches in this queue with batchIds less\n           * than or equal to this value are considered to have been acknowledged by\n           * the server.\n           */\n        lastAcknowledgedBatchId, \n        /**\n           * A stream token that was previously sent by the server.\n           *\n           * See StreamingWriteRequest in datastore.proto for more details about\n           * usage.\n           *\n           * After sending this token, earlier tokens may not be used anymore so\n           * only a single stream token is retained.\n           */\n        lastStreamToken) {\n        this.userId = userId;\n        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;\n        this.lastStreamToken = lastStreamToken;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationQueue.store = 'mutationQueues';\n    /** Keys are automatically assigned via the userId property. */\n    DbMutationQueue.keyPath = 'userId';\n    return DbMutationQueue;\n}());\nexport { DbMutationQueue };\n/**\n * An object to be stored in the 'mutations' store in IndexedDb.\n *\n * Represents a batch of user-level mutations intended to be sent to the server\n * in a single write. Each user-level batch gets a separate DbMutationBatch\n * with a new batchId.\n */\nvar DbMutationBatch = /** @class */ (function () {\n    function DbMutationBatch(\n        /**\n           * The normalized user ID to which this batch belongs.\n           */\n        userId, \n        /**\n           * An identifier for this batch, allocated by the mutation queue in a\n           * monotonically increasing manner.\n           */\n        batchId, \n        /**\n           * The local write time of the batch, stored as milliseconds since the\n           * epoch.\n           */\n        localWriteTimeMs, \n        /**\n           * A list of mutations to apply. All mutations will be applied atomically.\n           *\n           * Mutations are serialized via JsonProtoSerializer.toMutation().\n           */\n        mutations) {\n        this.userId = userId;\n        this.batchId = batchId;\n        this.localWriteTimeMs = localWriteTimeMs;\n        this.mutations = mutations;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationBatch.store = 'mutations';\n    /** Keys are automatically assigned via the userId, batchId properties. */\n    DbMutationBatch.keyPath = ['userId', 'batchId'];\n    return DbMutationBatch;\n}());\nexport { DbMutationBatch };\n/**\n * An object to be stored in the 'documentMutations' store in IndexedDb.\n *\n * A manually maintained index of all the mutation batches that affect a given\n * document key. The rows in this table are references based on the contents of\n * DbMutationBatch.mutations.\n */\nvar DbDocumentMutation = /** @class */ (function () {\n    function DbDocumentMutation() {\n    }\n    /**\n     * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n     * over all of a user's document mutations.\n     */\n    DbDocumentMutation.prefixForUser = function (userId) {\n        return [userId];\n    };\n    /**\n     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n     * index to iterate over all at document mutations for a given path or lower.\n     */\n    DbDocumentMutation.prefixForPath = function (userId, path) {\n        return [userId, encode(path)];\n    };\n    /**\n     * Creates a full index key of [userId, encodedPath, batchId] for inserting\n     * and deleting into the DbDocumentMutations index.\n     */\n    DbDocumentMutation.key = function (userId, path, batchId) {\n        return [userId, encode(path), batchId];\n    };\n    DbDocumentMutation.store = 'documentMutations';\n    /**\n     * Because we store all the useful information for this store in the key,\n     * there is no useful information to store as the value. The raw (unencoded)\n     * path cannot be stored because IndexedDb doesn't store prototype\n     * information.\n     */\n    DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();\n    return DbDocumentMutation;\n}());\nexport { DbDocumentMutation };\n/**\n * Represents the known absence of a document at a particular version.\n * Stored in IndexedDb as part of a DbRemoteDocument object.\n */\nvar DbNoDocument = /** @class */ (function () {\n    function DbNoDocument(path, readTime) {\n        this.path = path;\n        this.readTime = readTime;\n    }\n    return DbNoDocument;\n}());\nexport { DbNoDocument };\n/**\n * An object to be stored in the 'remoteDocuments' store in IndexedDb. It\n * represents either a cached document (if it exists) or a cached \"no-document\"\n * (if it is known to not exist).\n *\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\n * be made more general if necessary.\n */\nvar DbRemoteDocument = /** @class */ (function () {\n    function DbRemoteDocument(\n        /**\n           * Set to an instance of a DbNoDocument if it is known that no document\n           * exists.\n           */\n        noDocument, \n        /**\n           * Set to an instance of a Document if there's a cached version of the\n           * document.\n           */\n        document) {\n        this.noDocument = noDocument;\n        this.document = document;\n    }\n    DbRemoteDocument.store = 'remoteDocuments';\n    return DbRemoteDocument;\n}());\nexport { DbRemoteDocument };\n/**\n * An object to be stored in the 'targets' store in IndexedDb.\n *\n * This is based on and should be kept in sync with the proto used in the iOS\n * client.\n *\n * Each query the client listens to against the server is tracked on disk so\n * that the query can be efficiently resumed on restart.\n */\nvar DbTarget = /** @class */ (function () {\n    function DbTarget(\n        /**\n           * An auto-generated sequential numeric identifier for the query.\n           *\n           * Queries are stored using their canonicalId as the key, but these\n           * canonicalIds can be quite long so we additionally assign a unique\n           * queryId which can be used by referenced data structures (e.g.\n           * indexes) to minimize the on-disk cost.\n           */\n        targetId, \n        /**\n           * The canonical string representing this query. This is not unique.\n           */\n        canonicalId, \n        /**\n           * The last readTime received from the Watch Service for this query.\n           *\n           * This is the same value as TargetChange.read_time in the protos.\n           */\n        readTime, \n        /**\n           * An opaque, server-assigned token that allows watching a query to be\n           * resumed after disconnecting without retransmitting all the data\n           * that matches the query. The resume token essentially identifies a\n           * point in time from which the server should resume sending results.\n           *\n           * This is related to the snapshotVersion in that the resumeToken\n           * effectively also encodes that value, but the resumeToken is opaque\n           * and sometimes encodes additional information.\n           *\n           * A consequence of this is that the resumeToken should be used when\n           * asking the server to reason about where this client is in the watch\n           * stream, but the client should use the snapshotVersion for its own\n           * purposes.\n           *\n           * This is the same value as TargetChange.resume_token in the protos.\n           */\n        resumeToken, \n        /**\n           * A sequence number representing the last time this query was\n           * listened to, used for garbage collection purposes.\n           *\n           * Conventionally this would be a timestamp value, but device-local\n           * clocks are unreliable and they must be able to create new listens\n           * even while disconnected. Instead this should be a monotonically\n           * increasing number that's incremented on each listen call.\n           *\n           * This is different from the queryId since the queryId is an\n           * immutable identifier assigned to the Query on first use while\n           * lastListenSequenceNumber is updated every time the query is\n           * listened to.\n           */\n        lastListenSequenceNumber, \n        /**\n           * The query for this target.\n           *\n           * Because canonical ids are not unique we must store the actual query. We\n           * use the proto to have an object we can persist without having to\n           * duplicate translation logic to and from a `Query` object.\n           */\n        query) {\n        this.targetId = targetId;\n        this.canonicalId = canonicalId;\n        this.readTime = readTime;\n        this.resumeToken = resumeToken;\n        this.lastListenSequenceNumber = lastListenSequenceNumber;\n        this.query = query;\n    }\n    DbTarget.store = 'targets';\n    /** Keys are automatically assigned via the targetId property. */\n    DbTarget.keyPath = 'targetId';\n    /** The name of the queryTargets index. */\n    DbTarget.queryTargetsIndexName = 'queryTargetsIndex';\n    /**\n     * The index of all canonicalIds to the targets that they match. This is not\n     * a unique mapping because canonicalId does not promise a unique name for all\n     * possible queries, so we append the targetId to make the mapping unique.\n     */\n    DbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];\n    return DbTarget;\n}());\nexport { DbTarget };\n/**\n * An object representing an association between a target and a document.\n * Stored in the targetDocument object store to store the documents tracked by a\n * particular target.\n */\nvar DbTargetDocument = /** @class */ (function () {\n    function DbTargetDocument(\n        /**\n           * The targetId identifying a target.\n           */\n        targetId, \n        /**\n           * The path to the document, as encoded in the key.\n           */\n        path) {\n        this.targetId = targetId;\n        this.path = path;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbTargetDocument.store = 'targetDocuments';\n    /** Keys are automatically assigned via the targetId, path properties. */\n    DbTargetDocument.keyPath = ['targetId', 'path'];\n    /** The index name for the reverse index. */\n    DbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';\n    /** We also need to create the reverse index for these properties. */\n    DbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];\n    return DbTargetDocument;\n}());\nexport { DbTargetDocument };\n/**\n * A record of global state tracked across all Targets, tracked separately\n * to avoid the need for extra indexes.\n *\n * This should be kept in-sync with the proto used in the iOS client.\n */\nvar DbTargetGlobal = /** @class */ (function () {\n    function DbTargetGlobal(\n        /**\n           * The highest numbered target id across all targets.\n           *\n           * See DbTarget.targetId.\n           */\n        highestTargetId, \n        /**\n           * The highest numbered lastListenSequenceNumber across all targets.\n           *\n           * See DbTarget.lastListenSequenceNumber.\n           */\n        highestListenSequenceNumber, \n        /**\n           * A global snapshot version representing the last consistent snapshot we\n           * received from the backend. This is monotonically increasing and any\n           * snapshots received from the backend prior to this version (e.g. for\n           * targets resumed with a resumeToken) should be suppressed (buffered)\n           * until the backend has caught up to this snapshot version again. This\n           * prevents our cache from ever going backwards in time.\n           */\n        lastRemoteSnapshotVersion) {\n        this.highestTargetId = highestTargetId;\n        this.highestListenSequenceNumber = highestListenSequenceNumber;\n        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n    }\n    /**\n     * The key string used for the single object that exists in the\n     * DbTargetGlobal store.\n     */\n    DbTargetGlobal.key = 'targetGlobalKey';\n    DbTargetGlobal.store = 'targetGlobal';\n    return DbTargetGlobal;\n}());\nexport { DbTargetGlobal };\n/**\n * The list of all IndexedDB stored used by the SDK. This is used when creating\n * transactions so that access across all stores is done atomically.\n */\nexport var ALL_STORES = [\n    DbMutationQueue.store,\n    DbMutationBatch.store,\n    DbDocumentMutation.store,\n    DbRemoteDocument.store,\n    DbTarget.store,\n    DbOwner.store,\n    DbTargetGlobal.store,\n    DbTargetDocument.store\n];\n\n\n"]}