{"version":3,"sources":["src/firestore/local/remote_document_change_buffer.ts","firestore/local/remote_document_change_buffer.js"],"names":["RemoteDocumentChangeBuffer","remoteDocumentCache","changes","prototype","addEntry","maybeDocument","assertChanges","insert","key","getEntry","transaction","documentKey","bufferedEntry","get","resolve","apply","_this","promises","forEach","maybeDoc","push","waitFor"],"mappings":";;;;;;;AAgBA;;AAGA;;AAIA;;AAGA;;;;;;;;;;;;AAYA,IAAAA,6BAAA,aAAA,YAAA;AAGE,aAAAA,0BAAA,CAAoBC,mBAApB,EAA4D;AAAxC,aAAAA,mBAAA,GAAAA,mBAAA;AAFZ,aAAAC,OAAA,GAAmC,oCAAnC;AAEwD;AAEhE;AACAF,+BAAAG,SAAA,CAAAC,QAAA,GAAA,UAASC,aAAT,EAAqC;AACnC,YAAMH,UAAU,KAAKI,aAAL,EAAhB;AACA,aAAKJ,OAAL,GAAeA,QAAQK,MAAR,CAAeF,cAAcG,GAA7B,EAAkCH,aAAlC,CAAf;AACD,KAHD;AAKA;AAEA;;;;;;;;;;;AAWAL,+BAAAG,SAAA,CAAAM,QAAA,GAAA,UACEC,WADF,EAEEC,WAFF,EAE0B;AAExB,YAAMT,UAAU,KAAKI,aAAL,EAAhB;AAEA,YAAMM,gBAAgBV,QAAQW,GAAR,CAAYF,WAAZ,CAAtB;AACA,YAAIC,aAAJ,EAAmB;AACjB,mBAAO,wCAAmBE,OAAnB,CAA2BF,aAA3B,CAAP;AACD,SAFD,MAEO;AACL,mBAAO,KAAKX,mBAAL,CAAyBQ,QAAzB,CAAkCC,WAAlC,EAA+CC,WAA/C,CAAP;AACD;AACF,KAZD;AAcA;;;;AAIAX,+BAAAG,SAAA,CAAAY,KAAA,GAAA,UAAML,WAAN,EAAyC;AAAzC,YAAAM,QAAA,IAAA;AACE,YAAMd,UAAU,KAAKI,aAAL,EAAhB;AAEA,YAAMW,WAA4C,EAAlD;AACAf,gBAAQgB,OAAR,CAAgB,UAACV,GAAD,EAAMW,QAAN,EAAc;AAC5BF,qBAASG,IAAT,CAAcJ,MAAKf,mBAAL,CAAyBG,QAAzB,CAAkCM,WAAlC,EAA+CS,QAA/C,CAAd;AACD,SAFD;AAIA;AACA,aAAKjB,OAAL,GAAe,IAAf;AAEA,eAAO,wCAAmBmB,OAAnB,CAA2BJ,QAA3B,CAAP;AACD,KAZD;AAcA;AACQjB,+BAAAG,SAAA,CAAAG,aAAA,GAAR,YAAA;AACE,4BAAO,KAAKJ,OAAL,KAAiB,IAAxB,EAA8B,oCAA9B;AACA,eAAO,KAAKA,OAAZ;AACD,KAHO;AAIV,WAAAF,0BAAA;AA7DA,CAAA,EAAA,C,CAtCA;;;;;;;;;;;;;;;QCoFSA,0B,GAAAA,0B","file":"remote_document_change_buffer.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MaybeDocumentMap, maybeDocumentMap } from '../model/collections';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { assert } from '../util/assert';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * NOTE: This class was introduced in iOS to work around a limitation in\n * LevelDB. Given IndexedDb has full transaction support with\n * read-your-own-writes capability, this class is not technically needed, but\n * has been preserved as a convenience and to aid portability.\n */\nexport class RemoteDocumentChangeBuffer {\n  private changes: MaybeDocumentMap | null = maybeDocumentMap();\n\n  constructor(private remoteDocumentCache: RemoteDocumentCache) {}\n\n  /** Buffers a `RemoteDocumentCache.addEntry()` call. */\n  addEntry(maybeDocument: MaybeDocument): void {\n    const changes = this.assertChanges();\n    this.changes = changes.insert(maybeDocument.key, maybeDocument);\n  }\n\n  // NOTE: removeEntry() is not presently necessary and so is omitted.\n\n  /**\n   * Looks up an entry in the cache. The buffered changes will first be checked,\n   * and if no buffered change applies, this will forward to\n   * `RemoteDocumentCache.getEntry()`.\n   *\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the entry to look up.\n   * @return The cached Document or NoDocument entry, or null if we have nothing\n   * cached.\n   */\n  getEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    const changes = this.assertChanges();\n\n    const bufferedEntry = changes.get(documentKey);\n    if (bufferedEntry) {\n      return PersistencePromise.resolve(bufferedEntry);\n    } else {\n      return this.remoteDocumentCache.getEntry(transaction, documentKey);\n    }\n  }\n\n  /**\n   * Applies buffered changes to the underlying RemoteDocumentCache, using\n   * the provided transaction.\n   */\n  apply(transaction: PersistenceTransaction): PersistencePromise<void> {\n    const changes = this.assertChanges();\n\n    const promises: Array<PersistencePromise<void>> = [];\n    changes.forEach((key, maybeDoc) => {\n      promises.push(this.remoteDocumentCache.addEntry(transaction, maybeDoc));\n    });\n\n    // We should not be used to buffer any more changes.\n    this.changes = null;\n\n    return PersistencePromise.waitFor(promises);\n  }\n\n  /** Helper to assert this.changes is not null and return it. */\n  private assertChanges(): MaybeDocumentMap {\n    assert(this.changes !== null, 'Changes have already been applied.');\n    return this.changes!;\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { assert } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * NOTE: This class was introduced in iOS to work around a limitation in\n * LevelDB. Given IndexedDb has full transaction support with\n * read-your-own-writes capability, this class is not technically needed, but\n * has been preserved as a convenience and to aid portability.\n */\nvar RemoteDocumentChangeBuffer = /** @class */ (function () {\n    function RemoteDocumentChangeBuffer(remoteDocumentCache) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.changes = maybeDocumentMap();\n    }\n    /** Buffers a `RemoteDocumentCache.addEntry()` call. */\n    RemoteDocumentChangeBuffer.prototype.addEntry = function (maybeDocument) {\n        var changes = this.assertChanges();\n        this.changes = changes.insert(maybeDocument.key, maybeDocument);\n    };\n    // NOTE: removeEntry() is not presently necessary and so is omitted.\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the entry to look up.\n     * @return The cached Document or NoDocument entry, or null if we have nothing\n     * cached.\n     */\n    RemoteDocumentChangeBuffer.prototype.getEntry = function (transaction, documentKey) {\n        var changes = this.assertChanges();\n        var bufferedEntry = changes.get(documentKey);\n        if (bufferedEntry) {\n            return PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.remoteDocumentCache.getEntry(transaction, documentKey);\n        }\n    };\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    RemoteDocumentChangeBuffer.prototype.apply = function (transaction) {\n        var _this = this;\n        var changes = this.assertChanges();\n        var promises = [];\n        changes.forEach(function (key, maybeDoc) {\n            promises.push(_this.remoteDocumentCache.addEntry(transaction, maybeDoc));\n        });\n        // We should not be used to buffer any more changes.\n        this.changes = null;\n        return PersistencePromise.waitFor(promises);\n    };\n    /** Helper to assert this.changes is not null and return it. */\n    RemoteDocumentChangeBuffer.prototype.assertChanges = function () {\n        assert(this.changes !== null, 'Changes have already been applied.');\n        return this.changes;\n    };\n    return RemoteDocumentChangeBuffer;\n}());\nexport { RemoteDocumentChangeBuffer };\n\n\n"]}