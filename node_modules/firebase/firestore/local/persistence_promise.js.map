{"version":3,"sources":["src/firestore/local/persistence_promise.ts","firestore/local/persistence_promise.js"],"names":["PersistencePromise","callback","_this","nextCallback","catchCallback","result","undefined","error","isDone","callbackAttached","value","prototype","catch","fn","next","nextFn","catchFn","wrapSuccess","wrapFailure","resolve","reject","toPromise","wrapUserFunction","e","waitFor","all","reduce","promise","nextPromise","idx","map","results","first","initial","push"],"mappings":";;;;;;;AAgBA;;AACA;;AAWA;;;;;;;;;;;;;AA5BA;;;;;;;;;;;;;;;AAyCA,IAAAA,qBAAA,aAAA,YAAA;AAeE,aAAAA,kBAAA,CAAYC,QAAZ,EAAsE;AAAtE,YAAAC,QAAA,IAAA;AAdA;AACA;AACQ,aAAAC,YAAA,GAAyC,IAAzC;AACA,aAAAC,aAAA,GAAsC,IAAtC;AAER;AACQ,aAAAC,MAAA,GAAwBC,SAAxB;AACA,aAAAC,KAAA,GAAa,IAAb;AACA,aAAAC,MAAA,GAAS,KAAT;AAER;AACA;AACQ,aAAAC,gBAAA,GAAmB,KAAnB;AAGNR,iBACE,UAAAS,KAAA,EAAK;AACHR,kBAAKM,MAAL,GAAc,IAAd;AACAN,kBAAKG,MAAL,GAAcK,KAAd;AACA,gBAAIR,MAAKC,YAAT,EAAuB;AACrB;AACA;AACAD,sBAAKC,YAAL,CAAkBO,KAAlB;AACD;AACF,SATH,EAUE,UAAAH,KAAA,EAAK;AACHL,kBAAKM,MAAL,GAAc,IAAd;AACAN,kBAAKK,KAAL,GAAaA,KAAb;AACA,gBAAIL,MAAKE,aAAT,EAAwB;AACtBF,sBAAKE,aAAL,CAAmBG,KAAnB;AACD;AACF,SAhBH;AAkBD;AAEDP,uBAAAW,SAAA,CAAAC,KAAA,GAAA,UACEC,EADF,EAC+C;AAE7C,eAAO,KAAKC,IAAL,CAAUR,SAAV,EAAqBO,EAArB,CAAP;AACD,KAJD;AAMAb,uBAAAW,SAAA,CAAAG,IAAA,GAAA,UACEC,MADF,EAEEC,OAFF,EAE8B;AAF9B,YAAAd,QAAA,IAAA;AAIE,YAAI,KAAKO,gBAAT,EAA2B;AACzB,8BAAK,uDAAL;AACD;AACD,aAAKA,gBAAL,GAAwB,IAAxB;AACA,YAAI,KAAKD,MAAT,EAAiB;AACf,gBAAI,CAAC,KAAKD,KAAV,EAAiB;AACf,uBAAO,KAAKU,WAAL,CAAiBF,MAAjB,EAAyB,KAAKV,MAA9B,CAAP;AACD,aAFD,MAEO;AACL,uBAAO,KAAKa,WAAL,CAAiBF,OAAjB,EAA0B,KAAKT,KAA/B,CAAP;AACD;AACF,SAND,MAMO;AACL,mBAAO,IAAIP,kBAAJ,CAA0B,UAACmB,OAAD,EAAUC,MAAV,EAAgB;AAC/ClB,sBAAKC,YAAL,GAAoB,UAACO,KAAD,EAAS;AAC3BR,0BAAKe,WAAL,CAAiBF,MAAjB,EAAyBL,KAAzB,EAAgCI,IAAhC,CAAqCK,OAArC,EAA8CC,MAA9C;AACD,iBAFD;AAGAlB,sBAAKE,aAAL,GAAqB,UAACG,KAAD,EAAW;AAC9BL,0BAAKgB,WAAL,CAAiBF,OAAjB,EAA0BT,KAA1B,EAAiCO,IAAjC,CAAsCK,OAAtC,EAA+CC,MAA/C;AACD,iBAFD;AAGD,aAPM,CAAP;AAQD;AACF,KAxBD;AA0BApB,uBAAAW,SAAA,CAAAU,SAAA,GAAA,YAAA;AAAA,YAAAnB,QAAA,IAAA;AACE,eAAO,yBAAY,UAACiB,OAAD,EAAUC,MAAV,EAAgB;AACjClB,kBAAKY,IAAL,CAAUK,OAAV,EAAmBC,MAAnB;AACD,SAFM,CAAP;AAGD,KAJD;AAMQpB,uBAAAW,SAAA,CAAAW,gBAAA,GAAR,UACET,EADF,EACqC;AAEnC,YAAI;AACF,gBAAMR,SAASQ,IAAf;AACA,gBAAIR,kBAAkBL,kBAAtB,EAA0C;AACxC,uBAAOK,MAAP;AACD,aAFD,MAEO;AACL,uBAAOL,mBAAmBmB,OAAnB,CAA2Bd,MAA3B,CAAP;AACD;AACF,SAPD,CAOE,OAAOkB,CAAP,EAAU;AACV,mBAAOvB,mBAAmBoB,MAAnB,CAA6BG,CAA7B,CAAP;AACD;AACF,KAbO;AAeAvB,uBAAAW,SAAA,CAAAM,WAAA,GAAR,UACEF,MADF,EAEEL,KAFF,EAEU;AAER,YAAIK,MAAJ,EAAY;AACV,mBAAO,KAAKO,gBAAL,CAAsB,YAAA;AAAM,uBAAAP,OAAOL,KAAP,CAAA;AAAa,aAAzC,CAAP;AACD,SAFD,MAEO;AACL;AACA;AACA,mBAAOV,mBAAmBmB,OAAnB,CAA8BT,KAA9B,CAAP;AACD;AACF,KAXO;AAaAV,uBAAAW,SAAA,CAAAO,WAAA,GAAR,UACEF,OADF,EAEET,KAFF,EAEY;AAEV,YAAIS,OAAJ,EAAa;AACX,mBAAO,KAAKM,gBAAL,CAAsB,YAAA;AAAM,uBAAAN,QAAQT,KAAR,CAAA;AAAc,aAA1C,CAAP;AACD,SAFD,MAEO;AACL,mBAAOP,mBAAmBoB,MAAnB,CAA6Bb,KAA7B,CAAP;AACD;AACF,KATO;AAaDP,uBAAAmB,OAAA,GAAP,UAAkBd,MAAlB,EAA4B;AAC1B,eAAO,IAAIL,kBAAJ,CAA0B,UAACmB,OAAD,EAAUC,MAAV,EAAgB;AAC/CD,oBAAQd,MAAR;AACD,SAFM,CAAP;AAGD,KAJM;AAMAL,uBAAAoB,MAAA,GAAP,UAAiBb,KAAjB,EAA2B;AACzB,eAAO,IAAIP,kBAAJ,CAA0B,UAACmB,OAAD,EAAUC,MAAV,EAAgB;AAC/CA,mBAAOb,KAAP;AACD,SAFM,CAAP;AAGD,KAJM;AAMAP,uBAAAwB,OAAA,GAAP,UACEC,GADF,EACqC;AAEnC,eAAOA,IAAIC,MAAJ,CAAW,UAACC,OAAD,EAAUC,WAAV,EAAuBC,GAAvB,EAA0B;AAC1C,mBAAOF,QAAQb,IAAR,CAAa,YAAA;AAClB,uBAAOc,WAAP;AACD,aAFM,CAAP;AAGD,SAJM,EAIJ5B,mBAAmBmB,OAAnB,EAJI,CAAP;AAKD,KARM;AAUAnB,uBAAA8B,GAAA,GAAP,UAAcL,GAAd,EAA+C;AAC7C,YAAMM,UAAe,EAArB;AACA,YAAIC,QAAQ,IAAZ;AACA;AACA,YAAMC,UAAUjC,mBAAmBmB,OAAnB,CAA8B,IAA9B,CAAhB;AACA,eAAOM,IACJC,MADI,CACG,UAACC,OAAD,EAAUC,WAAV,EAAqB;AAC3B,mBAAOD,QAAQb,IAAR,CAAa,UAAAT,MAAA,EAAM;AACxB,oBAAI,CAAC2B,KAAL,EAAY;AACVD,4BAAQG,IAAR,CAAa7B,MAAb;AACD;AACD2B,wBAAQ,KAAR;AACA,uBAAOJ,WAAP;AACD,aANM,CAAP;AAOD,SATI,EASFK,OATE,EAUJnB,IAVI,CAUC,UAAAT,MAAA,EAAM;AACV0B,oBAAQG,IAAR,CAAa7B,MAAb;AACA,mBAAO0B,OAAP;AACD,SAbI,CAAP;AAcD,KAnBM;AAoBT,WAAA/B,kBAAA;AA7JA,CAAA,EAAA;QC4HSA,kB,GAAAA,kB","file":"persistence_promise.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fail } from '../util/assert';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nexport type FulfilledHandler<T, R> =\n  | ((result: T) => R | PersistencePromise<R>)\n  | null;\nexport type RejectedHandler<R> =\n  | ((reason: any) => R | PersistencePromise<R>)\n  | null;\nexport type Resolver<T> = (value?: T) => void;\nexport type Rejector = (error: any) => void;\n\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nexport class PersistencePromise<T> {\n  // NOTE: next/catchCallback will always point to our own wrapper functions,\n  // not the user's raw next() or catch() callbacks.\n  private nextCallback: FulfilledHandler<T, any> = null;\n  private catchCallback: RejectedHandler<any> = null;\n\n  // When the operation resolves, we'll set result or error and mark isDone.\n  private result: T | undefined = undefined;\n  private error: any = null;\n  private isDone = false;\n\n  // Set to true when .then() or .catch() are called and prevents additional\n  // chaining.\n  private callbackAttached = false;\n\n  constructor(callback: (resolve: Resolver<T>, reject: Rejector) => void) {\n    callback(\n      value => {\n        this.isDone = true;\n        this.result = value;\n        if (this.nextCallback) {\n          // value should be defined unless T is Void, but we can't express\n          // that in the type system.\n          this.nextCallback(value!);\n        }\n      },\n      error => {\n        this.isDone = true;\n        this.error = error;\n        if (this.catchCallback) {\n          this.catchCallback(error);\n        }\n      }\n    );\n  }\n\n  catch<R>(\n    fn: (error: any) => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    return this.next(undefined, fn);\n  }\n\n  next<R>(\n    nextFn?: FulfilledHandler<T, R>,\n    catchFn?: RejectedHandler<R>\n  ): PersistencePromise<R> {\n    if (this.callbackAttached) {\n      fail('Called next() or catch() twice for PersistencePromise');\n    }\n    this.callbackAttached = true;\n    if (this.isDone) {\n      if (!this.error) {\n        return this.wrapSuccess(nextFn, this.result!);\n      } else {\n        return this.wrapFailure(catchFn, this.error);\n      }\n    } else {\n      return new PersistencePromise<R>((resolve, reject) => {\n        this.nextCallback = (value: T) => {\n          this.wrapSuccess(nextFn, value).next(resolve, reject);\n        };\n        this.catchCallback = (error: any) => {\n          this.wrapFailure(catchFn, error).next(resolve, reject);\n        };\n      });\n    }\n  }\n\n  toPromise(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.next(resolve, reject);\n    });\n  }\n\n  private wrapUserFunction<R>(\n    fn: () => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    try {\n      const result = fn();\n      if (result instanceof PersistencePromise) {\n        return result;\n      } else {\n        return PersistencePromise.resolve(result);\n      }\n    } catch (e) {\n      return PersistencePromise.reject<R>(e);\n    }\n  }\n\n  private wrapSuccess<R>(\n    nextFn: FulfilledHandler<T, R> | undefined,\n    value: T\n  ): PersistencePromise<R> {\n    if (nextFn) {\n      return this.wrapUserFunction(() => nextFn(value));\n    } else {\n      // If there's no nextFn, then R must be the same as T but we\n      // can't express that in the type system.\n      return PersistencePromise.resolve<R>(value as any);\n    }\n  }\n\n  private wrapFailure<R>(\n    catchFn: RejectedHandler<R> | undefined,\n    error: any\n  ): PersistencePromise<R> {\n    if (catchFn) {\n      return this.wrapUserFunction(() => catchFn(error));\n    } else {\n      return PersistencePromise.reject<R>(error);\n    }\n  }\n\n  static resolve(): PersistencePromise<void>;\n  static resolve<R>(result: R): PersistencePromise<R>;\n  static resolve<R>(result?: R): PersistencePromise<R | void> {\n    return new PersistencePromise<R>((resolve, reject) => {\n      resolve(result);\n    });\n  }\n\n  static reject<R>(error: any): PersistencePromise<R> {\n    return new PersistencePromise<R>((resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  static waitFor(\n    all: Array<PersistencePromise<any>>\n  ): PersistencePromise<void> {\n    return all.reduce((promise, nextPromise, idx) => {\n      return promise.next(() => {\n        return nextPromise;\n      });\n    }, PersistencePromise.resolve());\n  }\n\n  static map<R>(all: Array<PersistencePromise<R>>): PersistencePromise<R[]> {\n    const results: R[] = [];\n    let first = true;\n    // initial is ignored, so we can cheat on the type.\n    const initial = PersistencePromise.resolve<R>(null as any);\n    return all\n      .reduce((promise, nextPromise) => {\n        return promise.next(result => {\n          if (!first) {\n            results.push(result);\n          }\n          first = false;\n          return nextPromise;\n        });\n      }, initial)\n      .next(result => {\n        results.push(result);\n        return results;\n      });\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nvar PersistencePromise = /** @class */ (function () {\n    function PersistencePromise(callback) {\n        var _this = this;\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        this.nextCallback = null;\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = null;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(function (value) {\n            _this.isDone = true;\n            _this.result = value;\n            if (_this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                _this.nextCallback(value);\n            }\n        }, function (error) {\n            _this.isDone = true;\n            _this.error = error;\n            if (_this.catchCallback) {\n                _this.catchCallback(error);\n            }\n        });\n    }\n    PersistencePromise.prototype.catch = function (fn) {\n        return this.next(undefined, fn);\n    };\n    PersistencePromise.prototype.next = function (nextFn, catchFn) {\n        var _this = this;\n        if (this.callbackAttached) {\n            fail('Called next() or catch() twice for PersistencePromise');\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise(function (resolve, reject) {\n                _this.nextCallback = function (value) {\n                    _this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                _this.catchCallback = function (error) {\n                    _this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    };\n    PersistencePromise.prototype.toPromise = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.next(resolve, reject);\n        });\n    };\n    PersistencePromise.prototype.wrapUserFunction = function (fn) {\n        try {\n            var result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    };\n    PersistencePromise.prototype.wrapSuccess = function (nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(function () { return nextFn(value); });\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T but we\n            // can't express that in the type system.\n            return PersistencePromise.resolve(value);\n        }\n    };\n    PersistencePromise.prototype.wrapFailure = function (catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(function () { return catchFn(error); });\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    };\n    PersistencePromise.resolve = function (result) {\n        return new PersistencePromise(function (resolve, reject) {\n            resolve(result);\n        });\n    };\n    PersistencePromise.reject = function (error) {\n        return new PersistencePromise(function (resolve, reject) {\n            reject(error);\n        });\n    };\n    PersistencePromise.waitFor = function (all) {\n        return all.reduce(function (promise, nextPromise, idx) {\n            return promise.next(function () {\n                return nextPromise;\n            });\n        }, PersistencePromise.resolve());\n    };\n    PersistencePromise.map = function (all) {\n        var results = [];\n        var first = true;\n        // initial is ignored, so we can cheat on the type.\n        var initial = PersistencePromise.resolve(null);\n        return all\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (!first) {\n                    results.push(result);\n                }\n                first = false;\n                return nextPromise;\n            });\n        }, initial)\n            .next(function (result) {\n            results.push(result);\n            return results;\n        });\n    };\n    return PersistencePromise;\n}());\nexport { PersistencePromise };\n\n\n"]}