{"version":3,"sources":["src/firestore/local/simple_db.ts","firestore/local/simple_db.js"],"names":["LOG_TAG","SimpleDb","db","openOrCreate","name","version","runUpgrade","isAvailable","resolve","reject","request","window","indexedDB","open","onsuccess","event","target","result","onerror","error","onupgradeneeded","oldVersion","toPromise","delete","wrapRequest","deleteDatabase","ua","navigator","userAgent","indexOf","prototype","runTransaction","mode","objectStores","transactionFn","transaction","SimpleDbTransaction","transactionFnResult","catch","abort","completionPromise","then","close","IterationController","dbCursor","shouldStop","nextKey","Object","defineProperty","get","enumerable","configurable","set","value","done","skip","key","objectStoresNames","_this","aborted","onabort","oncomplete","store","storeName","objectStore","SimpleDbStore","put","keyOrValue","undefined","next","loadAll","indexOrRange","range","cursor","options","results","iterateCursor","push","deleteAll","keysOnly","control","iterate","optionsOrCallback","callback","cursorRequest","fn","controller","userResult","primaryKey","isDone","skipToKey","continue","waitFor","indexName","index","direction","reverse","openKeyCursor","openCursor"],"mappings":"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","file":"simple_db.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { AnyDuringMigration } from '../util/misc';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { PersistencePromise } from './persistence_promise';\n\nconst LOG_TAG = 'SimpleDb';\n\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nexport class SimpleDb {\n  /** Opens the specified database, creating or upgrading it if necessary. */\n  static openOrCreate(\n    name: string,\n    version: number,\n    runUpgrade: (db: IDBDatabase, oldVersion: number) => void\n  ): Promise<SimpleDb> {\n    assert(\n      SimpleDb.isAvailable(),\n      'IndexedDB not supported in current environment.'\n    );\n    debug(LOG_TAG, 'Opening database:', name);\n    return new PersistencePromise<SimpleDb>((resolve, reject) => {\n      // TODO(mikelehen): Investigate browser compatibility.\n      // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n      // suggests IE9 and older WebKit browsers handle upgrade\n      // differently.\n      const request = window.indexedDB.open(name, version);\n\n      request.onsuccess = (event: Event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        resolve(new SimpleDb(db));\n      };\n\n      request.onerror = (event: ErrorEvent) => {\n        reject((event.target as IDBOpenDBRequest).error);\n      };\n\n      request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n        debug(\n          LOG_TAG,\n          'Database \"' + name + '\" requires upgrade from version:',\n          event.oldVersion\n        );\n        // TODO(mikelehen): If/when we need to do an actual data\n        // migration, we'll want to wrap db in a SimpleDb and have the\n        // runUpgrade function return a PersistencePromise, since we'll\n        // likely need to do async reads and writes. For now we're\n        // cheating and just passing the raw IndexedDB in, since\n        // createObjectStore(), etc. are synchronous.\n        const db = (event.target as IDBOpenDBRequest).result;\n        runUpgrade(db, event.oldVersion);\n      };\n    }).toPromise();\n  }\n\n  /** Deletes the specified database. */\n  static delete(name: string): Promise<void> {\n    debug(LOG_TAG, 'Removing database:', name);\n    return wrapRequest<void>(window.indexedDB.deleteDatabase(name)).toPromise();\n  }\n\n  /** Returns true if IndexedDB is available in the current environment. */\n  static isAvailable(): boolean {\n    if (typeof window === 'undefined' || window.indexedDB == null) {\n      return false;\n    }\n    // We extensively use indexed array values and compound keys,\n    // which IE and Edge do not support. However, they still have indexedDB\n    // defined on the window, so we need to check for them here and make sure\n    // to return that persistence is not enabled for those browsers.\n    // For tracking support of this feature, see here:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n\n    // Check the UA string to find out the browser.\n    const ua = window.navigator.userAgent;\n\n    // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n\n    // Edge\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n    // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n\n    if (\n      ua.indexOf('MSIE ') > 0 ||\n      ua.indexOf('Trident/') > 0 ||\n      ua.indexOf('Edge/') > 0\n    ) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  constructor(private db: IDBDatabase) {}\n\n  runTransaction<T>(\n    mode: 'readonly' | 'readwrite',\n    objectStores: string[],\n    transactionFn: (transaction: SimpleDbTransaction) => PersistencePromise<T>\n  ): Promise<T> {\n    const transaction = new SimpleDbTransaction(this.db, mode, objectStores);\n    const transactionFnResult = transactionFn(transaction)\n      .catch(error => {\n        // Abort the transaction if there was an\n        // error.\n        transaction.abort();\n        return PersistencePromise.reject(error);\n      })\n      .toPromise();\n\n    // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n    // fire), but still return the original transactionFnResult back to the\n    // caller.\n    return transaction.completionPromise.then(\n      () => transactionFnResult\n    ) as AnyDuringMigration;\n  }\n\n  close() {\n    this.db.close();\n  }\n}\n\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nexport class IterationController {\n  private shouldStop = false;\n  private nextKey: IDBValidKey | IDBKeyRange | null = null;\n\n  constructor(private dbCursor: IDBCursorWithValue) {}\n\n  get isDone(): boolean {\n    return this.shouldStop;\n  }\n\n  get skipToKey(): IDBValidKey | IDBKeyRange | null {\n    return this.nextKey;\n  }\n\n  set cursor(value: IDBCursorWithValue) {\n    this.dbCursor = value;\n  }\n\n  /**\n   * This function can be called to stop iteration at any point.\n   */\n  done(): void {\n    this.shouldStop = true;\n  }\n\n  /**\n   * This function can be called to skip to that next key, which could be\n   * an index or a primary key.\n   */\n  skip(key: IDBValidKey | IDBKeyRange): void {\n    this.nextKey = key;\n  }\n\n  /**\n   * Delete the current cursor value from the object store.\n   *\n   * NOTE: You CANNOT do this with a keysOnly query.\n   */\n  delete(): PersistencePromise<void> {\n    return wrapRequest<void>(this.dbCursor.delete());\n  }\n}\n\n/**\n * Callback used with iterate() method.\n */\nexport type IterateCallback<KeyType, ValueType> = (\n  key: KeyType,\n  value: ValueType,\n  control: IterationController\n) => void | PersistencePromise<void>;\n\n/** Options available to the iterate() method. */\nexport interface IterateOptions {\n  /** Index to iterate over (else primary keys will be iterated) */\n  index?: string;\n\n  /** IndxedDB Range to iterate over (else entire store will be iterated) */\n  range?: IDBKeyRange;\n\n  /** If true, values aren't read while iterating. */\n  keysOnly?: boolean;\n\n  /** If true, iterate over the store in reverse. */\n  reverse?: boolean;\n}\n\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nexport class SimpleDbTransaction {\n  private transaction: IDBTransaction;\n  private aborted = false;\n\n  /**\n   * A promise that resolves with the result of the IndexedDb transaction.\n   *\n   * Note: A transaction explicitly aborted via abort() is considered successful\n   * and this promise will resolve as successful.\n   */\n  readonly completionPromise: Promise<void>;\n\n  constructor(db: IDBDatabase, mode: string, objectStoresNames: string[]) {\n    this.transaction = db.transaction(\n      objectStoresNames,\n      mode as AnyDuringMigration\n    );\n\n    this.completionPromise = new Promise<void>((resolve, reject) => {\n      // We consider aborting to be \"normal\" and just resolve the promise.\n      // May need to revisit if/when we actually need to abort transactions.\n      this.transaction.onabort = this.transaction.oncomplete = event => {\n        resolve();\n      };\n      this.transaction.onerror = (event: Event) => {\n        reject((event.target as IDBRequest).error);\n      };\n    });\n  }\n\n  abort(): void {\n    if (!this.aborted) {\n      debug(LOG_TAG, 'Aborting transaction.');\n      this.aborted = true;\n      this.transaction.abort();\n    }\n  }\n\n  /**\n   * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n   * operations performed on the SimpleDbStore happen within the context of this\n   * transaction and it cannot be used anymore once the transaction is\n   * completed.\n   *\n   * Note that we can't actually enforce that the KeyType and ValueType are\n   * correct, but they allow type safety through the rest of the consuming code.\n   */\n  store<KeyType extends IDBValidKey, ValueType>(\n    storeName: string\n  ): SimpleDbStore<KeyType, ValueType> {\n    const store = this.transaction.objectStore(storeName);\n    assert(!!store, 'Object store not part of transaction: ' + storeName);\n    return new SimpleDbStore<KeyType, ValueType>(store);\n  }\n}\n\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nexport class SimpleDbStore<KeyType extends IDBValidKey, ValueType> {\n  constructor(private store: IDBObjectStore) {}\n\n  /**\n   * Writes a value into the Object Store.\n   *\n   * @param key Optional explicit key to use when writing the object, else the\n   * key will be auto-assigned (e.g. via the defined keyPath for the store).\n   * @param value The object to write.\n   */\n  put(value: ValueType): PersistencePromise<void>;\n  put(key: KeyType, value: ValueType): PersistencePromise<void>;\n  put(\n    keyOrValue: KeyType | ValueType,\n    value?: ValueType\n  ): PersistencePromise<void> {\n    let request;\n    if (value !== undefined) {\n      debug(LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n      request = this.store.put(value, keyOrValue as KeyType);\n    } else {\n      debug(LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n      request = this.store.put(keyOrValue as ValueType);\n    }\n    return wrapRequest<void>(request);\n  }\n\n  /**\n   * Gets the object with the specified key from the specified store, or null\n   * if no object exists with the specified key.\n   *\n   * @key The key of the object to get.\n   * @return The object with the specified key or null if no object exists.\n   */\n  get(key: KeyType): PersistencePromise<ValueType | null> {\n    const request = this.store.get(key);\n    // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.\n    return wrapRequest<any>(request).next(result => {\n      // Normalize nonexistence to null.\n      if (result === undefined) {\n        result = null;\n      }\n      debug(LOG_TAG, 'GET', this.store.name, key, result);\n      return result;\n    });\n  }\n\n  delete(key: KeyType | IDBKeyRange): PersistencePromise<void> {\n    debug(LOG_TAG, 'DELETE', this.store.name, key);\n    const request = this.store.delete(key);\n    return wrapRequest<void>(request);\n  }\n\n  loadAll(): PersistencePromise<ValueType[]>;\n  loadAll(range: IDBKeyRange): PersistencePromise<ValueType[]>;\n  loadAll(index: string, range: IDBKeyRange): PersistencePromise<ValueType[]>;\n  loadAll(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): PersistencePromise<ValueType[]> {\n    const cursor = this.cursor(this.options(indexOrRange, range));\n    const results: ValueType[] = [];\n    return this.iterateCursor(cursor, (key, value) => {\n      results.push(value);\n    }).next(() => {\n      return results;\n    });\n  }\n\n  deleteAll(): PersistencePromise<void>;\n  deleteAll(range: IDBKeyRange): PersistencePromise<void>;\n  deleteAll(index: string, range: IDBKeyRange): PersistencePromise<void>;\n  deleteAll(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): PersistencePromise<void> {\n    debug(LOG_TAG, 'DELETE ALL', this.store.name);\n    const options = this.options(indexOrRange, range);\n    options.keysOnly = false;\n    const cursor = this.cursor(options);\n    return this.iterateCursor(cursor, (key, value, control) => {\n      // NOTE: Calling delete() on a cursor is documented as more efficient than\n      // calling delete() on an object store with a single key\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n      // however, this requires us *not* to use a keysOnly cursor\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n      // may want to compare the performance of each method.\n      return control.delete();\n    });\n  }\n\n  /**\n   * Iterates over keys and values in an object store.\n   *\n   * @param options Options specifying how to iterate the objects in the store.\n   * @param callback will be called for each iterated object. Iteration can be\n   * canceled at any point by calling the doneFn passed to the callback.\n   * The callback can return a PersistencePromise if it performs async\n   * operations but note that iteration will continue without waiting for them\n   * to complete.\n   * @returns A PersistencePromise that resolves once all PersistencePromises\n   * returned by callbacks resolve.\n   */\n  iterate(\n    callback: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void>;\n  iterate(\n    options: IterateOptions,\n    callback: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void>;\n  iterate(\n    optionsOrCallback: IterateOptions | IterateCallback<KeyType, ValueType>,\n    callback?: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void> {\n    let options;\n    if (!callback) {\n      options = {};\n      callback = optionsOrCallback as IterateCallback<KeyType, ValueType>;\n    } else {\n      options = optionsOrCallback;\n    }\n    const cursor = this.cursor(options);\n    return this.iterateCursor(cursor, callback);\n  }\n\n  private iterateCursor(\n    cursorRequest: IDBRequest,\n    fn: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void> {\n    const results: Array<PersistencePromise<void>> = [];\n    return new PersistencePromise((resolve, reject) => {\n      cursorRequest.onerror = (event: Event) => {\n        reject((event.target as IDBRequest).error);\n      };\n      cursorRequest.onsuccess = (event: Event) => {\n        const cursor: IDBCursorWithValue = (event.target as IDBRequest).result;\n        if (!cursor) {\n          resolve();\n          return;\n        }\n        const controller = new IterationController(cursor);\n        const userResult = fn(cursor.primaryKey, cursor.value, controller);\n        if (userResult instanceof PersistencePromise) {\n          results.push(userResult);\n        }\n        if (controller.isDone) {\n          resolve();\n        } else if (controller.skipToKey === null) {\n          cursor.continue();\n        } else {\n          cursor.continue(controller.skipToKey);\n        }\n      };\n    }).next(() => {\n      return PersistencePromise.waitFor(results);\n    });\n  }\n\n  private options(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): IterateOptions {\n    let indexName: string | undefined = undefined;\n    if (indexOrRange !== undefined) {\n      if (typeof indexOrRange === 'string') {\n        indexName = indexOrRange;\n      } else {\n        assert(\n          range === undefined,\n          '3rd argument must not be defined if 2nd is a range.'\n        );\n        range = indexOrRange;\n      }\n    }\n    return { index: indexName, range };\n  }\n\n  private cursor(options: IterateOptions): IDBRequest {\n    let direction = 'next';\n    if (options.reverse) {\n      direction = 'prev';\n    }\n    if (options.index) {\n      const index = this.store.index(options.index);\n      if (options.keysOnly) {\n        return index.openKeyCursor(\n          options.range,\n          direction as AnyDuringMigration\n        );\n      } else {\n        return index.openCursor(options.range, direction as AnyDuringMigration);\n      }\n    } else {\n      return this.store.openCursor(\n        options.range,\n        direction as AnyDuringMigration\n      );\n    }\n  }\n}\n\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest<R>(request: IDBRequest): PersistencePromise<R> {\n  return new PersistencePromise<R>((resolve, reject) => {\n    request.onsuccess = (event: Event) => {\n      const result = (event.target as IDBRequest).result;\n      resolve(result);\n    };\n\n    request.onerror = (event: Event) => {\n      reject((event.target as IDBRequest).error);\n    };\n  });\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { PromiseImpl as Promise } from '../../utils/promise';\nimport { PersistencePromise } from './persistence_promise';\nvar LOG_TAG = 'SimpleDb';\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nvar SimpleDb = /** @class */ (function () {\n    function SimpleDb(db) {\n        this.db = db;\n    }\n    /** Opens the specified database, creating or upgrading it if necessary. */\n    SimpleDb.openOrCreate = function (name, version, runUpgrade) {\n        assert(SimpleDb.isAvailable(), 'IndexedDB not supported in current environment.');\n        debug(LOG_TAG, 'Opening database:', name);\n        return new PersistencePromise(function (resolve, reject) {\n            // TODO(mikelehen): Investigate browser compatibility.\n            // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n            // suggests IE9 and older WebKit browsers handle upgrade\n            // differently.\n            var request = window.indexedDB.open(name, version);\n            request.onsuccess = function (event) {\n                var db = event.target.result;\n                resolve(new SimpleDb(db));\n            };\n            request.onerror = function (event) {\n                reject(event.target.error);\n            };\n            request.onupgradeneeded = function (event) {\n                debug(LOG_TAG, 'Database \"' + name + '\" requires upgrade from version:', event.oldVersion);\n                // TODO(mikelehen): If/when we need to do an actual data\n                // migration, we'll want to wrap db in a SimpleDb and have the\n                // runUpgrade function return a PersistencePromise, since we'll\n                // likely need to do async reads and writes. For now we're\n                // cheating and just passing the raw IndexedDB in, since\n                // createObjectStore(), etc. are synchronous.\n                var db = event.target.result;\n                runUpgrade(db, event.oldVersion);\n            };\n        }).toPromise();\n    };\n    /** Deletes the specified database. */\n    SimpleDb.delete = function (name) {\n        debug(LOG_TAG, 'Removing database:', name);\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n    };\n    /** Returns true if IndexedDB is available in the current environment. */\n    SimpleDb.isAvailable = function () {\n        if (typeof window === 'undefined' || window.indexedDB == null) {\n            return false;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        var ua = window.navigator.userAgent;\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    SimpleDb.prototype.runTransaction = function (mode, objectStores, transactionFn) {\n        var transaction = new SimpleDbTransaction(this.db, mode, objectStores);\n        var transactionFnResult = transactionFn(transaction)\n            .catch(function (error) {\n            // Abort the transaction if there was an\n            // error.\n            transaction.abort();\n            return PersistencePromise.reject(error);\n        })\n            .toPromise();\n        // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n        // fire), but still return the original transactionFnResult back to the\n        // caller.\n        return transaction.completionPromise.then(function () { return transactionFnResult; });\n    };\n    SimpleDb.prototype.close = function () {\n        this.db.close();\n    };\n    return SimpleDb;\n}());\nexport { SimpleDb };\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nvar IterationController = /** @class */ (function () {\n    function IterationController(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    Object.defineProperty(IterationController.prototype, \"isDone\", {\n        get: function () {\n            return this.shouldStop;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"skipToKey\", {\n        get: function () {\n            return this.nextKey;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"cursor\", {\n        set: function (value) {\n            this.dbCursor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    IterationController.prototype.done = function () {\n        this.shouldStop = true;\n    };\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    IterationController.prototype.skip = function (key) {\n        this.nextKey = key;\n    };\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    IterationController.prototype.delete = function () {\n        return wrapRequest(this.dbCursor.delete());\n    };\n    return IterationController;\n}());\nexport { IterationController };\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nvar SimpleDbTransaction = /** @class */ (function () {\n    function SimpleDbTransaction(db, mode, objectStoresNames) {\n        var _this = this;\n        this.aborted = false;\n        this.transaction = db.transaction(objectStoresNames, mode);\n        this.completionPromise = new Promise(function (resolve, reject) {\n            // We consider aborting to be \"normal\" and just resolve the promise.\n            // May need to revisit if/when we actually need to abort transactions.\n            _this.transaction.onabort = _this.transaction.oncomplete = function (event) {\n                resolve();\n            };\n            _this.transaction.onerror = function (event) {\n                reject(event.target.error);\n            };\n        });\n    }\n    SimpleDbTransaction.prototype.abort = function () {\n        if (!this.aborted) {\n            debug(LOG_TAG, 'Aborting transaction.');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    };\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    SimpleDbTransaction.prototype.store = function (storeName) {\n        var store = this.transaction.objectStore(storeName);\n        assert(!!store, 'Object store not part of transaction: ' + storeName);\n        return new SimpleDbStore(store);\n    };\n    return SimpleDbTransaction;\n}());\nexport { SimpleDbTransaction };\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nvar SimpleDbStore = /** @class */ (function () {\n    function SimpleDbStore(store) {\n        this.store = store;\n    }\n    SimpleDbStore.prototype.put = function (keyOrValue, value) {\n        var request;\n        if (value !== undefined) {\n            debug(LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            debug(LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    };\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @return The object with the specified key or null if no object exists.\n     */\n    SimpleDbStore.prototype.get = function (key) {\n        var _this = this;\n        var request = this.store.get(key);\n        // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.\n        return wrapRequest(request).next(function (result) {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            debug(LOG_TAG, 'GET', _this.store.name, key, result);\n            return result;\n        });\n    };\n    SimpleDbStore.prototype.delete = function (key) {\n        debug(LOG_TAG, 'DELETE', this.store.name, key);\n        var request = this.store.delete(key);\n        return wrapRequest(request);\n    };\n    SimpleDbStore.prototype.loadAll = function (indexOrRange, range) {\n        var cursor = this.cursor(this.options(indexOrRange, range));\n        var results = [];\n        return this.iterateCursor(cursor, function (key, value) {\n            results.push(value);\n        }).next(function () {\n            return results;\n        });\n    };\n    SimpleDbStore.prototype.deleteAll = function (indexOrRange, range) {\n        debug(LOG_TAG, 'DELETE ALL', this.store.name);\n        var options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, function (key, value, control) {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    };\n    SimpleDbStore.prototype.iterate = function (optionsOrCallback, callback) {\n        var options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    };\n    SimpleDbStore.prototype.iterateCursor = function (cursorRequest, fn) {\n        var results = [];\n        return new PersistencePromise(function (resolve, reject) {\n            cursorRequest.onerror = function (event) {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                var controller = new IterationController(cursor);\n                var userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof PersistencePromise) {\n                    results.push(userResult);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(function () {\n            return PersistencePromise.waitFor(results);\n        });\n    };\n    SimpleDbStore.prototype.options = function (indexOrRange, range) {\n        var indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                assert(range === undefined, '3rd argument must not be defined if 2nd is a range.');\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range: range };\n    };\n    SimpleDbStore.prototype.cursor = function (options) {\n        var direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            var index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    };\n    return SimpleDbStore;\n}());\nexport { SimpleDbStore };\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new PersistencePromise(function (resolve, reject) {\n        request.onsuccess = function (event) {\n            var result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = function (event) {\n            reject(event.target.error);\n        };\n    });\n}\n\n\n"]}