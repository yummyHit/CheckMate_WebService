{"version":3,"sources":["src/firestore/local/indexeddb_persistence.ts"],"names":["log","LOG_TAG","OWNER_LEASE_MAX_AGE_MS","OWNER_LEASE_REFRESH_INTERVAL_MS","ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX","EXISTING_OWNER_ERROR_MSG","UNSUPPORTED_PLATFORM_ERROR_MSG","IndexedDbPersistence","prefix","serializer","ownerId","generateOwnerId","dbName","MAIN_DATABASE","localStoragePrefix","prototype","start","_this","isAvailable","persistenceError","UNIMPLEMENTED","reject","started","openOrCreate","then","db","simpleDb","tryAcquireOwnerLease","scheduleOwnerLeaseRefreshes","attachWindowUnloadHook","shutdown","detachWindowUnloadHook","stopOwnerLeaseRefreshes","releaseOwnerLease","close","getMutationQueue","user","forUser","getQueryCache","getRemoteDocumentCache","runTransaction","action","operation","debug","txn","ensureOwnerLease","next","buildStoragePrefix","databaseInfo","database","databaseId","projectId","isDefaultDatabase","persistenceKey","store","get","dbOwner","validOwner","newDbOwner","Date","now","put","FAILED_PRECONDITION","delete","resolve","minAcceptable","maxAcceptable","leaseTimestampMs","error","getZombiedOwnerId","ownerLeaseRefreshHandle","setInterval","txResult","catch","reason","clearInterval","windowUnloadHandler","setZombiedOwnerId","window","addEventListener","removeEventListener","zombiedOwnerId","localStorage","getItem","zombiedOwnerLocalStorageKey","e","zombieOwnerId","removeItem","setItem","newId"],"mappings":"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","file":"indexeddb_persistence.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { DatabaseInfo } from '../core/database_info';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AutoId } from '../util/misc';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { IndexedDbMutationQueue } from './indexeddb_mutation_queue';\nimport { IndexedDbQueryCache } from './indexeddb_query_cache';\nimport { IndexedDbRemoteDocumentCache } from './indexeddb_remote_document_cache';\nimport { ALL_STORES, DbOwner, DbOwnerKey } from './indexeddb_schema';\nimport { createOrUpgradeDb, SCHEMA_VERSION } from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { MutationQueue } from './mutation_queue';\nimport { Persistence } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { RemoteDocumentCache } from './remote_document_cache';\nimport { SimpleDb, SimpleDbTransaction } from './simple_db';\n\nconst LOG_TAG = 'IndexedDbPersistence';\n\n/** If the owner lease is older than 5 seconds, try to take ownership. */\nconst OWNER_LEASE_MAX_AGE_MS = 5000;\n/** Refresh the owner lease every 4 seconds while owner. */\nconst OWNER_LEASE_REFRESH_INTERVAL_MS = 4000;\n\n/** LocalStorage location to indicate a zombied ownerId (see class comment). */\nconst ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = 'zombiedOwnerId';\n/** Error when the owner lease cannot be acquired or is lost. */\nconst EXISTING_OWNER_ERROR_MSG =\n  'There is another tab open with offline' +\n  ' persistence enabled. Only one such tab is allowed at a time. The' +\n  ' other tab must be closed or persistence must be disabled.';\nconst UNSUPPORTED_PLATFORM_ERROR_MSG =\n  'This platform is either missing' +\n  ' IndexedDB or is known to have an incomplete implementation. Offline' +\n  ' persistence has been disabled.';\n\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * Currently the Firestore SDK only supports a single consumer of the database,\n * but browsers obviously support multiple tabs. IndexedDbPersistence ensures a\n * single consumer of the database via an \"owner lease\" stored in the database.\n *\n * On startup, IndexedDbPersistence assigns itself a random \"ownerId\" and writes\n * it to a special \"owner\" object in the database (if no entry exists already or\n * the current entry is expired). This owner lease is then verified inside every\n * transaction to ensure the lease has not been lost.\n *\n * If a tab opts not to acquire the owner lease (because there's an existing\n * non-expired owner) or loses the owner lease, IndexedDbPersistence enters a\n * failed state and all subsequent operations will automatically fail.\n *\n * The current owner regularly refreshes the owner lease with new timestamps to\n * prevent newly-opened tabs from taking over ownership.\n *\n * Additionally there is an optimization so that when a tab is closed, the owner\n * lease is released immediately (this is especially important to make sure that\n * a refreshed tab is able to immediately re-acquire the owner lease).\n * Unfortunately, IndexedDB cannot be reliably used in window.unload since it is\n * an asynchronous API. So in addition to attempting to give up the lease,\n * the owner writes its ownerId to a \"zombiedOwnerId\" entry in LocalStorage\n * which acts as an indicator that another tab should go ahead and take the\n * owner lease immediately regardless of the current lease timestamp.\n */\nexport class IndexedDbPersistence implements Persistence {\n  /**\n   * The name of the main (and currently only) IndexedDB database. this name is\n   * appended to the prefix provided to the IndexedDbPersistence constructor.\n   */\n  static MAIN_DATABASE = 'main';\n\n  private simpleDb: SimpleDb;\n  private started: boolean;\n  private dbName: string;\n  private localStoragePrefix: string;\n  private ownerId: string = this.generateOwnerId();\n\n  /**\n   * Set to an Error object if we encounter an unrecoverable error. All further\n   * transactions will be failed with this error.\n   */\n  private persistenceError: Error | null;\n  /** The setInterval() handle tied to refreshing the owner lease. */\n  // tslint:disable-next-line:no-any setTimeout() type differs on browser / node\n  private ownerLeaseRefreshHandle: any;\n  /** Our window.unload handler, if registered. */\n  private windowUnloadHandler: (() => void) | null;\n\n  private serializer: LocalSerializer;\n\n  constructor(prefix: string, serializer: JsonProtoSerializer) {\n    this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;\n    this.serializer = new LocalSerializer(serializer);\n    this.localStoragePrefix = prefix;\n  }\n\n  start(): Promise<void> {\n    if (!IndexedDbPersistence.isAvailable()) {\n      this.persistenceError = new FirestoreError(\n        Code.UNIMPLEMENTED,\n        UNSUPPORTED_PLATFORM_ERROR_MSG\n      );\n      return Promise.reject(this.persistenceError);\n    }\n\n    assert(!this.started, 'IndexedDbPersistence double-started!');\n    this.started = true;\n\n    return SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb)\n      .then(db => {\n        this.simpleDb = db;\n      })\n      .then(() => this.tryAcquireOwnerLease())\n      .then(() => {\n        this.scheduleOwnerLeaseRefreshes();\n        this.attachWindowUnloadHook();\n      });\n  }\n\n  shutdown(): Promise<void> {\n    assert(this.started, 'IndexedDbPersistence shutdown without start!');\n    this.started = false;\n    this.detachWindowUnloadHook();\n    this.stopOwnerLeaseRefreshes();\n    return this.releaseOwnerLease().then(() => {\n      this.simpleDb.close();\n    });\n  }\n\n  getMutationQueue(user: User): MutationQueue {\n    return IndexedDbMutationQueue.forUser(user, this.serializer);\n  }\n\n  getQueryCache(): QueryCache {\n    return new IndexedDbQueryCache(this.serializer);\n  }\n\n  getRemoteDocumentCache(): RemoteDocumentCache {\n    return new IndexedDbRemoteDocumentCache(this.serializer);\n  }\n\n  runTransaction<T>(\n    action: string,\n    operation: (transaction: SimpleDbTransaction) => PersistencePromise<T>\n  ): Promise<T> {\n    if (this.persistenceError) {\n      return Promise.reject(this.persistenceError);\n    }\n\n    log.debug(LOG_TAG, 'Starting transaction:', action);\n\n    // Do all transactions as readwrite against all object stores, since we\n    // are the only reader/writer.\n    return this.simpleDb.runTransaction('readwrite', ALL_STORES, txn => {\n      // Verify that we still have the owner lease as part of every transaction.\n      return this.ensureOwnerLease(txn).next(() => operation(txn));\n    });\n  }\n\n  static isAvailable(): boolean {\n    return SimpleDb.isAvailable();\n  }\n\n  /**\n   * Generates a string used as a prefix when storing data in IndexedDB and\n   * LocalStorage.\n   */\n  static buildStoragePrefix(databaseInfo: DatabaseInfo): string {\n    // Use two different prefix formats:\n    //\n    //   * firestore / persistenceKey / projectID . databaseID / ...\n    //   * firestore / persistenceKey / projectID / ...\n    //\n    // projectIDs are DNS-compatible names and cannot contain dots\n    // so there's no danger of collisions.\n    let database = databaseInfo.databaseId.projectId;\n    if (!databaseInfo.databaseId.isDefaultDatabase) {\n      database += '.' + databaseInfo.databaseId.database;\n    }\n\n    return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';\n  }\n\n  /**\n   * Acquires the owner lease if there's no valid owner. Else returns a rejected\n   * promise.\n   */\n  private tryAcquireOwnerLease(): Promise<void> {\n    // NOTE: Don't use this.runTransaction, since it requires us to already\n    // have the lease.\n    return this.simpleDb.runTransaction('readwrite', [DbOwner.store], txn => {\n      const store = txn.store<DbOwnerKey, DbOwner>(DbOwner.store);\n      return store.get('owner').next(dbOwner => {\n        if (!this.validOwner(dbOwner)) {\n          const newDbOwner = new DbOwner(this.ownerId, Date.now());\n          log.debug(\n            LOG_TAG,\n            'No valid owner. Acquiring owner lease. Current owner:',\n            dbOwner,\n            'New owner:',\n            newDbOwner\n          );\n          return store.put('owner', newDbOwner);\n        } else {\n          log.debug(\n            LOG_TAG,\n            'Valid owner already. Failing. Current owner:',\n            dbOwner\n          );\n          this.persistenceError = new FirestoreError(\n            Code.FAILED_PRECONDITION,\n            EXISTING_OWNER_ERROR_MSG\n          );\n          return PersistencePromise.reject<void>(this.persistenceError);\n        }\n      });\n    });\n  }\n\n  /** Checks the owner lease and deletes it if we are the current owner. */\n  private releaseOwnerLease(): Promise<void> {\n    // NOTE: Don't use this.runTransaction, since it requires us to already\n    // have the lease.\n    return this.simpleDb.runTransaction('readwrite', [DbOwner.store], txn => {\n      const store = txn.store<DbOwnerKey, DbOwner>(DbOwner.store);\n      return store.get('owner').next(dbOwner => {\n        if (dbOwner !== null && dbOwner.ownerId === this.ownerId) {\n          log.debug(LOG_TAG, 'Releasing owner lease.');\n          return store.delete('owner');\n        } else {\n          return PersistencePromise.resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Checks the owner lease and returns a rejected promise if we are not the\n   * current owner. This should be included in every transaction to guard\n   * against losing the owner lease.\n   */\n  private ensureOwnerLease(txn: SimpleDbTransaction): PersistencePromise<void> {\n    const store = txn.store<DbOwnerKey, DbOwner>(DbOwner.store);\n    return store.get('owner').next(dbOwner => {\n      if (dbOwner === null || dbOwner.ownerId !== this.ownerId) {\n        this.persistenceError = new FirestoreError(\n          Code.FAILED_PRECONDITION,\n          EXISTING_OWNER_ERROR_MSG\n        );\n        return PersistencePromise.reject<void>(this.persistenceError);\n      } else {\n        return PersistencePromise.resolve();\n      }\n    });\n  }\n\n  /**\n   * Returns true if the provided owner exists, has a recent timestamp, and\n   * isn't zombied.\n   *\n   * NOTE: To determine if the owner is zombied, this method reads from\n   * LocalStorage which could be mildly expensive.\n   */\n  private validOwner(dbOwner: DbOwner | null): boolean {\n    const now = Date.now();\n    const minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;\n    const maxAcceptable = now;\n    if (dbOwner === null) {\n      return false; // no owner.\n    } else if (dbOwner.leaseTimestampMs < minAcceptable) {\n      return false; // owner lease has expired.\n    } else if (dbOwner.leaseTimestampMs > maxAcceptable) {\n      log.error(\n        'Persistence owner-lease is in the future. Discarding.',\n        dbOwner\n      );\n      return false;\n    } else if (dbOwner.ownerId === this.getZombiedOwnerId()) {\n      return false; // owner's tab closed.\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Schedules a recurring timer to update the owner lease timestamp to prevent\n   * other tabs from taking the lease.\n   */\n  private scheduleOwnerLeaseRefreshes(): void {\n    // NOTE: This doesn't need to be scheduled on the async queue and doing so\n    // would increase the chances of us not refreshing on time if the queue is\n    // backed up for some reason.\n    this.ownerLeaseRefreshHandle = setInterval(() => {\n      const txResult = this.runTransaction('Refresh owner timestamp', txn => {\n        // NOTE: We don't need to validate the current owner contents, since\n        // runTransaction does that automatically.\n        const store = txn.store<DbOwnerKey, DbOwner>(DbOwner.store);\n        return store.put('owner', new DbOwner(this.ownerId, Date.now()));\n      });\n\n      txResult.catch(reason => {\n        // Probably means we lost the lease. Report the error and stop trying to\n        // refresh the lease.\n        log.error(reason);\n        this.stopOwnerLeaseRefreshes();\n      });\n    }, OWNER_LEASE_REFRESH_INTERVAL_MS);\n  }\n\n  private stopOwnerLeaseRefreshes(): void {\n    if (this.ownerLeaseRefreshHandle) {\n      clearInterval(this.ownerLeaseRefreshHandle);\n      this.ownerLeaseRefreshHandle = null;\n    }\n  }\n\n  /**\n   * Attaches a window.unload handler that will synchronously write our\n   * ownerId to a \"zombie owner id\" location in localstorage. This can be used\n   * by tabs trying to acquire the lease to determine that the lease should be\n   * acquired immediately even if the timestamp is recent. This is particularly\n   * important for the refresh case (so the tab correctly re-acquires the owner\n   * lease). LocalStorage is used for this rather than IndexedDb because it is\n   * a synchronous API and so can be used reliably from an unload handler.\n   */\n  private attachWindowUnloadHook(): void {\n    this.windowUnloadHandler = () => {\n      // Record that we're zombied.\n      this.setZombiedOwnerId(this.ownerId);\n\n      // Attempt graceful shutdown (including releasing our owner lease), but\n      // there's no guarantee it will complete.\n      this.shutdown();\n    };\n    window.addEventListener('unload', this.windowUnloadHandler);\n  }\n\n  private detachWindowUnloadHook(): void {\n    if (this.windowUnloadHandler) {\n      window.removeEventListener('unload', this.windowUnloadHandler);\n      this.windowUnloadHandler = null;\n    }\n  }\n\n  /**\n   * Returns any recorded \"zombied owner\" (i.e. a previous owner that became\n   * zombied due to their tab closing) from LocalStorage, or null if no such\n   * record exists.\n   */\n  private getZombiedOwnerId(): string | null {\n    try {\n      const zombiedOwnerId = window.localStorage.getItem(\n        this.zombiedOwnerLocalStorageKey()\n      );\n      log.debug(LOG_TAG, 'Zombied ownerID from LocalStorage:', zombiedOwnerId);\n      return zombiedOwnerId;\n    } catch (e) {\n      // Gracefully handle if LocalStorage isn't available / working.\n      log.error(LOG_TAG, 'Failed to get zombie owner id.', e);\n      return null;\n    }\n  }\n\n  /**\n   * Records a zombied owner (an owner that had its tab closed) in LocalStorage\n   * or, if passed null, deletes any recorded zombied owner.\n   */\n  private setZombiedOwnerId(zombieOwnerId: string | null) {\n    try {\n      if (zombieOwnerId === null) {\n        window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey());\n      } else {\n        window.localStorage.setItem(\n          this.zombiedOwnerLocalStorageKey(),\n          zombieOwnerId\n        );\n      }\n    } catch (e) {\n      // Gracefully handle if LocalStorage isn't available / working.\n      log.error(LOG_TAG, 'Failed to set zombie owner id.', e);\n    }\n  }\n\n  private zombiedOwnerLocalStorageKey(): string {\n    return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;\n  }\n\n  private generateOwnerId(): string {\n    // For convenience, just use an AutoId.\n    return AutoId.newId();\n  }\n}\n"]}