{"version":3,"sources":["src/firestore/local/local_documents_view.ts","firestore/local/local_documents_view.js"],"names":["LocalDocumentsView","remoteDocumentCache","mutationQueue","prototype","getDocument","transaction","key","_this","getEntry","next","remoteDoc","computeLocalDocument","getDocuments","keys","promises","results","forEach","push","maybeDoc","forDeletedDoc","insert","waitFor","getDocumentsMatchingQuery","query","isDocumentKey","path","getDocumentsMatchingDocumentQuery","getDocumentsMatchingCollectionQuery","docPath","result","queryResults","computeLocalDocuments","promisedResults","getAllMutationBatchesAffectingQuery","matchingMutationBatches","matchingKeys","_i","matchingMutationBatches_1","length","batch","_a","_b","mutations","mutation","get","add","doc","matches","remove","documentKey","document","getAllMutationBatchesAffectingDocumentKey","batches","batches_1","applyToLocalView","documents","mutatedDoc"],"mappings":"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","file":"local_documents_view.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  DocumentMap,\n  documentMap,\n  MaybeDocumentMap,\n  maybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { ResourcePath } from '../model/path';\nimport { fail } from '../util/assert';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nexport class LocalDocumentsView {\n  constructor(\n    private remoteDocumentCache: RemoteDocumentCache,\n    private mutationQueue: MutationQueue\n  ) {}\n\n  /**\n   * Get the local view of the document identified by `key`.\n   *\n   * @return Local view of the document or null if we don't have any cached\n   * state for it.\n   */\n  getDocument(\n    transaction: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    return this.remoteDocumentCache\n      .getEntry(transaction, key)\n      .next(remoteDoc => {\n        return this.computeLocalDocument(transaction, key, remoteDoc);\n      });\n  }\n\n  /**\n   * Gets the local view of the documents identified by `keys`.\n   *\n   * If we don't have cached state for a document in `keys`, a NoDocument will\n   * be stored for that key in the resulting set.\n   */\n  getDocuments(\n    transaction: PersistenceTransaction,\n    keys: DocumentKeySet\n  ): PersistencePromise<MaybeDocumentMap> {\n    const promises = [] as Array<PersistencePromise<void>>;\n    let results = maybeDocumentMap();\n    keys.forEach(key => {\n      promises.push(\n        this.getDocument(transaction, key).next(maybeDoc => {\n          // TODO(http://b/32275378): Don't conflate missing / deleted.\n          if (!maybeDoc) {\n            maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());\n          }\n          results = results.insert(key, maybeDoc);\n        })\n      );\n    });\n    return PersistencePromise.waitFor(promises).next(() => results);\n  }\n\n  /** Performs a query against the local view of all documents. */\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    if (DocumentKey.isDocumentKey(query.path)) {\n      return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n    } else {\n      return this.getDocumentsMatchingCollectionQuery(transaction, query);\n    }\n  }\n\n  private getDocumentsMatchingDocumentQuery(\n    transaction: PersistenceTransaction,\n    docPath: ResourcePath\n  ): PersistencePromise<DocumentMap> {\n    // Just do a simple document lookup.\n    return this.getDocument(\n      transaction,\n      new DocumentKey(docPath)\n    ).next(maybeDoc => {\n      let result = documentMap();\n      if (maybeDoc instanceof Document) {\n        result = result.insert(maybeDoc.key, maybeDoc);\n      }\n      return result;\n    });\n  }\n\n  private getDocumentsMatchingCollectionQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    // Query the remote documents and overlay mutations.\n    // TODO(mikelehen): There may be significant overlap between the mutations\n    // affecting these remote documents and the\n    // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n    let results: DocumentMap;\n    return this.remoteDocumentCache\n      .getDocumentsMatchingQuery(transaction, query)\n      .next(queryResults => {\n        return this.computeLocalDocuments(transaction, queryResults);\n      })\n      .next(promisedResults => {\n        results = promisedResults;\n        // Now use the mutation queue to discover any other documents that may\n        // match the query after applying mutations.\n        return this.mutationQueue.getAllMutationBatchesAffectingQuery(\n          transaction,\n          query\n        );\n      })\n      .next(matchingMutationBatches => {\n        let matchingKeys = documentKeySet();\n        for (const batch of matchingMutationBatches) {\n          for (const mutation of batch.mutations) {\n            // TODO(mikelehen): PERF: Check if this mutation actually\n            // affects the query to reduce work.\n            if (!results.get(mutation.key)) {\n              matchingKeys = matchingKeys.add(mutation.key);\n            }\n          }\n        }\n\n        // Now add in the results for the matchingKeys.\n        const promises = [] as Array<PersistencePromise<void>>;\n        matchingKeys.forEach(key => {\n          promises.push(\n            this.getDocument(transaction, key).next(doc => {\n              if (doc instanceof Document) {\n                results = results.insert(doc.key, doc);\n              }\n            })\n          );\n        });\n        return PersistencePromise.waitFor(promises);\n      })\n      .next(() => {\n        // Finally, filter out any documents that don't actually match\n        // the query.\n        results.forEach((key, doc) => {\n          if (!query.matches(doc)) {\n            results = results.remove(key);\n          }\n        });\n\n        return results;\n      });\n  }\n\n  /**\n   * Takes a remote document and applies local mutations to generate the local\n   * view of the document.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the document (necessary when remoteDocument\n   *     is null).\n   * @param document The base remote document to apply mutations to or null.\n   */\n  private computeLocalDocument(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey,\n    document: MaybeDocument | null\n  ): PersistencePromise<MaybeDocument | null> {\n    return this.mutationQueue\n      .getAllMutationBatchesAffectingDocumentKey(transaction, documentKey)\n      .next(batches => {\n        for (const batch of batches) {\n          document = batch.applyToLocalView(documentKey, document);\n        }\n        return document;\n      });\n  }\n\n  /**\n   * Takes a set of remote documents and applies local mutations to generate the\n   * local view of the documents.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documents The base remote documents to apply mutations to.\n   * @return The local view of the documents.\n   */\n  private computeLocalDocuments(\n    transaction: PersistenceTransaction,\n    documents: DocumentMap\n  ): PersistencePromise<DocumentMap> {\n    const promises = [] as Array<PersistencePromise<void>>;\n    documents.forEach((key, doc) => {\n      promises.push(\n        this.computeLocalDocument(transaction, key, doc).next(mutatedDoc => {\n          if (mutatedDoc instanceof Document) {\n            documents = documents.insert(mutatedDoc.key, mutatedDoc);\n          } else if (mutatedDoc instanceof NoDocument) {\n            documents = documents.remove(mutatedDoc.key);\n          } else {\n            fail('Unknown MaybeDocument: ' + mutatedDoc);\n          }\n        })\n      );\n    });\n    return PersistencePromise.waitFor(promises).next(() => documents);\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { documentKeySet, documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nvar LocalDocumentsView = /** @class */ (function () {\n    function LocalDocumentsView(remoteDocumentCache, mutationQueue) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @return Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    LocalDocumentsView.prototype.getDocument = function (transaction, key) {\n        var _this = this;\n        return this.remoteDocumentCache\n            .getEntry(transaction, key)\n            .next(function (remoteDoc) {\n            return _this.computeLocalDocument(transaction, key, remoteDoc);\n        });\n    };\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {\n        var _this = this;\n        var promises = [];\n        var results = maybeDocumentMap();\n        keys.forEach(function (key) {\n            promises.push(_this.getDocument(transaction, key).next(function (maybeDoc) {\n                // TODO(http://b/32275378): Don't conflate missing / deleted.\n                if (!maybeDoc) {\n                    maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());\n                }\n                results = results.insert(key, maybeDoc);\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(function () { return results; });\n    };\n    /** Performs a query against the local view of all documents. */\n    LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        if (DocumentKey.isDocumentKey(query.path)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query);\n        }\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(function (maybeDoc) {\n            var result = documentMap();\n            if (maybeDoc instanceof Document) {\n                result = result.insert(maybeDoc.key, maybeDoc);\n            }\n            return result;\n        });\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {\n        var _this = this;\n        // Query the remote documents and overlay mutations.\n        // TODO(mikelehen): There may be significant overlap between the mutations\n        // affecting these remote documents and the\n        // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n        var results;\n        return this.remoteDocumentCache\n            .getDocumentsMatchingQuery(transaction, query)\n            .next(function (queryResults) {\n            return _this.computeLocalDocuments(transaction, queryResults);\n        })\n            .next(function (promisedResults) {\n            results = promisedResults;\n            // Now use the mutation queue to discover any other documents that may\n            // match the query after applying mutations.\n            return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);\n        })\n            .next(function (matchingMutationBatches) {\n            var matchingKeys = documentKeySet();\n            for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {\n                var batch = matchingMutationBatches_1[_i];\n                for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                    var mutation = _b[_a];\n                    // TODO(mikelehen): PERF: Check if this mutation actually\n                    // affects the query to reduce work.\n                    if (!results.get(mutation.key)) {\n                        matchingKeys = matchingKeys.add(mutation.key);\n                    }\n                }\n            }\n            // Now add in the results for the matchingKeys.\n            var promises = [];\n            matchingKeys.forEach(function (key) {\n                promises.push(_this.getDocument(transaction, key).next(function (doc) {\n                    if (doc instanceof Document) {\n                        results = results.insert(doc.key, doc);\n                    }\n                }));\n            });\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            // Finally, filter out any documents that don't actually match\n            // the query.\n            results.forEach(function (key, doc) {\n                if (!query.matches(doc)) {\n                    results = results.remove(key);\n                }\n            });\n            return results;\n        });\n    };\n    /**\n     * Takes a remote document and applies local mutations to generate the local\n     * view of the document.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the document (necessary when remoteDocument\n     *     is null).\n     * @param document The base remote document to apply mutations to or null.\n     */\n    LocalDocumentsView.prototype.computeLocalDocument = function (transaction, documentKey, document) {\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKey(transaction, documentKey)\n            .next(function (batches) {\n            for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n                var batch = batches_1[_i];\n                document = batch.applyToLocalView(documentKey, document);\n            }\n            return document;\n        });\n    };\n    /**\n     * Takes a set of remote documents and applies local mutations to generate the\n     * local view of the documents.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documents The base remote documents to apply mutations to.\n     * @return The local view of the documents.\n     */\n    LocalDocumentsView.prototype.computeLocalDocuments = function (transaction, documents) {\n        var _this = this;\n        var promises = [];\n        documents.forEach(function (key, doc) {\n            promises.push(_this.computeLocalDocument(transaction, key, doc).next(function (mutatedDoc) {\n                if (mutatedDoc instanceof Document) {\n                    documents = documents.insert(mutatedDoc.key, mutatedDoc);\n                }\n                else if (mutatedDoc instanceof NoDocument) {\n                    documents = documents.remove(mutatedDoc.key);\n                }\n                else {\n                    fail('Unknown MaybeDocument: ' + mutatedDoc);\n                }\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(function () { return documents; });\n    };\n    return LocalDocumentsView;\n}());\nexport { LocalDocumentsView };\n\n\n"]}