{"version":3,"sources":["src/firestore/local/indexeddb_query_cache.ts","firestore/local/indexeddb_query_cache.js"],"names":["EncodedResourcePath","IndexedDbQueryCache","serializer","lastRemoteSnapshotVersion","MIN","metadata","toTimestamp","garbageCollector","prototype","start","transaction","_this","globalTargetStore","get","key","next","lastSavedVersion","fromTimestamp","seconds","nanos","resolve","getHighestTargetId","highestTargetId","getLastRemoteSnapshotVersion","setLastRemoteSnapshotVersion","snapshotVersion","put","addQueryData","queryData","targetId","addedQueryPromise","targetsStore","toDbTarget","removeQueryData","removeMatchingKeysForTargetId","delete","getQueryData","query","canonicalId","range","IDBKeyRange","bound","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","result","iterate","index","queryTargetsIndexName","value","control","found","fromDbTarget","equals","done","addMatchingKeys","txn","keys","promises","store","documentTargetStore","forEach","path","encode","push","waitFor","removeMatchingKeys","addPotentialGarbageKey","notifyGCForRemovedKeys","isEager","keysOnly","_","decode","docKey","getMatchingKeysForTargetId","add","setGarbageCollector","gc","containsKey","count","documentTargetsIndex","getStore"],"mappings":"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","file":"indexeddb_query_cache.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { TargetId } from '../core/types';\nimport { DocumentKeySet, documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert, fail } from '../util/assert';\nimport { immediateSuccessor } from '../util/misc';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { GarbageCollector } from './garbage_collector';\nimport {\n  DbQuery,\n  DbTarget,\n  DbTargetDocument,\n  DbTargetDocumentKey,\n  DbTargetGlobal,\n  DbTargetGlobalKey,\n  DbTargetKey,\n  DbTimestamp\n} from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { QueryData } from './query_data';\nimport { SimpleDbStore, SimpleDbTransaction } from './simple_db';\n\nexport class IndexedDbQueryCache implements QueryCache {\n  constructor(private serializer: LocalSerializer) {}\n\n  /**\n   * The last received snapshot version. We store this seperately from the\n   * metadata to avoid the extra conversion to/from DbTimestamp.\n   */\n  private lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n\n  /**\n   * A cached copy of the metadata for the query cache.\n   */\n  private metadata = new DbTargetGlobal(\n    /*highestTargetId=*/ 0,\n    /*lastListenSequenceNumber=*/ 0,\n    SnapshotVersion.MIN.toTimestamp()\n  );\n\n  /** The garbage collector to notify about potential garbage keys. */\n  private garbageCollector: GarbageCollector | null = null;\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    return globalTargetStore(transaction)\n      .get(DbTargetGlobal.key)\n      .next(metadata => {\n        if (metadata !== null) {\n          this.metadata = metadata;\n          const lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n          this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(\n            new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos)\n          );\n        }\n        return PersistencePromise.resolve();\n      });\n  }\n\n  getHighestTargetId(): TargetId {\n    return this.metadata.highestTargetId;\n  }\n\n  getLastRemoteSnapshotVersion(): SnapshotVersion {\n    return this.lastRemoteSnapshotVersion;\n  }\n\n  setLastRemoteSnapshotVersion(\n    transaction: PersistenceTransaction,\n    snapshotVersion: SnapshotVersion\n  ): PersistencePromise<void> {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n    return globalTargetStore(transaction).put(\n      DbTargetGlobal.key,\n      this.metadata\n    );\n  }\n\n  addQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    const targetId = queryData.targetId;\n    const addedQueryPromise = targetsStore(transaction).put(\n      this.serializer.toDbTarget(queryData)\n    );\n    if (targetId > this.metadata.highestTargetId) {\n      this.metadata.highestTargetId = targetId;\n      return addedQueryPromise.next(() =>\n        globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata)\n      );\n    } else {\n      return addedQueryPromise;\n    }\n  }\n\n  removeQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    return this.removeMatchingKeysForTargetId(\n      transaction,\n      queryData.targetId\n    ).next(() => {\n      targetsStore(transaction).delete(queryData.targetId);\n    });\n  }\n\n  getQueryData(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<QueryData | null> {\n    // Iterating by the canonicalId may yield more than one result because\n    // canonicalId values are not required to be unique per target. This query\n    // depends on the queryTargets index to be efficent.\n    const canonicalId = query.canonicalId();\n    const range = IDBKeyRange.bound(\n      [canonicalId, Number.NEGATIVE_INFINITY],\n      [canonicalId, Number.POSITIVE_INFINITY]\n    );\n    let result: QueryData | null = null;\n    return targetsStore(transaction)\n      .iterate(\n        { range, index: DbTarget.queryTargetsIndexName },\n        (key, value, control) => {\n          const found = this.serializer.fromDbTarget(value);\n          // After finding a potential match, check that the query is\n          // actually equal to the requested query.\n          if (query.equals(found.query)) {\n            result = found;\n            control.done();\n          }\n        }\n      )\n      .next(() => result);\n  }\n\n  addMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // Indexeddb.\n    const promises: Array<PersistencePromise<void>> = [];\n    const store = documentTargetStore(txn);\n    keys.forEach(key => {\n      const path = EncodedResourcePath.encode(key.path);\n      promises.push(store.put(new DbTargetDocument(targetId, path)));\n    });\n    return PersistencePromise.waitFor(promises);\n  }\n\n  removeMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // IndexedDb.\n    const promises: Array<PersistencePromise<void>> = [];\n    const store = documentTargetStore(txn);\n    keys.forEach(key => {\n      const path = EncodedResourcePath.encode(key.path);\n      promises.push(store.delete([targetId, path]));\n      if (this.garbageCollector !== null) {\n        this.garbageCollector.addPotentialGarbageKey(key);\n      }\n    });\n    return PersistencePromise.waitFor(promises);\n  }\n\n  removeMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    const store = documentTargetStore(txn);\n    const range = IDBKeyRange.bound(\n      [targetId],\n      [targetId + 1],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    return this.notifyGCForRemovedKeys(txn, range).next(() =>\n      store.delete(range)\n    );\n  }\n\n  private notifyGCForRemovedKeys(\n    txn: PersistenceTransaction,\n    range: IDBKeyRange\n  ): PersistencePromise<void> {\n    const store = documentTargetStore(txn);\n    if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n      // In order to generate garbage events properly, we need to read these\n      // keys before deleting.\n      return store.iterate({ range, keysOnly: true }, (key, _, control) => {\n        const path = EncodedResourcePath.decode(key[1]);\n        const docKey = new DocumentKey(path);\n        // Paranoid assertion in case the the collector is set to null\n        // during the iteration.\n        assert(\n          this.garbageCollector !== null,\n          'GarbageCollector for query cache set to null during key removal.'\n        );\n        this.garbageCollector!.addPotentialGarbageKey(docKey);\n      });\n    } else {\n      return PersistencePromise.resolve();\n    }\n  }\n\n  getMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<DocumentKeySet> {\n    const promises: Array<PersistencePromise<void>> = [];\n    const range = IDBKeyRange.bound(\n      [targetId],\n      [targetId + 1],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    const store = documentTargetStore(txn);\n    let result = documentKeySet();\n\n    return store\n      .iterate({ range, keysOnly: true }, (key, _, control) => {\n        const path = EncodedResourcePath.decode(key[1]);\n        const docKey = new DocumentKey(path);\n        result = result.add(docKey);\n      })\n      .next(() => result);\n  }\n\n  setGarbageCollector(gc: GarbageCollector | null): void {\n    this.garbageCollector = gc;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    assert(\n      txn !== null,\n      'Persistence Transaction cannot be null for query cache containsKey'\n    );\n    const path = EncodedResourcePath.encode(key.path);\n    const range = IDBKeyRange.bound(\n      [path],\n      [immediateSuccessor(path)],\n      /*lowerOpen=*/ false,\n      /*upperOpen=*/ true\n    );\n    let count = 0;\n    return documentTargetStore(txn!)\n      .iterate(\n        {\n          index: DbTargetDocument.documentTargetsIndex,\n          keysOnly: true,\n          range\n        },\n        (key, _, control) => {\n          count++;\n          control.done();\n        }\n      )\n      .next(() => count > 0);\n  }\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetKey, DbTarget> {\n  return getStore<DbTargetKey, DbTarget>(txn, DbTarget.store);\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetGlobalKey, DbTargetGlobal> {\n  return getStore<DbTargetGlobalKey, DbTargetGlobal>(txn, DbTargetGlobal.store);\n}\n\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(\n  txn: PersistenceTransaction\n): SimpleDbStore<DbTargetDocumentKey, DbTargetDocument> {\n  return getStore<DbTargetDocumentKey, DbTargetDocument>(\n    txn,\n    DbTargetDocument.store\n  );\n}\n\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore<KeyType extends IDBValidKey, ValueType>(\n  txn: PersistenceTransaction,\n  store: string\n): SimpleDbStore<KeyType, ValueType> {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store<KeyType, ValueType>(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert, fail } from '../util/assert';\nimport { immediateSuccessor } from '../util/misc';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbTarget, DbTargetDocument, DbTargetGlobal } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\nvar IndexedDbQueryCache = /** @class */ (function () {\n    function IndexedDbQueryCache(serializer) {\n        this.serializer = serializer;\n        /**\n         * The last received snapshot version. We store this seperately from the\n         * metadata to avoid the extra conversion to/from DbTimestamp.\n         */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n        /**\n         * A cached copy of the metadata for the query cache.\n         */\n        this.metadata = new DbTargetGlobal(\n        /*highestTargetId=*/ 0, \n        /*lastListenSequenceNumber=*/ 0, SnapshotVersion.MIN.toTimestamp());\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n    }\n    IndexedDbQueryCache.prototype.start = function (transaction) {\n        var _this = this;\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobal.key)\n            .next(function (metadata) {\n            if (metadata !== null) {\n                _this.metadata = metadata;\n                var lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n                _this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));\n            }\n            return PersistencePromise.resolve();\n        });\n    };\n    IndexedDbQueryCache.prototype.getHighestTargetId = function () {\n        return this.metadata.highestTargetId;\n    };\n    IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n    };\n    IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        var _this = this;\n        var targetId = queryData.targetId;\n        var addedQueryPromise = targetsStore(transaction).put(this.serializer.toDbTarget(queryData));\n        if (targetId > this.metadata.highestTargetId) {\n            this.metadata.highestTargetId = targetId;\n            return addedQueryPromise.next(function () {\n                return globalTargetStore(transaction).put(DbTargetGlobal.key, _this.metadata);\n            });\n        }\n        else {\n            return addedQueryPromise;\n        }\n    };\n    IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function () {\n            targetsStore(transaction).delete(queryData.targetId);\n        });\n    };\n    IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {\n        var _this = this;\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficent.\n        var canonicalId = query.canonicalId();\n        var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        var result = null;\n        return targetsStore(transaction)\n            .iterate({ range: range, index: DbTarget.queryTargetsIndexName }, function (key, value, control) {\n            var found = _this.serializer.fromDbTarget(value);\n            // After finding a potential match, check that the query is\n            // actually equal to the requested query.\n            if (query.equals(found.query)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // Indexeddb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = EncodedResourcePath.encode(key.path);\n            promises.push(store.put(new DbTargetDocument(targetId, path)));\n        });\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        var _this = this;\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = EncodedResourcePath.encode(key.path);\n            promises.push(store.delete([targetId, path]));\n            if (_this.garbageCollector !== null) {\n                _this.garbageCollector.addPotentialGarbageKey(key);\n            }\n        });\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        var store = documentTargetStore(txn);\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return this.notifyGCForRemovedKeys(txn, range).next(function () {\n            return store.delete(range);\n        });\n    };\n    IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) {\n        var _this = this;\n        var store = documentTargetStore(txn);\n        if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n            // In order to generate garbage events properly, we need to read these\n            // keys before deleting.\n            return store.iterate({ range: range, keysOnly: true }, function (key, _, control) {\n                var path = EncodedResourcePath.decode(key[1]);\n                var docKey = new DocumentKey(path);\n                // Paranoid assertion in case the the collector is set to null\n                // during the iteration.\n                assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');\n                _this.garbageCollector.addPotentialGarbageKey(docKey);\n            });\n        }\n        else {\n            return PersistencePromise.resolve();\n        }\n    };\n    IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var promises = [];\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var store = documentTargetStore(txn);\n        var result = documentKeySet();\n        return store\n            .iterate({ range: range, keysOnly: true }, function (key, _, control) {\n            var path = EncodedResourcePath.decode(key[1]);\n            var docKey = new DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbQueryCache.prototype.containsKey = function (txn, key) {\n        assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');\n        var path = EncodedResourcePath.encode(key.path);\n        var range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocument.documentTargetsIndex,\n            keysOnly: true,\n            range: range\n        }, function (key, _, control) {\n            count++;\n            control.done();\n        })\n            .next(function () { return count > 0; });\n    };\n    return IndexedDbQueryCache;\n}());\nexport { IndexedDbQueryCache };\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return getStore(txn, DbTarget.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return getStore(txn, DbTargetGlobal.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return getStore(txn, DbTargetDocument.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore(txn, store) {\n    if (txn instanceof SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n\n"]}