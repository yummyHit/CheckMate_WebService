{"version":3,"sources":["src/firestore/local/reference_set.ts","firestore/local/reference_set.js"],"names":["ReferenceSet","refsByKey","DocReference","compareByKey","refsByTarget","compareByTargetId","garbageCollector","prototype","isEmpty","addReference","key","id","ref","add","addReferences","keys","_this","forEach","removeReference","removeRef","removeReferences","removeReferencesForId","emptyKey","EMPTY","startRef","endRef","forEachInRange","removeAllReferences","delete","addPotentialGarbageKey","referencesForId","setGarbageCollector","containsKey","txn","firstRef","firstAfterOrEqual","resolve","equals","targetOrBatchId","left","right","comparator"],"mappings":"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","file":"reference_set.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BatchId, TargetId } from '../core/types';\nimport { documentKeySet, DocumentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { GarbageSource } from './garbage_source';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\n\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nexport class ReferenceSet implements GarbageSource {\n  // A set of outstanding references to a document sorted by key.\n  private refsByKey = new SortedSet(DocReference.compareByKey);\n\n  // A set of outstanding references to a document sorted by target id.\n  private refsByTarget = new SortedSet(DocReference.compareByTargetId);\n\n  /** Keeps track of keys that have references */\n  private garbageCollector: GarbageCollector | null = null;\n\n  /** Returns true if the reference set contains no references. */\n  isEmpty(): boolean {\n    return this.refsByKey.isEmpty();\n  }\n\n  /** Adds a reference to the given document key for the given ID. */\n  addReference(key: DocumentKey, id: TargetId | BatchId): void {\n    const ref = new DocReference(key, id);\n    this.refsByKey = this.refsByKey.add(ref);\n    this.refsByTarget = this.refsByTarget.add(ref);\n  }\n\n  /** Add references to the given document keys for the given ID. */\n  addReferences(keys: DocumentKeySet, id: TargetId | BatchId): void {\n    keys.forEach(key => this.addReference(key, id));\n  }\n\n  /**\n   * Removes a reference to the given document key for the given\n   * ID.\n   */\n  removeReference(key: DocumentKey, id: TargetId | BatchId): void {\n    this.removeRef(new DocReference(key, id));\n  }\n\n  removeReferences(keys: DocumentKeySet, id: TargetId | BatchId): void {\n    keys.forEach(key => this.removeReference(key, id));\n  }\n\n  /**\n   * Clears all references with a given ID. Calls removeRef() for each key\n   * removed.\n   */\n  removeReferencesForId(id: TargetId | BatchId): void {\n    const emptyKey = DocumentKey.EMPTY;\n    const startRef = new DocReference(emptyKey, id);\n    const endRef = new DocReference(emptyKey, id + 1);\n    this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n      this.removeRef(ref);\n    });\n  }\n\n  removeAllReferences(): void {\n    this.refsByKey.forEach(ref => this.removeRef(ref));\n  }\n\n  private removeRef(ref: DocReference): void {\n    this.refsByKey = this.refsByKey.delete(ref);\n    this.refsByTarget = this.refsByTarget.delete(ref);\n    if (this.garbageCollector !== null) {\n      this.garbageCollector.addPotentialGarbageKey(ref.key);\n    }\n  }\n\n  referencesForId(id: TargetId | BatchId): DocumentKeySet {\n    const emptyKey = DocumentKey.EMPTY;\n    const startRef = new DocReference(emptyKey, id);\n    const endRef = new DocReference(emptyKey, id + 1);\n    let keys = documentKeySet();\n    this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n      keys = keys.add(ref.key);\n    });\n    return keys;\n  }\n\n  setGarbageCollector(garbageCollector: GarbageCollector | null): void {\n    this.garbageCollector = garbageCollector;\n  }\n\n  containsKey(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const ref = new DocReference(key, 0);\n    const firstRef = this.refsByKey.firstAfterOrEqual(ref);\n    return PersistencePromise.resolve(\n      firstRef !== null && key.equals(firstRef.key)\n    );\n  }\n}\n\nexport class DocReference {\n  constructor(\n    public key: DocumentKey,\n    public targetOrBatchId: TargetId | BatchId\n  ) {}\n\n  /** Compare by key then by ID */\n  static compareByKey(left: DocReference, right: DocReference): number {\n    return (\n      DocumentKey.comparator(left.key, right.key) ||\n      primitiveComparator(left.targetOrBatchId, right.targetOrBatchId)\n    );\n  }\n\n  /** Compare by ID then by key */\n  static compareByTargetId(left: DocReference, right: DocReference): number {\n    return (\n      primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n      DocumentKey.comparator(left.key, right.key)\n    );\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nvar ReferenceSet = /** @class */ (function () {\n    function ReferenceSet() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\n        /** Keeps track of keys that have references */\n        this.garbageCollector = null;\n    }\n    /** Returns true if the reference set contains no references. */\n    ReferenceSet.prototype.isEmpty = function () {\n        return this.refsByKey.isEmpty();\n    };\n    /** Adds a reference to the given document key for the given ID. */\n    ReferenceSet.prototype.addReference = function (key, id) {\n        var ref = new DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    };\n    /** Add references to the given document keys for the given ID. */\n    ReferenceSet.prototype.addReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.addReference(key, id); });\n    };\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    ReferenceSet.prototype.removeReference = function (key, id) {\n        this.removeRef(new DocReference(key, id));\n    };\n    ReferenceSet.prototype.removeReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.removeReference(key, id); });\n    };\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    ReferenceSet.prototype.removeReferencesForId = function (id) {\n        var _this = this;\n        var emptyKey = DocumentKey.EMPTY;\n        var startRef = new DocReference(emptyKey, id);\n        var endRef = new DocReference(emptyKey, id + 1);\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            _this.removeRef(ref);\n        });\n    };\n    ReferenceSet.prototype.removeAllReferences = function () {\n        var _this = this;\n        this.refsByKey.forEach(function (ref) { return _this.removeRef(ref); });\n    };\n    ReferenceSet.prototype.removeRef = function (ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n        if (this.garbageCollector !== null) {\n            this.garbageCollector.addPotentialGarbageKey(ref.key);\n        }\n    };\n    ReferenceSet.prototype.referencesForId = function (id) {\n        var emptyKey = DocumentKey.EMPTY;\n        var startRef = new DocReference(emptyKey, id);\n        var endRef = new DocReference(emptyKey, id + 1);\n        var keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    };\n    ReferenceSet.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    ReferenceSet.prototype.containsKey = function (txn, key) {\n        var ref = new DocReference(key, 0);\n        var firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(firstRef !== null && key.equals(firstRef.key));\n    };\n    return ReferenceSet;\n}());\nexport { ReferenceSet };\nvar DocReference = /** @class */ (function () {\n    function DocReference(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    DocReference.compareByKey = function (left, right) {\n        return (DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    };\n    /** Compare by ID then by key */\n    DocReference.compareByTargetId = function (left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            DocumentKey.comparator(left.key, right.key));\n    };\n    return DocReference;\n}());\nexport { DocReference };\n\n\n"]}