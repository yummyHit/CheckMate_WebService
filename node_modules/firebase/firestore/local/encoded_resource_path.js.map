{"version":3,"sources":["src/firestore/local/encoded_resource_path.ts"],"names":["encode","decode","prefixSuccessor","escapeChar","encodedSeparatorChar","encodedNul","encodedEscape","path","result","i","length","encodeSeparator","encodeSegment","get","segment","resultBuf","c","charAt","EMPTY_PATH","lastReasonableEscapeIndex","segments","segmentBuilder","start","end","indexOf","next","currentPiece","substring","push","charCodeAt","String","fromCharCode"],"mappings":"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","file":"encoded_resource_path.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\n\n/**\n * Helpers for dealing with resource paths stored in IndexedDB.\n *\n * Resource paths in their canonical string form do not sort as the server\n * sorts them. Specifically the server splits paths into segments first and then\n * sorts, putting end-of-segment before any character. In a UTF-8 string\n * encoding the slash ('/') that denotes the end-of-segment naturally comes\n * after other characters so the intent here is to encode the path delimiters in\n * such a way that the resulting strings sort naturally.\n *\n * Resource paths are also used for prefix scans so it's important to\n * distinguish whole segments from any longer segments of which they might be a\n * prefix. For example, it's important to make it possible to scan documents in\n * a collection \"foo\" without encountering documents in a collection \"foobar\".\n *\n * Separate from the concerns about resource path ordering and separation,\n * On Android, SQLite imposes additional restrictions since it does not handle\n * keys with embedded NUL bytes particularly well. Rather than change the\n * implementation we keep the encoding identical to keep the ports similar.\n *\n * Taken together this means resource paths when encoded for storage in\n * IndexedDB have the following characteristics:\n *\n *   * Segment separators (\"/\") sort before everything else.\n *   * All paths have a trailing separator.\n *   * NUL bytes do not exist in the output, since IndexedDB doesn't treat them\n * well.\n *\n * Therefore resource paths are encoded into string form using the following\n * rules:\n *\n *   * '\\x01' is used as an escape character.\n *   * Path separators are encoded as \"\\x01\\x01\"\n *   * NUL bytes are encoded as \"\\x01\\x10\"\n *   * '\\x01' is encoded as \"\\x01\\x11\"\n *\n * This encoding leaves some room between path separators and the NUL byte\n * just in case we decide to support integer document ids after all.\n *\n * Note that characters treated specially by the backend ('.', '/', and '~')\n * are not treated specially here. This class assumes that any unescaping of\n * resource path strings into actual ResourcePath objects will handle these\n * characters there.\n */\nexport type EncodedResourcePath = string;\n\nconst escapeChar = '\\u0001';\nconst encodedSeparatorChar = '\\u0001';\nconst encodedNul = '\\u0010';\nconst encodedEscape = '\\u0011';\n\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nexport function encode(path: ResourcePath): EncodedResourcePath {\n  let result = '';\n  for (let i = 0; i < path.length; i++) {\n    if (result.length > 0) {\n      result = encodeSeparator(result);\n    }\n    result = encodeSegment(path.get(i), result);\n  }\n  return encodeSeparator(result);\n}\n\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment: string, resultBuf: string) {\n  let result = resultBuf;\n  const length = segment.length;\n  for (let i = 0; i < length; i++) {\n    const c = segment.charAt(i);\n    switch (c) {\n      case '\\0':\n        result += escapeChar + encodedNul;\n        break;\n      case escapeChar:\n        result += escapeChar + encodedEscape;\n        break;\n      default:\n        result += c;\n    }\n  }\n  return result;\n}\n\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result: string): string {\n  return result + escapeChar + encodedSeparatorChar;\n}\n\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nexport function decode(path: EncodedResourcePath): ResourcePath {\n  // Event the empty path must encode as a path of at least length 2. A path\n  // with exactly 2 must be the empty path.\n  const length = path.length;\n  assert(length >= 2, 'Invalid path ' + path);\n  if (length === 2) {\n    assert(\n      path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar,\n      'Non-empty path ' + path + ' had length 2'\n    );\n    return ResourcePath.EMPTY_PATH;\n  }\n\n  // Escape characters cannot exist past the second-to-last position in the\n  // source value.\n  const lastReasonableEscapeIndex = length - 2;\n\n  const segments: string[] = [];\n  let segmentBuilder = '';\n\n  for (let start = 0; start < length; ) {\n    // The last two characters of a valid encoded path must be a separator, so\n    // there must be an end to this segment.\n    const end = path.indexOf(escapeChar, start);\n    if (end < 0 || end > lastReasonableEscapeIndex) {\n      fail('Invalid encoded resource path: \"' + path + '\"');\n    }\n\n    const next = path.charAt(end + 1);\n    switch (next) {\n      case encodedSeparatorChar:\n        const currentPiece = path.substring(start, end);\n        let segment;\n        if (segmentBuilder.length === 0) {\n          // Avoid copying for the common case of a segment that excludes \\0\n          // and \\001\n          segment = currentPiece;\n        } else {\n          segmentBuilder += currentPiece;\n          segment = segmentBuilder;\n          segmentBuilder = '';\n        }\n        segments.push(segment);\n        break;\n      case encodedNul:\n        segmentBuilder += path.substring(start, end);\n        segmentBuilder += '\\0';\n        break;\n      case encodedEscape:\n        // The escape character can be used in the output to encode itself.\n        segmentBuilder += path.substring(start, end + 1);\n        break;\n      default:\n        fail('Invalid encoded resource path: \"' + path + '\"');\n    }\n\n    start = end + 2;\n  }\n\n  return new ResourcePath(segments);\n}\n\n/**\n * Computes the prefix successor of the given path, computed by encode above.\n * A prefix successor is the first key that cannot be prefixed by the given\n * path. It's useful for defining the end of a prefix scan such that all keys\n * in the scan have the same prefix.\n *\n * Note that this is not a general prefix successor implementation, which is\n * tricky to get right with Strings, given that they encode down to UTF-8.\n * Instead this relies on the fact that all paths encoded by this class are\n * always terminated with a separator, and so a successor can always be\n * cheaply computed by incrementing the last character of the path.\n */\nexport function prefixSuccessor(path: EncodedResourcePath) {\n  const c = path.charCodeAt(path.length - 1);\n  // TODO(mcg): this really should be a general thing, but not worth it right\n  // now\n  assert(c === 1, 'successor may only operate on paths generated by encode');\n  return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);\n}\n"]}