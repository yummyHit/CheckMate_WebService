{"version":3,"sources":["src/firestore/local/local_serializer.ts","firestore/local/local_serializer.js"],"names":["LocalSerializer","remoteSerializer","prototype","fromDbRemoteDocument","remoteDoc","document","fromDocument","noDocument","key","fromSegments","path","readTime","timestamp","seconds","nanos","fromTimestamp","toDbRemoteDocument","maybeDoc","doc","toDocument","toArray","version","toTimestamp","toDbMutationBatch","userId","batch","_this","serializedMutations","mutations","map","m","toMutation","batchId","localWriteTime","toEpochMilliseconds","fromDbMutationBatch","dbBatch","fromMutation","fromEpochMilliseconds","localWriteTimeMs","fromDbTarget","dbTarget","query","isDocumentQuery","fromDocumentsTarget","fromQueryTarget","targetId","Listen","resumeToken","toDbTarget","queryData","purpose","snapshotVersion","dbTimestamp","queryProto","toDocumentsTarget","toQueryTarget","canonicalId","dbQuery","documents","undefined"],"mappings":";;;;;;;AAkBA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;;AAQA;;AAEA;AApCA;;;;;;;;;;;;;;;AAqCA,IAAAA,kBAAA,aAAA,YAAA;AACE,aAAAA,eAAA,CAAoBC,gBAApB,EAAyD;AAArC,aAAAA,gBAAA,GAAAA,gBAAA;AAAyC;AAE7D;AACAD,oBAAAE,SAAA,CAAAC,oBAAA,GAAA,UAAqBC,SAArB,EAAgD;AAC9C,YAAIA,UAAUC,QAAd,EAAwB;AACtB,mBAAO,KAAKJ,gBAAL,CAAsBK,YAAtB,CAAmCF,UAAUC,QAA7C,CAAP;AACD,SAFD,MAEO,IAAID,UAAUG,UAAd,EAA0B;AAC/B,gBAAMC,MAAM,0BAAYC,YAAZ,CAAyBL,UAAUG,UAAV,CAAqBG,IAA9C,CAAZ;AACA,gBAAMC,WAAWP,UAAUG,UAAV,CAAqBI,QAAtC;AACA,gBAAMC,YAAY,yBAAcD,SAASE,OAAvB,EAAgCF,SAASG,KAAzC,CAAlB;AACA,mBAAO,yBAAeN,GAAf,EAAoB,kCAAgBO,aAAhB,CAA8BH,SAA9B,CAApB,CAAP;AACD,SALM,MAKA;AACL,mBAAO,kBAAK,6BAAL,CAAP;AACD;AACF,KAXD;AAaA;AACAZ,oBAAAE,SAAA,CAAAc,kBAAA,GAAA,UAAmBC,QAAnB,EAA0C;AACxC,YAAIA,sCAAJ,EAAkC;AAChC,gBAAMC,MAAM,KAAKjB,gBAAL,CAAsBkB,UAAtB,CAAiCF,QAAjC,CAAZ;AACA,mBAAO,uCAAqB,IAArB,EAA2BC,GAA3B,CAAP;AACD,SAHD,MAGO;AACL,gBAAMR,OAAOO,SAAST,GAAT,CAAaE,IAAb,CAAkBU,OAAlB,EAAb;AACA,gBAAMR,YAAYK,SAASI,OAAT,CAAiBC,WAAjB,EAAlB;AACA,gBAAMX,WAAW,kCAAgBC,UAAUC,OAA1B,EAAmCD,UAAUE,KAA7C,CAAjB;AACA,mBAAO,uCAAqB,mCAAiBJ,IAAjB,EAAuBC,QAAvB,CAArB,EAAuD,IAAvD,CAAP;AACD;AACF,KAVD;AAYA;AACAX,oBAAAE,SAAA,CAAAqB,iBAAA,GAAA,UAAkBC,MAAlB,EAAkCC,KAAlC,EAAsD;AAAtD,YAAAC,QAAA,IAAA;AACE,YAAMC,sBAAsBF,MAAMG,SAAN,CAAgBC,GAAhB,CAAoB,UAAAC,CAAA,EAAC;AAC/C,mBAAAJ,MAAKzB,gBAAL,CAAsB8B,UAAtB,CAAiCD,CAAjC,CAAA;AAAmC,SADT,CAA5B;AAGA,eAAO,sCACLN,MADK,EAELC,MAAMO,OAFD,EAGLP,MAAMQ,cAAN,CAAqBC,mBAArB,EAHK,EAILP,mBAJK,CAAP;AAMD,KAVD;AAYA;AACA3B,oBAAAE,SAAA,CAAAiC,mBAAA,GAAA,UAAoBC,OAApB,EAA4C;AAA5C,YAAAV,QAAA,IAAA;AACE,YAAME,YAAYQ,QAAQR,SAAR,CAAkBC,GAAlB,CAAsB,UAAAC,CAAA,EAAC;AACvC,mBAAAJ,MAAKzB,gBAAL,CAAsBoC,YAAtB,CAAmCP,CAAnC,CAAA;AAAqC,SADrB,CAAlB;AAGA,YAAMlB,YAAY,qBAAU0B,qBAAV,CAAgCF,QAAQG,gBAAxC,CAAlB;AACA,eAAO,kCAAkBH,QAAQJ,OAA1B,EAAmCpB,SAAnC,EAA8CgB,SAA9C,CAAP;AACD,KAND;AAQA;AACA5B,oBAAAE,SAAA,CAAAsC,YAAA,GAAA,UAAaC,QAAb,EAA+B;AAC7B,YAAM9B,WAAW,yBACf8B,SAAS9B,QAAT,CAAkBE,OADH,EAEf4B,SAAS9B,QAAT,CAAkBG,KAFH,CAAjB;AAIA,YAAMO,UAAU,kCAAgBN,aAAhB,CAA8BJ,QAA9B,CAAhB;AACA,YAAI+B,KAAJ;AACA,YAAIC,gBAAgBF,SAASC,KAAzB,CAAJ,EAAqC;AACnCA,oBAAQ,KAAKzC,gBAAL,CAAsB2C,mBAAtB,CAA0CH,SAASC,KAAnD,CAAR;AACD,SAFD,MAEO;AACLA,oBAAQ,KAAKzC,gBAAL,CAAsB4C,eAAtB,CAAsCJ,SAASC,KAA/C,CAAR;AACD;AACD,eAAO,0BACLA,KADK,EAELD,SAASK,QAFJ,EAGL,yBAAaC,MAHR,EAIL1B,OAJK,EAKLoB,SAASO,WALJ,CAAP;AAOD,KAnBD;AAqBA;AACAhD,oBAAAE,SAAA,CAAA+C,UAAA,GAAA,UAAWC,SAAX,EAA+B;AAC7B,4BACE,yBAAaH,MAAb,KAAwBG,UAAUC,OADpC,EAEE,+BACE,yBAAaJ,MADf,GAEE,sBAFF,GAGEG,UAAUC,OALd;AAOA,YAAMvC,YAAYsC,UAAUE,eAAV,CAA0B9B,WAA1B,EAAlB;AACA,YAAM+B,cAAc,kCAAgBzC,UAAUC,OAA1B,EAAmCD,UAAUE,KAA7C,CAApB;AACA,YAAIwC,UAAJ;AACA,YAAIJ,UAAUR,KAAV,CAAgBC,eAAhB,EAAJ,EAAuC;AACrCW,yBAAa,KAAKrD,gBAAL,CAAsBsD,iBAAtB,CAAwCL,UAAUR,KAAlD,CAAb;AACD,SAFD,MAEO;AACLY,yBAAa,KAAKrD,gBAAL,CAAsBuD,aAAtB,CAAoCN,UAAUR,KAA9C,CAAb;AACD;AACD,4BACE,OAAOQ,UAAUF,WAAjB,KAAiC,QADnC,EAEE,mDAFF;AAIA,YAAMA,cAAcE,UAAUF,WAA9B;AAEA;AACA,eAAO,+BACLE,UAAUJ,QADL,EAELI,UAAUR,KAAV,CAAgBe,WAAhB,EAFK,EAGLJ,WAHK,EAILL,WAJK,EAKL,CALK,EAMLM,UANK,CAAP;AAQD,KA/BD;AAgCF,WAAAtD,eAAA;AA3GA,CAAA,EAAA;QCuESA,e,GAAAA,e;ADsCT;;;;AAGA,SAAA2C,eAAA,CAAyBe,OAAzB,EAAyC;AACvC,WAAQA,QAAgCC,SAAhC,KAA8CC,SAAtD;AACD","file":"local_serializer.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationBatch } from '../model/mutation_batch';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { assert, fail } from '../util/assert';\n\nimport {\n  DbMutationBatch,\n  DbNoDocument,\n  DbQuery,\n  DbRemoteDocument,\n  DbTarget,\n  DbTimestamp\n} from './indexeddb_schema';\nimport { QueryData, QueryPurpose } from './query_data';\n\n/** Serializer for values stored in the LocalStore. */\nexport class LocalSerializer {\n  constructor(private remoteSerializer: JsonProtoSerializer) {}\n\n  /** Decodes a remote document from storage locally to a Document. */\n  fromDbRemoteDocument(remoteDoc: DbRemoteDocument): MaybeDocument {\n    if (remoteDoc.document) {\n      return this.remoteSerializer.fromDocument(remoteDoc.document);\n    } else if (remoteDoc.noDocument) {\n      const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n      const readTime = remoteDoc.noDocument.readTime;\n      const timestamp = new Timestamp(readTime.seconds, readTime.nanos);\n      return new NoDocument(key, SnapshotVersion.fromTimestamp(timestamp));\n    } else {\n      return fail('Unexpected DbRemoteDocument');\n    }\n  }\n\n  /** Encodes a document for storage locally. */\n  toDbRemoteDocument(maybeDoc: MaybeDocument): DbRemoteDocument {\n    if (maybeDoc instanceof Document) {\n      const doc = this.remoteSerializer.toDocument(maybeDoc);\n      return new DbRemoteDocument(null, doc);\n    } else {\n      const path = maybeDoc.key.path.toArray();\n      const timestamp = maybeDoc.version.toTimestamp();\n      const readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n      return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n    }\n  }\n\n  /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n  toDbMutationBatch(userId: string, batch: MutationBatch): DbMutationBatch {\n    const serializedMutations = batch.mutations.map(m =>\n      this.remoteSerializer.toMutation(m)\n    );\n    return new DbMutationBatch(\n      userId,\n      batch.batchId,\n      batch.localWriteTime.toEpochMilliseconds(),\n      serializedMutations\n    );\n  }\n\n  /** Decodes a DbMutationBatch into a MutationBatch */\n  fromDbMutationBatch(dbBatch: DbMutationBatch): MutationBatch {\n    const mutations = dbBatch.mutations.map(m =>\n      this.remoteSerializer.fromMutation(m)\n    );\n    const timestamp = Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n    return new MutationBatch(dbBatch.batchId, timestamp, mutations);\n  }\n\n  /** Decodes a DbTarget into QueryData */\n  fromDbTarget(dbTarget: DbTarget): QueryData {\n    const readTime = new Timestamp(\n      dbTarget.readTime.seconds,\n      dbTarget.readTime.nanos\n    );\n    const version = SnapshotVersion.fromTimestamp(readTime);\n    let query: Query;\n    if (isDocumentQuery(dbTarget.query)) {\n      query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n    } else {\n      query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n    }\n    return new QueryData(\n      query,\n      dbTarget.targetId,\n      QueryPurpose.Listen,\n      version,\n      dbTarget.resumeToken\n    );\n  }\n\n  /** Encodes QueryData into a DbTarget for storage locally. */\n  toDbTarget(queryData: QueryData): DbTarget {\n    assert(\n      QueryPurpose.Listen === queryData.purpose,\n      'Only queries with purpose ' +\n        QueryPurpose.Listen +\n        ' may be stored, got ' +\n        queryData.purpose\n    );\n    const timestamp = queryData.snapshotVersion.toTimestamp();\n    const dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n    let queryProto: DbQuery;\n    if (queryData.query.isDocumentQuery()) {\n      queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n    } else {\n      queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n    }\n    assert(\n      typeof queryData.resumeToken === 'string',\n      'Persisting non-string resume token not supported.'\n    );\n    const resumeToken = queryData.resumeToken as string;\n\n    // lastListenSequenceNumber is always 0 until we do real GC.\n    return new DbTarget(\n      queryData.targetId,\n      queryData.query.canonicalId(),\n      dbTimestamp,\n      resumeToken,\n      0,\n      queryProto\n    );\n  }\n}\n\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery: DbQuery): dbQuery is api.DocumentsTarget {\n  return (dbQuery as api.DocumentsTarget).documents !== undefined;\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { DbMutationBatch, DbNoDocument, DbRemoteDocument, DbTarget, DbTimestamp } from './indexeddb_schema';\nimport { QueryData, QueryPurpose } from './query_data';\n/** Serializer for values stored in the LocalStore. */\nvar LocalSerializer = /** @class */ (function () {\n    function LocalSerializer(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n    /** Decodes a remote document from storage locally to a Document. */\n    LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {\n        if (remoteDoc.document) {\n            return this.remoteSerializer.fromDocument(remoteDoc.document);\n        }\n        else if (remoteDoc.noDocument) {\n            var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n            var readTime = remoteDoc.noDocument.readTime;\n            var timestamp = new Timestamp(readTime.seconds, readTime.nanos);\n            return new NoDocument(key, SnapshotVersion.fromTimestamp(timestamp));\n        }\n        else {\n            return fail('Unexpected DbRemoteDocument');\n        }\n    };\n    /** Encodes a document for storage locally. */\n    LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {\n        if (maybeDoc instanceof Document) {\n            var doc = this.remoteSerializer.toDocument(maybeDoc);\n            return new DbRemoteDocument(null, doc);\n        }\n        else {\n            var path = maybeDoc.key.path.toArray();\n            var timestamp = maybeDoc.version.toTimestamp();\n            var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n            return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n        }\n    };\n    /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n    LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {\n        var _this = this;\n        var serializedMutations = batch.mutations.map(function (m) {\n            return _this.remoteSerializer.toMutation(m);\n        });\n        return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);\n    };\n    /** Decodes a DbMutationBatch into a MutationBatch */\n    LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {\n        var _this = this;\n        var mutations = dbBatch.mutations.map(function (m) {\n            return _this.remoteSerializer.fromMutation(m);\n        });\n        var timestamp = Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n        return new MutationBatch(dbBatch.batchId, timestamp, mutations);\n    };\n    /** Decodes a DbTarget into QueryData */\n    LocalSerializer.prototype.fromDbTarget = function (dbTarget) {\n        var readTime = new Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);\n        var version = SnapshotVersion.fromTimestamp(readTime);\n        var query;\n        if (isDocumentQuery(dbTarget.query)) {\n            query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n        }\n        else {\n            query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n        }\n        return new QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);\n    };\n    /** Encodes QueryData into a DbTarget for storage locally. */\n    LocalSerializer.prototype.toDbTarget = function (queryData) {\n        assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' +\n            QueryPurpose.Listen +\n            ' may be stored, got ' +\n            queryData.purpose);\n        var timestamp = queryData.snapshotVersion.toTimestamp();\n        var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n        var queryProto;\n        if (queryData.query.isDocumentQuery()) {\n            queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n        }\n        else {\n            queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n        }\n        assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');\n        var resumeToken = queryData.resumeToken;\n        // lastListenSequenceNumber is always 0 until we do real GC.\n        return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);\n    };\n    return LocalSerializer;\n}());\nexport { LocalSerializer };\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n\n\n"]}