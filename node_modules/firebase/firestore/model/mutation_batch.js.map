{"version":3,"sources":["src/firestore/model/mutation_batch.ts","firestore/model/mutation_batch.js"],"names":["misc","BATCHID_UNKNOWN","MutationBatch","batchId","localWriteTime","mutations","prototype","applyToRemoteDocument","docKey","maybeDoc","batchResult","key","equals","mutationResults","length","i","mutation","mutationResult","applyToLocalView","keys","keySet","_i","_a","add","other","arrayEquals","isTombstone","toTombstone","MutationBatchResult","batch","commitVersion","streamToken","docVersions","from","results","versionMap","version","insert"],"mappings":"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","file":"mutation_batch.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { BatchId, ProtoByteString } from '../core/types';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  DocumentVersionMap,\n  documentVersionMap\n} from './collections';\nimport { MaybeDocument } from './document';\nimport { DocumentKey } from './document_key';\nimport { Mutation, MutationResult } from './mutation';\nimport { assert } from '../util/assert';\nimport * as misc from '../util/misc';\n\nexport const BATCHID_UNKNOWN = -1;\n\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nexport class MutationBatch {\n  constructor(\n    public batchId: BatchId,\n    public localWriteTime: Timestamp,\n    public mutations: Mutation[]\n  ) {}\n\n  /**\n   * Applies all the mutations in this MutationBatch to the specified document\n   * to create a new remote document\n   *\n   * @param docKey The key of the document to apply mutations to.\n   * @param maybeDoc The document to apply mutations to.\n   * @param batchResult The result of applying the MutationBatch to the\n   * backend.\n   */\n  applyToRemoteDocument(\n    docKey: DocumentKey,\n    maybeDoc: MaybeDocument | null,\n    batchResult: MutationBatchResult\n  ): MaybeDocument | null {\n    if (maybeDoc) {\n      assert(\n        maybeDoc.key.equals(docKey),\n        `applyToRemoteDocument: key ${docKey} should match maybeDoc key\n        ${maybeDoc.key}`\n      );\n    }\n\n    const mutationResults = batchResult.mutationResults;\n    assert(\n      mutationResults.length === this.mutations.length,\n      `Mismatch between mutations length\n      (${this.mutations.length}) and mutation results length\n      (${mutationResults.length}).`\n    );\n\n    for (let i = 0; i < this.mutations.length; i++) {\n      const mutation = this.mutations[i];\n      if (mutation.key.equals(docKey)) {\n        const mutationResult = mutationResults[i];\n        maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n      }\n    }\n    return maybeDoc;\n  }\n\n  /**\n   * Computes the local view of a document given all the mutations in this\n   * batch.\n   *\n   * @param docKey The key of the document to apply mutations to.\n   * @param maybeDoc The document to apply mutations to.\n   */\n  applyToLocalView(\n    docKey: DocumentKey,\n    maybeDoc: MaybeDocument | null\n  ): MaybeDocument | null {\n    if (maybeDoc) {\n      assert(\n        maybeDoc.key.equals(docKey),\n        `applyToLocalDocument: key ${docKey} should match maybeDoc key\n        ${maybeDoc.key}`\n      );\n    }\n\n    for (let i = 0; i < this.mutations.length; i++) {\n      const mutation = this.mutations[i];\n      if (mutation.key.equals(docKey)) {\n        maybeDoc = mutation.applyToLocalView(maybeDoc, this.localWriteTime);\n      }\n    }\n    return maybeDoc;\n  }\n\n  keys(): DocumentKeySet {\n    let keySet = documentKeySet();\n\n    for (const mutation of this.mutations) {\n      keySet = keySet.add(mutation.key);\n    }\n    return keySet;\n  }\n\n  equals(other: MutationBatch): boolean {\n    return (\n      this.batchId === other.batchId &&\n      misc.arrayEquals(this.mutations, other.mutations)\n    );\n  }\n\n  /**\n   * Returns true if this mutation batch has already been removed from the\n   * mutation queue.\n   *\n   * Note that not all implementations of the MutationQueue necessarily use\n   * tombstones as part of their implementation and generally speaking no code\n   * outside the mutation queues should really care about this.\n   */\n  isTombstone(): boolean {\n    return this.mutations.length === 0;\n  }\n\n  /** Converts this batch into a tombstone */\n  toTombstone(): MutationBatch {\n    return new MutationBatch(this.batchId, this.localWriteTime, []);\n  }\n}\n\n/** The result of applying a mutation batch to the backend. */\nexport class MutationBatchResult {\n  private constructor(\n    readonly batch: MutationBatch,\n    readonly commitVersion: SnapshotVersion,\n    readonly mutationResults: MutationResult[],\n    readonly streamToken: ProtoByteString,\n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    readonly docVersions: DocumentVersionMap\n  ) {}\n\n  /**\n   * Creates a new MutationBatchResult for the given batch and results. There\n   * must be one result for each mutation in the batch. This static factory\n   * caches a document=>version mapping (docVersions).\n   */\n  static from(\n    batch: MutationBatch,\n    commitVersion: SnapshotVersion,\n    results: MutationResult[],\n    streamToken: ProtoByteString\n  ) {\n    assert(\n      batch.mutations.length === results.length,\n      'Mutations sent ' +\n        batch.mutations.length +\n        ' must equal results received ' +\n        results.length\n    );\n\n    let versionMap = documentVersionMap();\n    const mutations = batch.mutations;\n    for (let i = 0; i < mutations.length; i++) {\n      let version = results[i].version;\n      if (version === null) {\n        // deletes don't have a version, so we substitute the commitVersion\n        // of the entire batch.\n        version = commitVersion;\n      }\n\n      versionMap = versionMap.insert(mutations[i].key, version);\n    }\n\n    return new MutationBatchResult(\n      batch,\n      commitVersion,\n      results,\n      streamToken,\n      versionMap\n    );\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet, documentVersionMap } from './collections';\nimport { assert } from '../util/assert';\nimport * as misc from '../util/misc';\nexport var BATCHID_UNKNOWN = -1;\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nvar MutationBatch = /** @class */ (function () {\n    function MutationBatch(batchId, localWriteTime, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to create a new remote document\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     * @param batchResult The result of applying the MutationBatch to the\n     * backend.\n     */\n    MutationBatch.prototype.applyToRemoteDocument = function (docKey, maybeDoc, batchResult) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(docKey), \"applyToRemoteDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        var mutationResults = batchResult.mutationResults;\n        assert(mutationResults.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + mutationResults.length + \").\");\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.equals(docKey)) {\n                var mutationResult = mutationResults[i];\n                maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n            }\n        }\n        return maybeDoc;\n    };\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     */\n    MutationBatch.prototype.applyToLocalView = function (docKey, maybeDoc) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(docKey), \"applyToLocalDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.equals(docKey)) {\n                maybeDoc = mutation.applyToLocalView(maybeDoc, this.localWriteTime);\n            }\n        }\n        return maybeDoc;\n    };\n    MutationBatch.prototype.keys = function () {\n        var keySet = documentKeySet();\n        for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {\n            var mutation = _a[_i];\n            keySet = keySet.add(mutation.key);\n        }\n        return keySet;\n    };\n    MutationBatch.prototype.equals = function (other) {\n        return (this.batchId === other.batchId &&\n            misc.arrayEquals(this.mutations, other.mutations));\n    };\n    /**\n     * Returns true if this mutation batch has already been removed from the\n     * mutation queue.\n     *\n     * Note that not all implementations of the MutationQueue necessarily use\n     * tombstones as part of their implementation and generally speaking no code\n     * outside the mutation queues should really care about this.\n     */\n    MutationBatch.prototype.isTombstone = function () {\n        return this.mutations.length === 0;\n    };\n    /** Converts this batch into a tombstone */\n    MutationBatch.prototype.toTombstone = function () {\n        return new MutationBatch(this.batchId, this.localWriteTime, []);\n    };\n    return MutationBatch;\n}());\nexport { MutationBatch };\n/** The result of applying a mutation batch to the backend. */\nvar MutationBatchResult = /** @class */ (function () {\n    function MutationBatchResult(batch, commitVersion, mutationResults, streamToken, \n        /**\n         * A pre-computed mapping from each mutated document to the resulting\n         * version.\n         */\n        docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.streamToken = streamToken;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=>version mapping (docVersions).\n     */\n    MutationBatchResult.from = function (batch, commitVersion, results, streamToken) {\n        assert(batch.mutations.length === results.length, 'Mutations sent ' +\n            batch.mutations.length +\n            ' must equal results received ' +\n            results.length);\n        var versionMap = documentVersionMap();\n        var mutations = batch.mutations;\n        for (var i = 0; i < mutations.length; i++) {\n            var version = results[i].version;\n            if (version === null) {\n                // deletes don't have a version, so we substitute the commitVersion\n                // of the entire batch.\n                version = commitVersion;\n            }\n            versionMap = versionMap.insert(mutations[i].key, version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);\n    };\n    return MutationBatchResult;\n}());\nexport { MutationBatchResult };\n\n\n"]}