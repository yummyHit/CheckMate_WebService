{"version":3,"sources":["src/firestore/model/mutation.ts","firestore/model/mutation.js"],"names":["misc","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","FieldMask","fields","equals","other","arrayEquals","ServerTimestampTransform","instance","FieldTransform","field","transform","MutationResult","version","transformResults","MutationType","Precondition","updateTime","exists","undefined","defineProperty","get","enumerable","configurable","isValidFor","maybeDoc","isNone","NONE","Mutation","verifyKeyMatches","key","getPostMutationVersion","MIN","SetMutation","_super","value","precondition","_this","call","type","Set","applyToRemoteDocument","mutationResult","hasLocalMutations","applyToLocalView","localWriteTime","PatchMutation","data","fieldMask","Patch","newData","patchDocument","EMPTY","patchObject","_i","_a","length","fieldPath","newValue","set","delete","TransformMutation","fieldTransforms","Transform","doc","requireDocument","transformObject","localTransformResults","fieldTransform","push","i","DeleteMutation","Delete","forDeletedDoc"],"mappings":"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","file":"mutation.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { assert, fail } from '../util/assert';\nimport * as misc from '../util/misc';\n\nimport { Document, MaybeDocument, NoDocument } from './document';\nimport { DocumentKey } from './document_key';\nimport { FieldValue, ObjectValue, ServerTimestampValue } from './field_value';\nimport { FieldPath } from './path';\n\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nexport class FieldMask {\n  constructor(readonly fields: FieldPath[]) {\n    // TODO(dimond): validation of FieldMask\n  }\n\n  equals(other: FieldMask): boolean {\n    return misc.arrayEquals(this.fields, other.fields);\n  }\n}\n\n/** Represents a transform within a TransformMutation. */\nexport interface TransformOperation {\n  equals(other: TransformOperation): boolean;\n}\n\n/** Transforms a value into a server-generated timestamp. */\nexport class ServerTimestampTransform implements TransformOperation {\n  private constructor() {}\n  static instance = new ServerTimestampTransform();\n\n  equals(other: TransformOperation): boolean {\n    return other instanceof ServerTimestampTransform;\n  }\n}\n\n/** A field path and the TransformOperation to perform upon it. */\nexport class FieldTransform {\n  constructor(\n    readonly field: FieldPath,\n    readonly transform: TransformOperation\n  ) {}\n\n  equals(other: FieldTransform): boolean {\n    return (\n      this.field.equals(other.field) && this.transform.equals(other.transform)\n    );\n  }\n}\n\n/** The result of successfully applying a mutation to the backend. */\nexport class MutationResult {\n  constructor(\n    /**\n       * The version at which the mutation was committed or null for a delete.\n       */\n    readonly version: SnapshotVersion | null,\n    /**\n       * The resulting fields returned from the backend after a\n       * TransformMutation has been committed. Contains one FieldValue for each\n       * FieldTransform that was in the mutation.\n       *\n       * Will be null if the mutation was not a TransformMutation.\n       */\n    readonly transformResults: FieldValue[] | null\n  ) {}\n}\n\nexport enum MutationType {\n  Set,\n  Patch,\n  Transform,\n  Delete\n}\n\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nexport class Precondition {\n  static readonly NONE = new Precondition();\n\n  private constructor(\n    public readonly updateTime?: SnapshotVersion,\n    public readonly exists?: boolean\n  ) {\n    assert(\n      updateTime === undefined || exists === undefined,\n      'Precondition can specify \"exists\" or \"updateTime\" but not both'\n    );\n  }\n\n  /** Creates a new Precondition with an exists flag. */\n  static exists(exists: boolean) {\n    return new Precondition(undefined, exists);\n  }\n\n  /** Creates a new Precondition based on a version a document exists at. */\n  static updateTime(version: SnapshotVersion) {\n    return new Precondition(version);\n  }\n\n  /** Returns whether this Precondition is empty. */\n  get isNone(): boolean {\n    return this.updateTime === undefined && this.exists === undefined;\n  }\n\n  /**\n   * Returns true if the preconditions is valid for the given document\n   * (or null if no document is available).\n   */\n  isValidFor(maybeDoc: MaybeDocument | null) {\n    if (this.updateTime !== undefined) {\n      return (\n        maybeDoc instanceof Document && maybeDoc.version.equals(this.updateTime)\n      );\n    } else if (this.exists !== undefined) {\n      if (this.exists) {\n        return maybeDoc instanceof Document;\n      } else {\n        return maybeDoc === null || maybeDoc instanceof NoDocument;\n      }\n    } else {\n      assert(this.isNone, 'Precondition should be empty');\n      return true;\n    }\n  }\n\n  equals(other: Precondition) {\n    return (\n      misc.equals(this.updateTime, other.updateTime) &&\n      this.exists === other.exists\n    );\n  }\n}\n\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nexport abstract class Mutation {\n  readonly type: MutationType;\n  readonly key: DocumentKey;\n  readonly precondition: Precondition;\n\n  /**\n   * Applies this mutation to the given MaybeDocument or null for the purposes\n   * of computing a new remote document. Both the input and returned documents\n   * can be null.\n   *\n   * @param maybeDoc The document to mutate. The input document can be null if\n   *     the client has no knowledge of the pre-mutation state of the document.\n   * @param mutationResult The result of applying the mutation from the backend.\n   * @return The mutated document. The returned document may be null, but only\n   *     if maybeDoc was null and the mutation would not create a new document.\n   */\n  abstract applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null;\n\n  /**\n   * Applies this mutation to the given MaybeDocument or null for the purposes\n   * of computing the new local view of a document. Both the input and returned\n   * documents can be null.\n   *\n   * @param maybeDoc The document to mutate. The input document can be null if\n   *     the client has no knowledge of the pre-mutation state of the document.\n   * @param localWriteTime A timestamp indicating the local write time of the\n   *     batch this mutation is a part of.\n   * @return The mutated document. The returned document may be null, but only\n   *     if maybeDoc was null and the mutation would not create a new document.\n   */\n  abstract applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null;\n\n  abstract equals(other: Mutation): boolean;\n\n  protected verifyKeyMatches(maybeDoc: MaybeDocument | null): void {\n    if (maybeDoc != null) {\n      assert(\n        maybeDoc.key.equals(this.key),\n        'Can only apply a mutation to a document with the same key'\n      );\n    }\n  }\n\n  /**\n   * Returns the version from the given document for use as the result of a\n   * mutation. Mutations are defined to return the version of the base document\n   * only if it is an existing document. Deleted and unknown documents have a\n   * post-mutation version of SnapshotVersion.MIN.\n   */\n  protected static getPostMutationVersion(\n    maybeDoc: MaybeDocument | null\n  ): SnapshotVersion {\n    if (maybeDoc instanceof Document) {\n      return maybeDoc.version;\n    } else {\n      return SnapshotVersion.MIN;\n    }\n  }\n}\n\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nexport class SetMutation extends Mutation {\n  constructor(\n    readonly key: DocumentKey,\n    readonly value: ObjectValue,\n    readonly precondition: Precondition\n  ) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Set;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by SetMutation.'\n    );\n\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof SetMutation &&\n      this.key.equals(other.key) &&\n      this.value.equals(other.value) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n}\n\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nexport class PatchMutation extends Mutation {\n  constructor(\n    readonly key: DocumentKey,\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask,\n    readonly precondition: Precondition\n  ) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Patch;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by PatchMutation.'\n    );\n\n    // TODO(mcg): Relax enforcement of this precondition\n    //\n    // We shouldn't actually enforce the precondition since it already passed on\n    // the backend, but we may not have a local version of the document to\n    // patch, so we use the precondition to prevent incorrectly putting a\n    // partial document into our cache.\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    const newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    const newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof PatchMutation &&\n      this.key.equals(other.key) &&\n      this.fieldMask.equals(other.fieldMask) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n\n  /**\n   * Patches the data of document if available or creates a new document. Note\n   * that this does not check whether or not the precondition of this patch\n   * holds.\n   */\n  private patchDocument(maybeDoc: MaybeDocument | null): ObjectValue {\n    let data: ObjectValue;\n    if (maybeDoc instanceof Document) {\n      data = maybeDoc.data;\n    } else {\n      data = ObjectValue.EMPTY;\n    }\n    return this.patchObject(data);\n  }\n\n  private patchObject(data: ObjectValue): ObjectValue {\n    for (const fieldPath of this.fieldMask.fields) {\n      const newValue = this.data.field(fieldPath);\n      if (newValue !== undefined) {\n        data = data.set(fieldPath, newValue);\n      } else {\n        data = data.delete(fieldPath);\n      }\n    }\n    return data;\n  }\n}\n\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nexport class TransformMutation extends Mutation {\n  readonly type: MutationType = MutationType.Transform;\n\n  // NOTE: We set a precondition of exists: true as a safety-check, since we\n  // always combine TransformMutations with a SetMutation or PatchMutation which\n  // (if successful) should end up with an existing document.\n  readonly precondition = Precondition.exists(true);\n\n  constructor(\n    readonly key: DocumentKey,\n    readonly fieldTransforms: FieldTransform[]\n  ) {\n    super();\n  }\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults != null,\n      'Transform results missing for TransformMutation.'\n    );\n    const transformResults = mutationResult.transformResults!;\n\n    // TODO(mcg): Relax enforcement of this precondition\n    //\n    // We shouldn't actually enforce the precondition since it already passed on\n    // the backend, but we may not have a local version of the document to\n    // patch, so we use the precondition to prevent incorrectly putting a\n    // partial document into our cache.\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const doc = this.requireDocument(maybeDoc);\n    const newData = this.transformObject(doc.data, transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: false\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const doc = this.requireDocument(maybeDoc);\n    const transformResults = this.localTransformResults(localWriteTime);\n    const newData = this.transformObject(doc.data, transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: true\n    });\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof TransformMutation &&\n      this.key.equals(other.key) &&\n      misc.arrayEquals(this.fieldTransforms, other.fieldTransforms) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n\n  /**\n   * Asserts that the given MaybeDocument is actually a Document and verifies\n   * that it matches the key for this mutation. Since we only support\n   * transformations with precondition exists this method is guaranteed to be\n   * safe.\n   */\n  private requireDocument(maybeDoc: MaybeDocument | null): Document {\n    assert(\n      maybeDoc instanceof Document,\n      'Unknown MaybeDocument type ' + maybeDoc\n    );\n    const doc = maybeDoc! as Document;\n    assert(\n      doc.key.equals(this.key),\n      'Can only transform a document with the same key'\n    );\n    return doc;\n  }\n\n  /**\n   * Creates a list of \"transform results\" (a transform result is a field value\n   * representing the result of applying a transform) for use when applying a\n   * TransformMutation locally.\n   *\n   * @param localWriteTime The local time of the transform mutation (used to\n   *     generate ServerTimestampValues).\n   * @return The transform results list.\n   */\n  private localTransformResults(localWriteTime: Timestamp): FieldValue[] {\n    const transformResults = [] as FieldValue[];\n    for (const fieldTransform of this.fieldTransforms) {\n      const transform = fieldTransform.transform;\n      if (transform instanceof ServerTimestampTransform) {\n        transformResults.push(new ServerTimestampValue(localWriteTime));\n      } else {\n        return fail('Encountered unknown transform: ' + transform);\n      }\n    }\n    return transformResults;\n  }\n\n  private transformObject(\n    data: ObjectValue,\n    transformResults: FieldValue[]\n  ): ObjectValue {\n    assert(\n      transformResults.length === this.fieldTransforms.length,\n      'TransformResults length mismatch.'\n    );\n\n    for (let i = 0; i < this.fieldTransforms.length; i++) {\n      const fieldTransform = this.fieldTransforms[i];\n      const transform = fieldTransform.transform;\n      const fieldPath = fieldTransform.field;\n      if (transform instanceof ServerTimestampTransform) {\n        data = data.set(fieldPath, transformResults[i]);\n      } else {\n        return fail('Encountered unknown transform: ' + transform);\n      }\n    }\n    return data;\n  }\n}\n\n/** A mutation that deletes the document at the given key. */\nexport class DeleteMutation extends Mutation {\n  constructor(readonly key: DocumentKey, readonly precondition: Precondition) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Delete;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    assert(\n      mutationResult.transformResults == null,\n      'Transform results received by DeleteMutation.'\n    );\n\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    return new NoDocument(this.key, SnapshotVersion.MIN);\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    if (maybeDoc) {\n      assert(\n        maybeDoc.key.equals(this.key),\n        'Can only apply mutation to document with same key'\n      );\n    }\n    return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());\n  }\n\n  equals(other: Mutation): boolean {\n    return (\n      other instanceof DeleteMutation &&\n      this.key.equals(other.key) &&\n      this.precondition.equals(other.precondition)\n    );\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { assert, fail } from '../util/assert';\nimport * as misc from '../util/misc';\nimport { Document, NoDocument } from './document';\nimport { ObjectValue, ServerTimestampValue } from './field_value';\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nvar FieldMask = /** @class */ (function () {\n    function FieldMask(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n    }\n    FieldMask.prototype.equals = function (other) {\n        return misc.arrayEquals(this.fields, other.fields);\n    };\n    return FieldMask;\n}());\nexport { FieldMask };\n/** Transforms a value into a server-generated timestamp. */\nvar ServerTimestampTransform = /** @class */ (function () {\n    function ServerTimestampTransform() {\n    }\n    ServerTimestampTransform.prototype.equals = function (other) {\n        return other instanceof ServerTimestampTransform;\n    };\n    ServerTimestampTransform.instance = new ServerTimestampTransform();\n    return ServerTimestampTransform;\n}());\nexport { ServerTimestampTransform };\n/** A field path and the TransformOperation to perform upon it. */\nvar FieldTransform = /** @class */ (function () {\n    function FieldTransform(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n    FieldTransform.prototype.equals = function (other) {\n        return (this.field.equals(other.field) && this.transform.equals(other.transform));\n    };\n    return FieldTransform;\n}());\nexport { FieldTransform };\n/** The result of successfully applying a mutation to the backend. */\nvar MutationResult = /** @class */ (function () {\n    function MutationResult(\n        /**\n           * The version at which the mutation was committed or null for a delete.\n           */\n        version, \n        /**\n           * The resulting fields returned from the backend after a\n           * TransformMutation has been committed. Contains one FieldValue for each\n           * FieldTransform that was in the mutation.\n           *\n           * Will be null if the mutation was not a TransformMutation.\n           */\n        transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n    return MutationResult;\n}());\nexport { MutationResult };\nexport var MutationType;\n(function (MutationType) {\n    MutationType[MutationType[\"Set\"] = 0] = \"Set\";\n    MutationType[MutationType[\"Patch\"] = 1] = \"Patch\";\n    MutationType[MutationType[\"Transform\"] = 2] = \"Transform\";\n    MutationType[MutationType[\"Delete\"] = 3] = \"Delete\";\n})(MutationType || (MutationType = {}));\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nvar Precondition = /** @class */ (function () {\n    function Precondition(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n        assert(updateTime === undefined || exists === undefined, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n    }\n    /** Creates a new Precondition with an exists flag. */\n    Precondition.exists = function (exists) {\n        return new Precondition(undefined, exists);\n    };\n    /** Creates a new Precondition based on a version a document exists at. */\n    Precondition.updateTime = function (version) {\n        return new Precondition(version);\n    };\n    Object.defineProperty(Precondition.prototype, \"isNone\", {\n        /** Returns whether this Precondition is empty. */\n        get: function () {\n            return this.updateTime === undefined && this.exists === undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns true if the preconditions is valid for the given document\n     * (or null if no document is available).\n     */\n    Precondition.prototype.isValidFor = function (maybeDoc) {\n        if (this.updateTime !== undefined) {\n            return (maybeDoc instanceof Document && maybeDoc.version.equals(this.updateTime));\n        }\n        else if (this.exists !== undefined) {\n            if (this.exists) {\n                return maybeDoc instanceof Document;\n            }\n            else {\n                return maybeDoc === null || maybeDoc instanceof NoDocument;\n            }\n        }\n        else {\n            assert(this.isNone, 'Precondition should be empty');\n            return true;\n        }\n    };\n    Precondition.prototype.equals = function (other) {\n        return (misc.equals(this.updateTime, other.updateTime) &&\n            this.exists === other.exists);\n    };\n    Precondition.NONE = new Precondition();\n    return Precondition;\n}());\nexport { Precondition };\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nvar Mutation = /** @class */ (function () {\n    function Mutation() {\n    }\n    Mutation.prototype.verifyKeyMatches = function (maybeDoc) {\n        if (maybeDoc != null) {\n            assert(maybeDoc.key.equals(this.key), 'Can only apply a mutation to a document with the same key');\n        }\n    };\n    /**\n     * Returns the version from the given document for use as the result of a\n     * mutation. Mutations are defined to return the version of the base document\n     * only if it is an existing document. Deleted and unknown documents have a\n     * post-mutation version of SnapshotVersion.MIN.\n     */\n    Mutation.getPostMutationVersion = function (maybeDoc) {\n        if (maybeDoc instanceof Document) {\n            return maybeDoc.version;\n        }\n        else {\n            return SnapshotVersion.MIN;\n        }\n    };\n    return Mutation;\n}());\nexport { Mutation };\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nvar SetMutation = /** @class */ (function (_super) {\n    __extends(SetMutation, _super);\n    function SetMutation(key, value, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.value = value;\n        _this.precondition = precondition;\n        _this.type = MutationType.Set;\n        return _this;\n    }\n    SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        return new Document(this.key, version, this.value, {\n            hasLocalMutations: false\n        });\n    };\n    SetMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        return new Document(this.key, version, this.value, {\n            hasLocalMutations: true\n        });\n    };\n    SetMutation.prototype.equals = function (other) {\n        return (other instanceof SetMutation &&\n            this.key.equals(other.key) &&\n            this.value.equals(other.value) &&\n            this.precondition.equals(other.precondition));\n    };\n    return SetMutation;\n}(Mutation));\nexport { SetMutation };\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nvar PatchMutation = /** @class */ (function (_super) {\n    __extends(PatchMutation, _super);\n    function PatchMutation(key, data, fieldMask, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.data = data;\n        _this.fieldMask = fieldMask;\n        _this.precondition = precondition;\n        _this.type = MutationType.Patch;\n        return _this;\n    }\n    PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.');\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new Document(this.key, version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    PatchMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new Document(this.key, version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    PatchMutation.prototype.equals = function (other) {\n        return (other instanceof PatchMutation &&\n            this.key.equals(other.key) &&\n            this.fieldMask.equals(other.fieldMask) &&\n            this.precondition.equals(other.precondition));\n    };\n    /**\n     * Patches the data of document if available or creates a new document. Note\n     * that this does not check whether or not the precondition of this patch\n     * holds.\n     */\n    PatchMutation.prototype.patchDocument = function (maybeDoc) {\n        var data;\n        if (maybeDoc instanceof Document) {\n            data = maybeDoc.data;\n        }\n        else {\n            data = ObjectValue.EMPTY;\n        }\n        return this.patchObject(data);\n    };\n    PatchMutation.prototype.patchObject = function (data) {\n        for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {\n            var fieldPath = _a[_i];\n            var newValue = this.data.field(fieldPath);\n            if (newValue !== undefined) {\n                data = data.set(fieldPath, newValue);\n            }\n            else {\n                data = data.delete(fieldPath);\n            }\n        }\n        return data;\n    };\n    return PatchMutation;\n}(Mutation));\nexport { PatchMutation };\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nvar TransformMutation = /** @class */ (function (_super) {\n    __extends(TransformMutation, _super);\n    function TransformMutation(key, fieldTransforms) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.fieldTransforms = fieldTransforms;\n        _this.type = MutationType.Transform;\n        // NOTE: We set a precondition of exists: true as a safety-check, since we\n        // always combine TransformMutations with a SetMutation or PatchMutation which\n        // (if successful) should end up with an existing document.\n        _this.precondition = Precondition.exists(true);\n        return _this;\n    }\n    TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');\n        var transformResults = mutationResult.transformResults;\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new Document(this.key, doc.version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    TransformMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var transformResults = this.localTransformResults(localWriteTime);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new Document(this.key, doc.version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    TransformMutation.prototype.equals = function (other) {\n        return (other instanceof TransformMutation &&\n            this.key.equals(other.key) &&\n            misc.arrayEquals(this.fieldTransforms, other.fieldTransforms) &&\n            this.precondition.equals(other.precondition));\n    };\n    /**\n     * Asserts that the given MaybeDocument is actually a Document and verifies\n     * that it matches the key for this mutation. Since we only support\n     * transformations with precondition exists this method is guaranteed to be\n     * safe.\n     */\n    TransformMutation.prototype.requireDocument = function (maybeDoc) {\n        assert(maybeDoc instanceof Document, 'Unknown MaybeDocument type ' + maybeDoc);\n        var doc = maybeDoc;\n        assert(doc.key.equals(this.key), 'Can only transform a document with the same key');\n        return doc;\n    };\n    /**\n     * Creates a list of \"transform results\" (a transform result is a field value\n     * representing the result of applying a transform) for use when applying a\n     * TransformMutation locally.\n     *\n     * @param localWriteTime The local time of the transform mutation (used to\n     *     generate ServerTimestampValues).\n     * @return The transform results list.\n     */\n    TransformMutation.prototype.localTransformResults = function (localWriteTime) {\n        var transformResults = [];\n        for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {\n            var fieldTransform = _a[_i];\n            var transform = fieldTransform.transform;\n            if (transform instanceof ServerTimestampTransform) {\n                transformResults.push(new ServerTimestampValue(localWriteTime));\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return transformResults;\n    };\n    TransformMutation.prototype.transformObject = function (data, transformResults) {\n        assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');\n        for (var i = 0; i < this.fieldTransforms.length; i++) {\n            var fieldTransform = this.fieldTransforms[i];\n            var transform = fieldTransform.transform;\n            var fieldPath = fieldTransform.field;\n            if (transform instanceof ServerTimestampTransform) {\n                data = data.set(fieldPath, transformResults[i]);\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return data;\n    };\n    return TransformMutation;\n}(Mutation));\nexport { TransformMutation };\n/** A mutation that deletes the document at the given key. */\nvar DeleteMutation = /** @class */ (function (_super) {\n    __extends(DeleteMutation, _super);\n    function DeleteMutation(key, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.precondition = precondition;\n        _this.type = MutationType.Delete;\n        return _this;\n    }\n    DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        return new NoDocument(this.key, SnapshotVersion.MIN);\n    };\n    DeleteMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(this.key), 'Can only apply mutation to document with same key');\n        }\n        return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());\n    };\n    DeleteMutation.prototype.equals = function (other) {\n        return (other instanceof DeleteMutation &&\n            this.key.equals(other.key) &&\n            this.precondition.equals(other.precondition));\n    };\n    return DeleteMutation;\n}(Mutation));\nexport { DeleteMutation };\n\n\n"]}