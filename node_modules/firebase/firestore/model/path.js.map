{"version":3,"sources":["src/firestore/model/path.ts","firestore/model/path.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","DOCUMENT_KEY_NAME","Path","segments","offset","length","init","undefined","len","construct","path","getPrototypeOf","defineProperty","get","enumerable","configurable","equals","other","comparator","child","nameOrPath","slice","limit","forEach","segment","push","popFirst","size","popLast","isEmpty","firstSegment","lastSegment","index","isPrefixOf","i","fn","end","toArray","p1","p2","Math","min","left","right","ResourcePath","_super","apply","arguments","canonicalString","join","toString","fromString","indexOf","INVALID_ARGUMENT","split","filter","EMPTY_PATH","identifierRegExp","FieldPath","isValidIdentifier","test","map","str","replace","isKeyField","keyField","fromServerFormat","current","addCurrentSegment","inBackticks","c","next"],"mappings":"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","file":"path.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\n\nexport const DOCUMENT_KEY_NAME = '__name__';\n\n/**\n * Path represents an ordered sequence of string segments.\n */\nexport abstract class Path {\n  private segments: string[];\n  private offset: number;\n  private len: number;\n\n  public constructor(segments: string[], offset?: number, length?: number) {\n    this.init(segments, offset, length);\n  }\n\n  /**\n   * An initialization method that can be called from outside the constructor.\n   * We need this so that we can have a non-static construct method that returns\n   * the polymorphic `this` type.\n   */\n  private init(segments: string[], offset?: number, length?: number) {\n    if (offset === undefined) {\n      offset = 0;\n    } else if (offset > segments.length) {\n      fail('offset ' + offset + ' out of range ' + segments.length);\n    }\n\n    if (length === undefined) {\n      length = segments.length - offset;\n    } else if (length > segments.length - offset) {\n      fail('length ' + length + ' out of range ' + (segments.length - offset));\n    }\n    this.segments = segments;\n    this.offset = offset;\n    this.len = length;\n  }\n\n  /**\n   * Constructs a new instance of Path using the same concrete type as `this`.\n   * We need this instead of using the normal constructor, because polymorphic\n   * `this` doesn't work on static methods.\n   */\n  private construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): this {\n    const path: this = Object.create(Object.getPrototypeOf(this));\n    path.init(segments, offset, length);\n    return path;\n  }\n\n  get length(): number {\n    return this.len;\n  }\n\n  equals(other: Path): boolean {\n    return Path.comparator(this, other) === 0;\n  }\n\n  child(nameOrPath: string | this): this {\n    const segments = this.segments.slice(this.offset, this.limit());\n    if (nameOrPath instanceof Path) {\n      nameOrPath.forEach(segment => {\n        segments.push(segment);\n      });\n    } else if (typeof nameOrPath === 'string') {\n      segments.push(nameOrPath);\n    } else {\n      fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n    }\n    return this.construct(segments);\n  }\n\n  /** The index of one past the last segment of the path. */\n  private limit(): number {\n    return this.offset + this.length;\n  }\n\n  popFirst(size?: number): this {\n    size = size === undefined ? 1 : size;\n    assert(this.length >= size, \"Can't call popFirst() with less segments\");\n    return this.construct(\n      this.segments,\n      this.offset + size,\n      this.length - size\n    );\n  }\n\n  popLast(): this {\n    assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n    return this.construct(this.segments, this.offset, this.length - 1);\n  }\n\n  firstSegment(): string {\n    assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n    return this.segments[this.offset];\n  }\n\n  lastSegment(): string {\n    assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n    return this.segments[this.limit() - 1];\n  }\n\n  get(index: number): string {\n    assert(index < this.length, 'Index out of range');\n    return this.segments[this.offset + index];\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  isPrefixOf(other: this): boolean {\n    if (other.length < this.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (this.get(i) !== other.get(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  forEach(fn: (segment: string) => void): void {\n    for (let i = this.offset, end = this.limit(); i < end; i++) {\n      fn(this.segments[i]);\n    }\n  }\n\n  toArray(): string[] {\n    return this.segments.slice(this.offset, this.limit());\n  }\n\n  static comparator(p1: Path, p2: Path): number {\n    const len = Math.min(p1.length, p2.length);\n    for (let i = 0; i < len; i++) {\n      const left = p1.get(i);\n      const right = p2.get(i);\n      if (left < right) return -1;\n      if (left > right) return 1;\n    }\n    if (p1.length < p2.length) return -1;\n    if (p1.length > p2.length) return 1;\n    return 0;\n  }\n}\n\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nexport class ResourcePath extends Path {\n  canonicalString(): string {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    return this.toArray().join('/');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Creates a resource path from the given slash-delimited string.\n   */\n  static fromString(path: string): ResourcePath {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    if (path.indexOf('//') >= 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid path (${path}). Paths must not contain // in them.`\n      );\n    }\n\n    // We may still have an empty segment at the beginning or end if they had a\n    // leading or trailing slash (which we allow).\n    const segments = path.split('/').filter(segment => segment.length > 0);\n\n    return new ResourcePath(segments);\n  }\n\n  static EMPTY_PATH = new ResourcePath([]);\n}\n\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n\n/** A dot-separated path for navigating sub-objects within a document. */\nexport class FieldPath extends Path {\n  /**\n   * Returns true if the string could be used as a segment in a field path\n   * without escaping.\n   */\n  private static isValidIdentifier(segment: string) {\n    return identifierRegExp.test(segment);\n  }\n\n  canonicalString(): string {\n    return this.toArray()\n      .map(str => {\n        str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n        if (!FieldPath.isValidIdentifier(str)) {\n          str = '`' + str + '`';\n        }\n        return str;\n      })\n      .join('.');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Returns true if this field references the key of a document.\n   */\n  isKeyField(): boolean {\n    return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n  }\n\n  /**\n   * The field designating the key of a document.\n   */\n  static keyField(): FieldPath {\n    return new FieldPath([DOCUMENT_KEY_NAME]);\n  }\n\n  /**\n   * Parses a field string from the given server-formatted string.\n   *\n   * - Splitting the empty string is not allowed (for now at least).\n   * - Empty segments within the string (e.g. if there are two consecutive\n   *   separators) are not allowed.\n   *\n   * TODO(b/37244157): we should make this more strict. Right now, it allows\n   * non-identifier path components, even if they aren't escaped.\n   */\n  static fromServerFormat(path: string): FieldPath {\n    const segments: string[] = [];\n    let current = '';\n    let i = 0;\n\n    const addCurrentSegment = () => {\n      if (current.length === 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid field path (${path}). Paths must not be empty, begin ` +\n            `with '.', end with '.', or contain '..'`\n        );\n      }\n      segments.push(current);\n      current = '';\n    };\n\n    let inBackticks = false;\n\n    while (i < path.length) {\n      const c = path[i];\n      if (c === '\\\\') {\n        if (i + 1 === path.length) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has trailing escape character: ' + path\n          );\n        }\n        const next = path[i + 1];\n        if (!(next === '\\\\' || next === '.' || next === '`')) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has invalid escape sequence: ' + path\n          );\n        }\n        current += next;\n        i += 2;\n      } else if (c === '`') {\n        inBackticks = !inBackticks;\n        i++;\n      } else if (c === '.' && !inBackticks) {\n        addCurrentSegment();\n        i++;\n      } else {\n        current += c;\n        i++;\n      }\n    }\n    addCurrentSegment();\n\n    if (inBackticks) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Unterminated ` in path: ' + path\n      );\n    }\n\n    return new FieldPath(segments);\n  }\n\n  static EMPTY_PATH = new FieldPath([]);\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nexport var DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nvar Path = /** @class */ (function () {\n    function Path(segments, offset, length) {\n        this.init(segments, offset, length);\n    }\n    /**\n     * An initialization method that can be called from outside the constructor.\n     * We need this so that we can have a non-static construct method that returns\n     * the polymorphic `this` type.\n     */\n    Path.prototype.init = function (segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail('offset ' + offset + ' out of range ' + segments.length);\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail('length ' + length + ' out of range ' + (segments.length - offset));\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    };\n    /**\n     * Constructs a new instance of Path using the same concrete type as `this`.\n     * We need this instead of using the normal constructor, because polymorphic\n     * `this` doesn't work on static methods.\n     */\n    Path.prototype.construct = function (segments, offset, length) {\n        var path = Object.create(Object.getPrototypeOf(this));\n        path.init(segments, offset, length);\n        return path;\n    };\n    Object.defineProperty(Path.prototype, \"length\", {\n        get: function () {\n            return this.len;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path.prototype.equals = function (other) {\n        return Path.comparator(this, other) === 0;\n    };\n    Path.prototype.child = function (nameOrPath) {\n        var segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof Path) {\n            nameOrPath.forEach(function (segment) {\n                segments.push(segment);\n            });\n        }\n        else if (typeof nameOrPath === 'string') {\n            segments.push(nameOrPath);\n        }\n        else {\n            fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n        }\n        return this.construct(segments);\n    };\n    /** The index of one past the last segment of the path. */\n    Path.prototype.limit = function () {\n        return this.offset + this.length;\n    };\n    Path.prototype.popFirst = function (size) {\n        size = size === undefined ? 1 : size;\n        assert(this.length >= size, \"Can't call popFirst() with less segments\");\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    };\n    Path.prototype.popLast = function () {\n        assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n        return this.construct(this.segments, this.offset, this.length - 1);\n    };\n    Path.prototype.firstSegment = function () {\n        assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n        return this.segments[this.offset];\n    };\n    Path.prototype.lastSegment = function () {\n        assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n        return this.segments[this.limit() - 1];\n    };\n    Path.prototype.get = function (index) {\n        assert(index < this.length, 'Index out of range');\n        return this.segments[this.offset + index];\n    };\n    Path.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    Path.prototype.isPrefixOf = function (other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Path.prototype.forEach = function (fn) {\n        for (var i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    };\n    Path.prototype.toArray = function () {\n        return this.segments.slice(this.offset, this.limit());\n    };\n    Path.comparator = function (p1, p2) {\n        var len = Math.min(p1.length, p2.length);\n        for (var i = 0; i < len; i++) {\n            var left = p1.get(i);\n            var right = p2.get(i);\n            if (left < right)\n                return -1;\n            if (left > right)\n                return 1;\n        }\n        if (p1.length < p2.length)\n            return -1;\n        if (p1.length > p2.length)\n            return 1;\n        return 0;\n    };\n    return Path;\n}());\nexport { Path };\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nvar ResourcePath = /** @class */ (function (_super) {\n    __extends(ResourcePath, _super);\n    function ResourcePath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourcePath.prototype.canonicalString = function () {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    };\n    ResourcePath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Creates a resource path from the given slash-delimited string.\n     */\n    ResourcePath.fromString = function (path) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        if (path.indexOf('//') >= 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid path (\" + path + \"). Paths must not contain // in them.\");\n        }\n        // We may still have an empty segment at the beginning or end if they had a\n        // leading or trailing slash (which we allow).\n        var segments = path.split('/').filter(function (segment) { return segment.length > 0; });\n        return new ResourcePath(segments);\n    };\n    ResourcePath.EMPTY_PATH = new ResourcePath([]);\n    return ResourcePath;\n}(Path));\nexport { ResourcePath };\nvar identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/** A dot-separated path for navigating sub-objects within a document. */\nvar FieldPath = /** @class */ (function (_super) {\n    __extends(FieldPath, _super);\n    function FieldPath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    FieldPath.isValidIdentifier = function (segment) {\n        return identifierRegExp.test(segment);\n    };\n    FieldPath.prototype.canonicalString = function () {\n        return this.toArray()\n            .map(function (str) {\n            str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n            if (!FieldPath.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    };\n    FieldPath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    FieldPath.prototype.isKeyField = function () {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    };\n    /**\n     * The field designating the key of a document.\n     */\n    FieldPath.keyField = function () {\n        return new FieldPath([DOCUMENT_KEY_NAME]);\n    };\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    FieldPath.fromServerFormat = function (path) {\n        var segments = [];\n        var current = '';\n        var i = 0;\n        var addCurrentSegment = function () {\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, begin \" +\n                    \"with '.', end with '.', or contain '..'\");\n            }\n            segments.push(current);\n            current = '';\n        };\n        var inBackticks = false;\n        while (i < path.length) {\n            var c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                var next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath(segments);\n    };\n    FieldPath.EMPTY_PATH = new FieldPath([]);\n    return FieldPath;\n}(Path));\nexport { FieldPath };\n\n\n"]}