{"version":3,"sources":["src/firestore/model/document_set.ts","firestore/model/document_set.js"],"names":["DocumentSet","comp","comparator","d1","d2","key","keyedMap","sortedSet","emptySet","oldSet","prototype","has","get","first","minKey","last","maxKey","isEmpty","prevDoc","doc","getPredecessorKey","indexOf","Object","defineProperty","size","enumerable","configurable","forEach","cb","inorderTraversal","k","v","add","set","delete","copy","insert","remove","equals","other","thisIt","getIterator","otherIt","hasNext","thisDoc","getNext","otherDoc","toString","docStrings","push","length","join","newSet"],"mappings":"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","file":"document_set.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\n\nimport { documentMap } from './collections';\nimport { Document } from './document';\nimport { DocumentComparator } from './document_comparator';\nimport { DocumentKey } from './document_key';\n\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\n\nexport class DocumentSet {\n  /**\n   * Returns an empty copy of the existing DocumentSet, using the same\n   * comparator.\n   */\n  static emptySet(oldSet: DocumentSet): DocumentSet {\n    return new DocumentSet(oldSet.comparator);\n  }\n\n  private comparator: DocumentComparator;\n  private keyedMap: SortedMap<DocumentKey, Document>;\n  private sortedSet: SortedMap<Document, null>;\n\n  /** The default ordering is by key if the comparator is omitted */\n  constructor(comp?: DocumentComparator) {\n    // We are adding document key comparator to the end as it's the only\n    // guaranteed unique property of a document.\n    if (comp) {\n      this.comparator = (d1: Document, d2: Document) =>\n        comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n    } else {\n      this.comparator = (d1: Document, d2: Document) =>\n        DocumentKey.comparator(d1.key, d2.key);\n    }\n\n    this.keyedMap = documentMap();\n    this.sortedSet = new SortedMap<Document, null>(this.comparator);\n  }\n\n  has(key: DocumentKey): boolean {\n    return this.keyedMap.get(key) != null;\n  }\n\n  get(key: DocumentKey): Document | null {\n    return this.keyedMap.get(key);\n  }\n\n  first(): Document | null {\n    return this.sortedSet.minKey();\n  }\n\n  last(): Document | null {\n    return this.sortedSet.maxKey();\n  }\n\n  isEmpty(): boolean {\n    return this.sortedSet.isEmpty();\n  }\n\n  /**\n   * Returns previous document or null if it's a first doc.\n   *\n   * @param key A key that MUST be present in the DocumentSet.\n   */\n  prevDoc(key: DocumentKey): Document | null {\n    assert(\n      this.has(key),\n      'Trying to get a previous document to non-existing key: ' + key\n    );\n    const doc = this.keyedMap.get(key);\n    return this.sortedSet.getPredecessorKey(doc!);\n  }\n\n  /**\n   * Returns the index of the provided key in the document set, or -1 if the\n   * document key is not present in the set;\n   */\n  indexOf(key: DocumentKey): number {\n    const doc = this.keyedMap.get(key);\n    return doc ? this.sortedSet.indexOf(doc) : -1;\n  }\n\n  get size(): number {\n    return this.sortedSet.size;\n  }\n\n  /** Iterates documents in order defined by \"comparator\" */\n  forEach(cb: (doc: Document) => void): void {\n    this.sortedSet.inorderTraversal((k, v) => {\n      cb(k);\n      return false;\n    });\n  }\n\n  /** Inserts or updates a document with the same key */\n  add(doc: Document): DocumentSet {\n    // First remove the element if we have it.\n    const set = this.delete(doc.key);\n    return set.copy(\n      set.keyedMap.insert(doc.key, doc),\n      set.sortedSet.insert(doc, null)\n    );\n  }\n\n  /** Deletes a document with a given key */\n  delete(key: DocumentKey): DocumentSet {\n    const doc = this.get(key);\n    if (!doc) {\n      return this;\n    }\n\n    return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n  }\n\n  equals(other: DocumentSet | null | undefined): boolean {\n    if (!(other instanceof DocumentSet)) return false;\n    if (this.size !== other.size) return false;\n\n    const thisIt = this.sortedSet.getIterator();\n    const otherIt = other.sortedSet.getIterator();\n    while (thisIt.hasNext()) {\n      const thisDoc = thisIt.getNext().key;\n      const otherDoc = otherIt.getNext().key;\n      if (!thisDoc.equals(otherDoc)) return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    const docStrings: string[] = [];\n    this.forEach(doc => {\n      docStrings.push(doc.toString());\n    });\n    if (docStrings.length === 0) {\n      return 'DocumentSet ()';\n    } else {\n      return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n    }\n  }\n\n  private copy(\n    keyedMap: SortedMap<DocumentKey, Document>,\n    sortedSet: SortedMap<Document, null>\n  ): DocumentSet {\n    const newSet = new DocumentSet();\n    newSet.comparator = this.comparator;\n    newSet.keyedMap = keyedMap;\n    newSet.sortedSet = sortedSet;\n    return newSet;\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\nimport { documentMap } from './collections';\nimport { DocumentKey } from './document_key';\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nvar DocumentSet = /** @class */ (function () {\n    /** The default ordering is by key if the comparator is omitted */\n    function DocumentSet(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = function (d1, d2) {\n                return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        else {\n            this.comparator = function (d1, d2) {\n                return DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new SortedMap(this.comparator);\n    }\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    DocumentSet.emptySet = function (oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    };\n    DocumentSet.prototype.has = function (key) {\n        return this.keyedMap.get(key) != null;\n    };\n    DocumentSet.prototype.get = function (key) {\n        return this.keyedMap.get(key);\n    };\n    DocumentSet.prototype.first = function () {\n        return this.sortedSet.minKey();\n    };\n    DocumentSet.prototype.last = function () {\n        return this.sortedSet.maxKey();\n    };\n    DocumentSet.prototype.isEmpty = function () {\n        return this.sortedSet.isEmpty();\n    };\n    /**\n     * Returns previous document or null if it's a first doc.\n     *\n     * @param key A key that MUST be present in the DocumentSet.\n     */\n    DocumentSet.prototype.prevDoc = function (key) {\n        assert(this.has(key), 'Trying to get a previous document to non-existing key: ' + key);\n        var doc = this.keyedMap.get(key);\n        return this.sortedSet.getPredecessorKey(doc);\n    };\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    DocumentSet.prototype.indexOf = function (key) {\n        var doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    };\n    Object.defineProperty(DocumentSet.prototype, \"size\", {\n        get: function () {\n            return this.sortedSet.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Iterates documents in order defined by \"comparator\" */\n    DocumentSet.prototype.forEach = function (cb) {\n        this.sortedSet.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Inserts or updates a document with the same key */\n    DocumentSet.prototype.add = function (doc) {\n        // First remove the element if we have it.\n        var set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    };\n    /** Deletes a document with a given key */\n    DocumentSet.prototype.delete = function (key) {\n        var doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    };\n    DocumentSet.prototype.equals = function (other) {\n        if (!(other instanceof DocumentSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.sortedSet.getIterator();\n        var otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            var thisDoc = thisIt.getNext().key;\n            var otherDoc = otherIt.getNext().key;\n            if (!thisDoc.equals(otherDoc))\n                return false;\n        }\n        return true;\n    };\n    DocumentSet.prototype.toString = function () {\n        var docStrings = [];\n        this.forEach(function (doc) {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    };\n    DocumentSet.prototype.copy = function (keyedMap, sortedSet) {\n        var newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    };\n    return DocumentSet;\n}());\nexport { DocumentSet };\n\n\n"]}