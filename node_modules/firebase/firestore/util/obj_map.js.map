{"version":3,"sources":["src/firestore/util/obj_map.ts","firestore/util/obj_map.js"],"names":["objUtil","ObjectMap","mapKeyFn","inner","prototype","get","key","id","matches","undefined","_i","matches_1","length","_a","otherKey","value","equals","has","set","i","push","delete","splice","forEach","fn","_","entries","entries_1","k","v","isEmpty"],"mappings":"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","file":"obj_map.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Equatable } from './misc';\nimport * as objUtil from './obj';\n\ntype Entry<K, V> = [K, V];\n\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nexport class ObjectMap<KeyType extends Equatable<KeyType>, ValueType> {\n  /**\n   * The inner map for a key -> value pair. Due to the possibility of\n   * collisions we keep a list of entries that we do a linear search through\n   * to find an actual match. Note that collisions should be rare, so we still\n   * expect near constant time lookups in practice.\n   */\n  private inner: {\n    [canonicalId: string]: Array<Entry<KeyType, ValueType>>;\n  } = {};\n\n  constructor(private mapKeyFn: (key: KeyType) => string) {}\n\n  /** Get a value for this key, or undefined if it does not exist. */\n  get(key: KeyType): ValueType | undefined {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      return undefined;\n    }\n    for (const [otherKey, value] of matches) {\n      if (otherKey.equals(key)) {\n        return value;\n      }\n    }\n    return undefined;\n  }\n\n  has(key: KeyType): boolean {\n    return this.get(key) !== undefined;\n  }\n\n  /** Put this key and value in the map. */\n  set(key: KeyType, value: ValueType): void {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      this.inner[id] = [[key, value]];\n      return;\n    }\n    for (let i = 0; i < matches.length; i++) {\n      if (matches[i][0].equals(key)) {\n        matches[i] = [key, value];\n        return;\n      }\n    }\n    matches.push([key, value]);\n  }\n\n  /**\n   * Remove this key from the map. Returns a boolean if anything was deleted.\n   */\n  delete(key: KeyType): boolean {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      return false;\n    }\n    for (let i = 0; i < matches.length; i++) {\n      if (matches[i][0].equals(key)) {\n        if (matches.length === 1) {\n          delete this.inner[id];\n        } else {\n          matches.splice(i, 1);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  forEach(fn: (key: KeyType, val: ValueType) => void): void {\n    objUtil.forEach(this.inner, (_, entries) => {\n      for (const [k, v] of entries) {\n        fn(k, v);\n      }\n    });\n  }\n\n  isEmpty(): boolean {\n    return objUtil.isEmpty(this.inner);\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as objUtil from './obj';\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nvar ObjectMap = /** @class */ (function () {\n    function ObjectMap(mapKeyFn) {\n        this.mapKeyFn = mapKeyFn;\n        /**\n         * The inner map for a key -> value pair. Due to the possibility of\n         * collisions we keep a list of entries that we do a linear search through\n         * to find an actual match. Note that collisions should be rare, so we still\n         * expect near constant time lookups in practice.\n         */\n        this.inner = {};\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    ObjectMap.prototype.get = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n            var _a = matches_1[_i], otherKey = _a[0], value = _a[1];\n            if (otherKey.equals(key)) {\n                return value;\n            }\n        }\n        return undefined;\n    };\n    ObjectMap.prototype.has = function (key) {\n        return this.get(key) !== undefined;\n    };\n    /** Put this key and value in the map. */\n    ObjectMap.prototype.set = function (key, value) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            return;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].equals(key)) {\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n    };\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    ObjectMap.prototype.delete = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].equals(key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    ObjectMap.prototype.forEach = function (fn) {\n        objUtil.forEach(this.inner, function (_, entries) {\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                fn(k, v);\n            }\n        });\n    };\n    ObjectMap.prototype.isEmpty = function () {\n        return objUtil.isEmpty(this.inner);\n    };\n    return ObjectMap;\n}());\nexport { ObjectMap };\n\n\n"]}