{"version":3,"sources":["src/firestore/util/async_queue.ts","firestore/util/async_queue.js"],"names":["log","AsyncQueue","tail","resolve","delayedOpCount","operationInProgress","prototype","schedule","op","delay","_this","failure","message","deferred_1","setTimeout","scheduleInternal","then","result","promise","catch","error","stack","verifyOperationInProgress","drain","undefined"],"mappings":";;;;;;;AAgBA;;AAEA;;AACA;;IAAYA,G;;AAGZ;;;;AAtBA;;;;;;;;;;;;;;;AAwBA,IAAAC,aAAA,aAAA,YAAA;AAAA,aAAAA,UAAA,GAAA;AACE;AACQ,aAAAC,IAAA,GAA8B,qBAAQC,OAAR,EAA9B;AAER;AACA;AACQ,aAAAC,cAAA,GAAiB,CAAjB;AAKR;AACA;AACQ,aAAAC,mBAAA,GAAsB,KAAtB;AAmET;AAjEC;;;;;;AAMAJ,eAAAK,SAAA,CAAAC,QAAA,GAAA,UAAYC,EAAZ,EAAkCC,KAAlC,EAAgD;AAAhD,YAAAC,QAAA,IAAA;AACE,YAAI,KAAKC,OAAT,EAAkB;AAChB,8BAAK,mCAAmC,KAAKA,OAAL,CAAaC,OAArD;AACD;AAED,YAAI,CAACH,SAAS,CAAV,IAAe,CAAnB,EAAsB;AACpB,iBAAKL,cAAL;AACA,gBAAMS,aAAW,wBAAjB;AACAC,uBAAW,YAAA;AACTJ,sBAAKK,gBAAL,CAAsB,YAAA;AACpB,2BAAOP,KAAKQ,IAAL,CAAU,UAAAC,MAAA,EAAM;AACrBJ,mCAASV,OAAT,CAAiBc,MAAjB;AACD,qBAFM,CAAP;AAGD,iBAJD;AAKAP,sBAAKN,cAAL,GANS,CAMc;AACxB,aAPD,EAOGK,KAPH;AAQA,mBAAOI,WAASK,OAAhB;AACD,SAZD,MAYO;AACL,mBAAO,KAAKH,gBAAL,CAAsBP,EAAtB,CAAP;AACD;AACF,KApBD;AAsBQP,eAAAK,SAAA,CAAAS,gBAAA,GAAR,UAA4BP,EAA5B,EAAgD;AAAhD,YAAAE,QAAA,IAAA;AACE,aAAKR,IAAL,GAAY,KAAKA,IAAL,CAAUc,IAAV,CAAe,YAAA;AACzBN,kBAAKL,mBAAL,GAA2B,IAA3B;AACA,mBAAOG,KACJW,KADI,CACE,UAAAC,KAAA,EAAK;AACVV,sBAAKC,OAAL,GAAeS,KAAf;AACAV,sBAAKL,mBAAL,GAA2B,KAA3B;AACAL,oBAAIoB,KAAJ,CAAU,4BAAV,EAAwCA,MAAMC,KAAN,IAAeD,MAAMR,OAA7D;AACA,sBAAMQ,KAAN;AACD,aANI,EAOJJ,IAPI,CAOC,YAAA;AACJN,sBAAKL,mBAAL,GAA2B,KAA3B;AACD,aATI,CAAP;AAUD,SAZW,CAAZ;AAaA,eAAO,KAAKH,IAAZ;AACD,KAfO;AAiBR;;;;;;AAMAD,eAAAK,SAAA,CAAAgB,yBAAA,GAAA,YAAA;AACE,4BACE,KAAKjB,mBADP,EAEE,mEAFF;AAID,KALD;AAOAJ,eAAAK,SAAA,CAAAiB,KAAA,GAAA,YAAA;AACE;AACA;AACA;AACA,4BAAO,KAAKnB,cAAL,KAAwB,CAA/B,EAAkC,sCAAlC;AACA,eAAO,KAAKG,QAAL,CAAc,YAAA;AAAM,mBAAA,qBAAQJ,OAAR,CAAgBqB,SAAhB,CAAA;AAA0B,SAA9C,CAAP;AACD,KAND;AAOF,WAAAvB,UAAA;AAhFA,CAAA,EAAA;QCqESA,U,GAAAA,U","file":"async_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { AnyDuringMigration, AnyJs } from './misc';\n\nimport { Deferred } from './promise';\n\nexport class AsyncQueue {\n  // The last promise in the queue.\n  private tail: Promise<AnyJs | void> = Promise.resolve();\n\n  // The number of ops that are queued to be run in the future (i.e. they had a\n  // delay that has not yet elapsed).\n  private delayedOpCount = 0;\n\n  // visible for testing\n  failure: Error;\n\n  // Flag set while there's an outstanding AsyncQueue operation, used for\n  // assertion sanity-checks.\n  private operationInProgress = false;\n\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   *\n   * Can optionally specify a delay to wait before queuing the operation.\n   */\n  schedule<T>(op: () => Promise<T>, delay?: number): Promise<T> {\n    if (this.failure) {\n      fail('AsyncQueue is already failed: ' + this.failure.message);\n    }\n\n    if ((delay || 0) > 0) {\n      this.delayedOpCount++;\n      const deferred = new Deferred<T>();\n      setTimeout(() => {\n        this.scheduleInternal(() => {\n          return op().then(result => {\n            deferred.resolve(result);\n          });\n        });\n        this.delayedOpCount--; // decrement once it's actually queued.\n      }, delay);\n      return deferred.promise;\n    } else {\n      return this.scheduleInternal(op);\n    }\n  }\n\n  private scheduleInternal<T>(op: () => Promise<T>): Promise<T> {\n    this.tail = this.tail.then(() => {\n      this.operationInProgress = true;\n      return op()\n        .catch(error => {\n          this.failure = error;\n          this.operationInProgress = false;\n          log.error('INTERNAL UNHANDLED ERROR: ', error.stack || error.message);\n          throw error;\n        })\n        .then(() => {\n          this.operationInProgress = false;\n        });\n    });\n    return this.tail as AnyDuringMigration;\n  }\n\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n  verifyOperationInProgress(): void {\n    assert(\n      this.operationInProgress,\n      'verifyOpInProgress() called when no op in progress on this queue.'\n    );\n  }\n\n  drain(): Promise<void> {\n    // TODO(mikelehen): This should perhaps also drain items that are queued to\n    // run in the future (perhaps by artificially running them early), but since\n    // no tests need that yet, I didn't bother for now.\n    assert(this.delayedOpCount === 0, \"draining doesn't handle delayed ops.\");\n    return this.schedule(() => Promise.resolve(undefined));\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PromiseImpl as Promise } from '../../utils/promise';\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { Deferred } from './promise';\nvar AsyncQueue = /** @class */ (function () {\n    function AsyncQueue() {\n        // The last promise in the queue.\n        this.tail = Promise.resolve();\n        // The number of ops that are queued to be run in the future (i.e. they had a\n        // delay that has not yet elapsed).\n        this.delayedOpCount = 0;\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n    }\n    /**\n     * Adds a new operation to the queue. Returns a promise that will be resolved\n     * when the promise returned by the new operation is (with its value).\n     *\n     * Can optionally specify a delay to wait before queuing the operation.\n     */\n    AsyncQueue.prototype.schedule = function (op, delay) {\n        var _this = this;\n        if (this.failure) {\n            fail('AsyncQueue is already failed: ' + this.failure.message);\n        }\n        if ((delay || 0) > 0) {\n            this.delayedOpCount++;\n            var deferred_1 = new Deferred();\n            setTimeout(function () {\n                _this.scheduleInternal(function () {\n                    return op().then(function (result) {\n                        deferred_1.resolve(result);\n                    });\n                });\n                _this.delayedOpCount--; // decrement once it's actually queued.\n            }, delay);\n            return deferred_1.promise;\n        }\n        else {\n            return this.scheduleInternal(op);\n        }\n    };\n    AsyncQueue.prototype.scheduleInternal = function (op) {\n        var _this = this;\n        this.tail = this.tail.then(function () {\n            _this.operationInProgress = true;\n            return op()\n                .catch(function (error) {\n                _this.failure = error;\n                _this.operationInProgress = false;\n                log.error('INTERNAL UNHANDLED ERROR: ', error.stack || error.message);\n                throw error;\n            })\n                .then(function () {\n                _this.operationInProgress = false;\n            });\n        });\n        return this.tail;\n    };\n    /**\n     * Verifies there's an operation currently in-progress on the AsyncQueue.\n     * Unfortunately we can't verify that the running code is in the promise chain\n     * of that operation, so this isn't a foolproof check, but it should be enough\n     * to catch some bugs.\n     */\n    AsyncQueue.prototype.verifyOperationInProgress = function () {\n        assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');\n    };\n    AsyncQueue.prototype.drain = function () {\n        // TODO(mikelehen): This should perhaps also drain items that are queued to\n        // run in the future (perhaps by artificially running them early), but since\n        // no tests need that yet, I didn't bother for now.\n        assert(this.delayedOpCount === 0, \"draining doesn't handle delayed ops.\");\n        return this.schedule(function () { return Promise.resolve(undefined); });\n    };\n    return AsyncQueue;\n}());\nexport { AsyncQueue };\n\n\n"]}