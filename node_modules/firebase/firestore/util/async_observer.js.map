{"version":3,"sources":["src/firestore/util/async_observer.ts","firestore/util/async_observer.js"],"names":["AsyncObserver","observer","muted","prototype","next","value","scheduleEvent","error","mute","eventHandler","event","_this","setTimeout"],"mappings":";;;;;AAAA;;;;;;;;;;;;;;;AAmBA;;;;;AAKA,IAAAA,gBAAA,aAAA,YAAA;AAOE,aAAAA,aAAA,CAAoBC,QAApB,EAAyC;AAArB,aAAAA,QAAA,GAAAA,QAAA;AANpB;;;;AAIQ,aAAAC,KAAA,GAAQ,KAAR;AAEqC;AAE7CF,kBAAAG,SAAA,CAAAC,IAAA,GAAA,UAAKC,KAAL,EAAa;AACX,aAAKC,aAAL,CAAmB,KAAKL,QAAL,CAAcG,IAAjC,EAAuCC,KAAvC;AACD,KAFD;AAIAL,kBAAAG,SAAA,CAAAI,KAAA,GAAA,UAAMA,KAAN,EAAkB;AAChB,aAAKD,aAAL,CAAmB,KAAKL,QAAL,CAAcM,KAAjC,EAAwCA,KAAxC;AACD,KAFD;AAIAP,kBAAAG,SAAA,CAAAK,IAAA,GAAA,YAAA;AACE,aAAKN,KAAL,GAAa,IAAb;AACD,KAFD;AAIQF,kBAAAG,SAAA,CAAAG,aAAA,GAAR,UAAyBG,YAAzB,EAAwDC,KAAxD,EAAgE;AAAhE,YAAAC,QAAA,IAAA;AACE,YAAI,CAAC,KAAKT,KAAV,EAAiB;AACfU,uBAAW,YAAA;AACT,oBAAI,CAACD,MAAKT,KAAV,EAAiB;AACfO,iCAAaC,KAAb;AACD;AACF,aAJD,EAIG,CAJH;AAKD;AACF,KARO;AASV,WAAAV,aAAA;AA9BA,CAAA,EAAA;QC0BSA,a,GAAAA,a","file":"async_observer.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Observer } from '../core/event_manager';\nimport { EventHandler } from './misc';\n\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nexport class AsyncObserver<T> implements Observer<T> {\n  /**\n   * When set to true, will not raise future events. Necessary to deal with\n   * async detachment of listener.\n   */\n  private muted = false;\n\n  constructor(private observer: Observer<T>) {}\n\n  next(value: T): void {\n    this.scheduleEvent(this.observer.next, value);\n  }\n\n  error(error: Error): void {\n    this.scheduleEvent(this.observer.error, error);\n  }\n\n  mute(): void {\n    this.muted = true;\n  }\n\n  private scheduleEvent<E>(eventHandler: EventHandler<E>, event: E): void {\n    if (!this.muted) {\n      setTimeout(() => {\n        if (!this.muted) {\n          eventHandler(event);\n        }\n      }, 0);\n    }\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nvar AsyncObserver = /** @class */ (function () {\n    function AsyncObserver(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    AsyncObserver.prototype.next = function (value) {\n        this.scheduleEvent(this.observer.next, value);\n    };\n    AsyncObserver.prototype.error = function (error) {\n        this.scheduleEvent(this.observer.error, error);\n    };\n    AsyncObserver.prototype.mute = function () {\n        this.muted = true;\n    };\n    AsyncObserver.prototype.scheduleEvent = function (eventHandler, event) {\n        var _this = this;\n        if (!this.muted) {\n            setTimeout(function () {\n                if (!_this.muted) {\n                    eventHandler(event);\n                }\n            }, 0);\n        }\n    };\n    return AsyncObserver;\n}());\nexport { AsyncObserver };\n\n\n"]}