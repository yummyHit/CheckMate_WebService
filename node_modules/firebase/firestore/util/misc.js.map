{"version":3,"sources":["src/firestore/util/misc.ts","firestore/util/misc.js"],"names":["primitiveComparator","equals","arrayEquals","immediatePredecessor","immediateSuccessor","AutoId","newId","chars","autoId","i","charAt","Math","floor","random","length","left","right","undefined","s","lastIndex","substring","String","fromCharCode","charCodeAt"],"mappings":";;;;;;QAgDMA,mB,GAAAA,mB;QAYAC,M,GAAAA,M;QAcAC,W,GAAAA,W;QAuBAC,oB,GAAAA,oB;QAsBAC,kB,GAAAA,kB;;AAvGN;;AAiBA;AACA,IAAAC,SAAA,aAAA,YAAA;AAAA,aAAAA,MAAA,GAAA,CAYC;AAXQA,WAAAC,KAAA,GAAP,YAAA;AACE;AACA,YAAMC,QACJ,gEADF;AAEA,YAAIC,SAAS,EAAb;AACA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,EAApB,EAAwBA,GAAxB,EAA6B;AAC3BD,sBAAUD,MAAMG,MAAN,CAAaC,KAAKC,KAAL,CAAWD,KAAKE,MAAL,KAAgBN,MAAMO,MAAjC,CAAb,CAAV;AACD;AACD,4BAAON,OAAOM,MAAP,KAAkB,EAAzB,EAA6B,sBAAsBN,MAAnD;AACA,eAAOA,MAAP;AACD,KAVM;AAWT,WAAAH,MAAA;AAZA,CAAA,EAAA,C,CAlCA;;;;;;;;;;;;;;;QCgCSA,M,GAAAA,M;ADgBH,SAAAL,mBAAA,CAAiCe,IAAjC,EAA0CC,KAA1C,EAAkD;AACtD,QAAID,OAAOC,KAAX,EAAkB,OAAO,CAAC,CAAR;AAClB,QAAID,OAAOC,KAAX,EAAkB,OAAO,CAAP;AAClB,WAAO,CAAP;AACD;AAOD;AACM,SAAAf,MAAA,CACJc,IADI,EAEJC,KAFI,EAEuB;AAE3B,QAAID,SAAS,IAAT,IAAiBA,SAASE,SAA9B,EAAyC;AACvC,eAAO,CAAC,EAAED,SAASD,KAAKd,MAAL,CAAYe,KAAZ,CAAX,CAAR;AACD,KAFD,MAEO;AACL;AACA;AACA,eAAQD,SAA8BC,KAAtC;AACD;AACF;AAED;AACM,SAAAd,WAAA,CAAyBa,IAAzB,EAAoDC,KAApD,EAA8D;AAClE,QAAID,KAAKD,MAAL,KAAgBE,MAAMF,MAA1B,EAAkC;AAChC,eAAO,KAAP;AACD;AAED,SAAK,IAAIL,IAAI,CAAb,EAAgBA,IAAIM,KAAKD,MAAzB,EAAiCL,GAAjC,EAAsC;AACpC,YAAI,CAACM,KAAKN,CAAL,EAAQR,MAAR,CAAee,MAAMP,CAAN,CAAf,CAAL,EAA+B;AAC7B,mBAAO,KAAP;AACD;AACF;AAED,WAAO,IAAP;AACD;AAED;;;;;;;;;AASM,SAAAN,oBAAA,CAA+Be,CAA/B,EAAwC;AAC5C;AACA;AACA;AACA,QAAMC,YAAYD,EAAEJ,MAAF,GAAW,CAA7B;AACA,QAAII,EAAEJ,MAAF,KAAa,CAAjB,EAAoB;AAClB;AACA,eAAO,EAAP;AACD,KAHD,MAGO,IAAII,EAAER,MAAF,CAASS,SAAT,MAAwB,IAA5B,EAAkC;AACvC,eAAOD,EAAEE,SAAF,CAAY,CAAZ,EAAeD,SAAf,CAAP;AACD,KAFM,MAEA;AACL,eACED,EAAEE,SAAF,CAAY,CAAZ,EAAeD,SAAf,IACAE,OAAOC,YAAP,CAAoBJ,EAAEK,UAAF,CAAaJ,SAAb,IAA0B,CAA9C,CAFF;AAID;AACF;AAED;;;;AAIM,SAAAf,kBAAA,CAA6Bc,CAA7B,EAAsC;AAC1C;AACA,WAAOA,IAAI,IAAX;AACD","file":"misc.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from './assert';\n\nexport type EventHandler<E> = (value: E) => void;\n\n/**\n * A union of all of the standard JS types, useful for cases where the type is\n * unknown. Unlike \"any\" this doesn't lose all type-safety, since the consuming\n * code must still cast to a particular type before using it.\n */\nexport type AnyJs = null | undefined | boolean | number | string | object;\n\n// TODO(b/66916745): AnyDuringMigration was used to suppress type check failures\n// that were found during the upgrade to TypeScript 2.4. They need to be audited\n// and fixed.\n// tslint:disable-next-line:no-any\nexport type AnyDuringMigration = any;\n\n// tslint:disable-next-line:class-as-namespace\nexport class AutoId {\n  static newId(): string {\n    // Alphanumeric characters\n    const chars =\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let autoId = '';\n    for (let i = 0; i < 20; i++) {\n      autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n    return autoId;\n  }\n}\n\nexport function primitiveComparator<T>(left: T, right: T): number {\n  if (left < right) return -1;\n  if (left > right) return 1;\n  return 0;\n}\n\n/** Duck-typed interface for objects that have an equals() method. */\nexport interface Equatable<T> {\n  equals(other: T): boolean;\n}\n\n/** Helper to compare nullable (or undefined-able) objects using equals(). */\nexport function equals<T>(\n  left: Equatable<T> | null | undefined,\n  right: T | null | undefined\n): boolean {\n  if (left !== null && left !== undefined) {\n    return !!(right && left.equals(right));\n  } else {\n    // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n    // smart enough.\n    return (left as null | undefined) === right;\n  }\n}\n\n/** Helper to compare arrays using equals(). */\nexport function arrayEquals<T>(left: Array<Equatable<T>>, right: T[]): boolean {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    if (!left[i].equals(right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\nexport function immediatePredecessor(s: string): string {\n  // We can decrement the last character in the string and be done\n  // unless that character is 0 (0x0000), in which case we have to erase the\n  // last character.\n  const lastIndex = s.length - 1;\n  if (s.length === 0) {\n    // Special case the empty string.\n    return '';\n  } else if (s.charAt(lastIndex) === '\\0') {\n    return s.substring(0, lastIndex);\n  } else {\n    return (\n      s.substring(0, lastIndex) +\n      String.fromCharCode(s.charCodeAt(lastIndex) - 1)\n    );\n  }\n}\n\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nexport function immediateSuccessor(s: string): string {\n  // Return the input string, with an additional NUL byte appended.\n  return s + '\\0';\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from './assert';\n// tslint:disable-next-line:class-as-namespace\nvar AutoId = /** @class */ (function () {\n    function AutoId() {\n    }\n    AutoId.newId = function () {\n        // Alphanumeric characters\n        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var autoId = '';\n        for (var i = 0; i < 20; i++) {\n            autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n        return autoId;\n    };\n    return AutoId;\n}());\nexport { AutoId };\nexport function primitiveComparator(left, right) {\n    if (left < right)\n        return -1;\n    if (left > right)\n        return 1;\n    return 0;\n}\n/** Helper to compare nullable (or undefined-able) objects using equals(). */\nexport function equals(left, right) {\n    if (left !== null && left !== undefined) {\n        return !!(right && left.equals(right));\n    }\n    else {\n        // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n        // smart enough.\n        return left === right;\n    }\n}\n/** Helper to compare arrays using equals(). */\nexport function arrayEquals(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (var i = 0; i < left.length; i++) {\n        if (!left[i].equals(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\nexport function immediatePredecessor(s) {\n    // We can decrement the last character in the string and be done\n    // unless that character is 0 (0x0000), in which case we have to erase the\n    // last character.\n    var lastIndex = s.length - 1;\n    if (s.length === 0) {\n        // Special case the empty string.\n        return '';\n    }\n    else if (s.charAt(lastIndex) === '\\0') {\n        return s.substring(0, lastIndex);\n    }\n    else {\n        return (s.substring(0, lastIndex) +\n            String.fromCharCode(s.charCodeAt(lastIndex) - 1));\n    }\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nexport function immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n\n"]}