{"version":3,"sources":["src/firestore/util/sorted_map.ts","firestore/util/sorted_map.js"],"names":["SortedMap","comparator","root","LLRBNode","EMPTY","prototype","insert","key","value","copy","BLACK","remove","get","node","isEmpty","cmp","left","right","getPredecessorKey","rightParent","indexOf","prunedNodes","size","Object","defineProperty","enumerable","configurable","minKey","maxKey","inorderTraversal","action","forEach","fn","k","v","reverseTraversal","getIterator","resultGenerator","SortedMapIterator","getIteratorFrom","getReverseIterator","getReverseIteratorFrom","startKey","isReverse","nodeStack","push","getNext","length","pop","result","hasNext","peek","color","RED","min","n","fixUp","removeMin","isRed","moveRedLeft","smallest","rotateRight","moveRedRight","rotateLeft","colorFlip","nl","nr","checkMaxDepth","blackDepth","check","Math","pow","LLRBEmptyNode"],"mappings":"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","file":"sorted_map.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from './assert';\nimport { AnyJs } from './misc';\n\n/*\n * Implementation of an immutable SortedMap using a Left-leaning\n * Red-Black Tree, adapted from the implementation in Mugs\n * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen\n * (mads379@gmail.com).\n *\n * Original paper on Left-leaning Red-Black Trees:\n *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\n\nexport type Comparator<K> = (key1: K, key2: K) => number;\n\nexport interface Entry<K, V> {\n  key: K;\n  value: V;\n}\n\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nexport class SortedMap<K, V> {\n  // visible for testing\n  root: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n\n  constructor(public comparator: Comparator<K>, root?: LLRBNode<K, V>) {\n    this.root = root ? root : LLRBNode.EMPTY;\n  }\n\n  // Returns a copy of the map, with the specified key/value added or replaced.\n  insert(key: K, value: V): SortedMap<K, V> {\n    return new SortedMap<K, V>(\n      this.comparator,\n      this.root\n        .insert(key, value, this.comparator)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  // Returns a copy of the map, with the specified key removed.\n  remove(key: K): SortedMap<K, V> {\n    return new SortedMap<K, V>(\n      this.comparator,\n      this.root\n        .remove(key, this.comparator)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  // Returns the value of the node with the given key, or null.\n  get(key: K): V | null {\n    let node = this.root;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  }\n\n  // Returns the key of the item *before* the specified key, or null if key is\n  // the first item.\n  getPredecessorKey(key: K): K | null {\n    let node = this.root;\n    let rightParent: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null = null;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        if (!node.left.isEmpty()) {\n          node = node.left;\n          while (!node.right.isEmpty()) node = node.right;\n          return node.key;\n        } else if (rightParent) {\n          return rightParent.key;\n        } else {\n          return null; // first item.\n        }\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        rightParent = node;\n        node = node.right;\n      }\n    }\n\n    throw fail(\n      'Attempted to find predecessor key for a nonexistent key.' +\n        '  What gives?'\n    );\n  }\n\n  // Returns the index of the element in this sorted map, or -1 if it doesn't\n  // exist.\n  indexOf(key: K): number {\n    // Number of nodes that were pruned when descending right\n    let prunedNodes = 0;\n    let node = this.root;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        return prunedNodes + node.left.size;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        // Count all nodes left of the node plus the node itself\n        prunedNodes += node.left.size + 1;\n        node = node.right;\n      }\n    }\n    // Node not found\n    return -1;\n  }\n\n  isEmpty(): boolean {\n    return this.root.isEmpty();\n  }\n\n  // Returns the total number of nodes in the map.\n  get size(): number {\n    return this.root.size;\n  }\n\n  // Returns the minimum key in the map.\n  minKey(): K | null {\n    return this.root.minKey();\n  }\n\n  // Returns the maximum key in the map.\n  maxKey(): K | null {\n    return this.root.maxKey();\n  }\n\n  // Traverses the map in key order and calls the specified action function\n  // for each key/value pair. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  inorderTraversal<T>(action: (k: K, v: V) => T): T {\n    return (this.root as LLRBNode<K, V>).inorderTraversal(action);\n  }\n\n  forEach(fn: (k: K, v: V) => void) {\n    this.inorderTraversal((k, v) => {\n      fn(k, v);\n      return false;\n    });\n  }\n\n  // Traverses the map in reverse key order and calls the specified action\n  // function for each key/value pair. If action returns true, traversal is\n  // aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  reverseTraversal<T>(action: (k: K, v: V) => T): T {\n    return (this.root as LLRBNode<K, V>).reverseTraversal(action);\n  }\n\n  // Returns an iterator over the SortedMap.\n  getIterator(): SortedMapIterator<K, V, Entry<K, V>>;\n  getIterator<T>(\n    resultGenerator: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T>;\n  getIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator<K, V, T>(\n      this.root,\n      null,\n      this.comparator,\n      false,\n      resultGenerator\n    );\n  }\n\n  getIteratorFrom(key: K): SortedMapIterator<K, V, Entry<K, V>>;\n  getIteratorFrom<T>(\n    key: K,\n    resultGenerator: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T>;\n  getIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator<K, V, T>(\n      this.root,\n      key,\n      this.comparator,\n      false,\n      resultGenerator\n    );\n  }\n\n  getReverseIterator(): SortedMapIterator<K, V, Entry<K, V>>;\n  getReverseIterator<T>(\n    resultGenerator: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T>;\n  getReverseIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator<K, V, T>(\n      this.root,\n      null,\n      this.comparator,\n      true,\n      resultGenerator\n    );\n  }\n\n  getReverseIteratorFrom(key: K): SortedMapIterator<K, V, Entry<K, V>>;\n  getReverseIteratorFrom<T>(\n    key: K,\n    resultGenerator: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T>;\n  getReverseIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator<K, V, T>(\n      this.root,\n      key,\n      this.comparator,\n      true,\n      resultGenerator\n    );\n  }\n} // end SortedMap\n\n// An iterator over an LLRBNode.\nexport class SortedMapIterator<K, V, T> {\n  private resultGenerator: ((k: K, v: V) => T) | null;\n  private isReverse: boolean;\n  private nodeStack: Array<LLRBNode<K, V> | LLRBEmptyNode<K, V>>;\n\n  constructor(\n    node: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    startKey: K | null,\n    comparator: Comparator<K>,\n    isReverse: boolean,\n    resultGenerator?: (k: K, v: V) => T\n  ) {\n    this.resultGenerator = resultGenerator || null;\n    this.isReverse = isReverse;\n    this.nodeStack = [];\n\n    let cmp = 1;\n    while (!node.isEmpty()) {\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (isReverse) cmp *= -1;\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack,\n        // but stop iterating;\n        this.nodeStack.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move\n        // to the next one\n        this.nodeStack.push(node);\n        if (this.isReverse) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  getNext(): T {\n    assert(\n      this.nodeStack.length > 0,\n      'getNext() called on iterator when hasNext() is false.'\n    );\n\n    let node = this.nodeStack.pop()!;\n    let result: any;\n    if (this.resultGenerator)\n      result = this.resultGenerator(node.key, node.value);\n    else result = { key: node.key, value: node.value };\n\n    if (this.isReverse) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  }\n\n  hasNext(): boolean {\n    return this.nodeStack.length > 0;\n  }\n\n  peek(): any {\n    if (this.nodeStack.length === 0) return null;\n\n    const node = this.nodeStack[this.nodeStack.length - 1];\n    if (this.resultGenerator) {\n      return this.resultGenerator(node.key, node.value);\n    } else {\n      return { key: node.key, value: node.value };\n    }\n  }\n} // end SortedMapIterator\n\n// Represents a node in a Left-leaning Red-Black tree.\nexport class LLRBNode<K, V> {\n  readonly color: boolean;\n  readonly left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  readonly right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  readonly size: number;\n\n  static EMPTY: LLRBEmptyNode<any, any> = null as any;\n\n  static RED = true;\n  static BLACK = false;\n\n  constructor(\n    public key: K,\n    public value: V,\n    color?: boolean,\n    left?: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    right?: LLRBNode<K, V> | LLRBEmptyNode<K, V>\n  ) {\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left = left != null ? left : LLRBNode.EMPTY;\n    this.right = right != null ? right : LLRBNode.EMPTY;\n    this.size = this.left.size + 1 + this.right.size;\n  }\n\n  // Returns a copy of the current node, optionally replacing pieces of it.\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): any {\n    return new LLRBNode<K, V>(\n      key != null ? key : this.key,\n      value != null ? value : this.value,\n      color != null ? color : this.color,\n      left != null ? left : this.left,\n      right != null ? right : this.right\n    );\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  // Traverses the tree in key order and calls the specified action function\n  // for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  inorderTraversal<T>(action: (k: K, v: V) => T): T {\n    return (\n      (this.left as LLRBNode<K, V>).inorderTraversal(action) ||\n      action(this.key, this.value) ||\n      (this.right as LLRBNode<K, V>).inorderTraversal(action)\n    );\n  }\n\n  // Traverses the tree in reverse key order and calls the specified action\n  // function for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  reverseTraversal<T>(action: (k: K, v: V) => T): T {\n    return (\n      (this.right as LLRBNode<K, V>).reverseTraversal(action) ||\n      action(this.key, this.value) ||\n      (this.left as LLRBNode<K, V>).reverseTraversal(action)\n    );\n  }\n\n  // Returns the minimum node in the tree.\n  private min(): LLRBNode<K, V> {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return (this.left as LLRBNode<K, V>).min();\n    }\n  }\n\n  // Returns the maximum key in the tree.\n  minKey(): K | null {\n    return this.min().key;\n  }\n\n  // Returns the maximum key in the tree.\n  maxKey(): K | null {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }\n\n  // Returns new tree, with the key/value added.\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    let n = this;\n    const cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        n.right.insert(key, value, comparator)\n      );\n    }\n    return n.fixUp();\n  }\n\n  private removeMin(): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    if (this.left.isEmpty()) {\n      return LLRBNode.EMPTY;\n    }\n    let n: LLRBNode<K, V> = this;\n    if (!n.left.isRed() && !n.left.left.isRed()) n = n.moveRedLeft();\n    n = n.copy(null, null, null, (n.left as LLRBNode<K, V>).removeMin(), null);\n    return n.fixUp();\n  }\n\n  // Returns new tree, with the specified item removed.\n  remove(\n    key: K,\n    comparator: Comparator<K>\n  ): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    let smallest: LLRBNode<K, V>;\n    let n: LLRBNode<K, V> = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n        n = n.moveRedLeft();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed()) n = n.rotateRight();\n      if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n        n = n.moveRedRight();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return LLRBNode.EMPTY;\n        } else {\n          smallest = (n.right as LLRBNode<K, V>).min();\n          n = n.copy(\n            smallest.key,\n            smallest.value,\n            null,\n            null,\n            (n.right as LLRBNode<K, V>).removeMin()\n          );\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp();\n  }\n\n  isRed(): boolean {\n    return this.color;\n  }\n\n  // Returns new tree after performing any needed rotations.\n  private fixUp(): LLRBNode<K, V> {\n    let n: LLRBNode<K, V> = this;\n    if (n.right.isRed() && !n.left.isRed()) n = n.rotateLeft();\n    if (n.left.isRed() && n.left.left.isRed()) n = n.rotateRight();\n    if (n.left.isRed() && n.right.isRed()) n = n.colorFlip();\n    return n;\n  }\n\n  private moveRedLeft(): LLRBNode<K, V> {\n    let n = this.colorFlip();\n    if (n.right.left.isRed()) {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        (n.right as LLRBNode<K, V>).rotateRight()\n      );\n      n = n.rotateLeft();\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private moveRedRight(): LLRBNode<K, V> {\n    let n = this.colorFlip();\n    if (n.left.left.isRed()) {\n      n = n.rotateRight();\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private rotateLeft(): LLRBNode<K, V> {\n    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return this.right.copy(null, null, this.color, nl, null);\n  }\n\n  private rotateRight(): LLRBNode<K, V> {\n    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return this.left.copy(null, null, this.color, null, nr);\n  }\n\n  private colorFlip(): LLRBNode<K, V> {\n    const left = this.left.copy(null, null, !this.left.color, null, null);\n    const right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }\n\n  // For testing.\n  checkMaxDepth(): boolean {\n    const blackDepth = this.check();\n    if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // In a balanced RB tree, the black-depth (number of black nodes) from root to\n  // leaves is equal on both sides.  This function verifies that or asserts.\n  private check(): number {\n    if (this.isRed() && this.left.isRed()) {\n      throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n    }\n    if (this.right.isRed()) {\n      throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n    }\n    const blackDepth = (this.left as LLRBNode<K, V>).check();\n    if (blackDepth !== (this.right as LLRBNode<K, V>).check()) {\n      throw fail('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed() ? 0 : 1);\n    }\n  }\n} // end LLRBNode\n\n// Represents an empty node (a leaf node in the Red-Black Tree).\nexport class LLRBEmptyNode<K, V> {\n  key: K;\n  value: V;\n  color: boolean;\n  left: LLRBNode<K, V>;\n  right: LLRBNode<K, V>;\n  size = 0;\n\n  constructor() {}\n\n  // Returns a copy of the current node.\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  // Returns a copy of the tree, with the specified key/value added.\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    return new LLRBNode<K, V>(key, value);\n  }\n\n  // Returns a copy of the tree, with the specified key removed.\n  remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  isEmpty(): boolean {\n    return true;\n  }\n\n  inorderTraversal(action: (k: K, v: V) => boolean): boolean {\n    return false;\n  }\n\n  reverseTraversal(action: (k: K, v: V) => boolean): boolean {\n    return false;\n  }\n\n  minKey(): K | null {\n    return null;\n  }\n\n  maxKey(): K | null {\n    return null;\n  }\n\n  isRed(): boolean {\n    return false;\n  }\n\n  // For testing.\n  checkMaxDepth(): boolean {\n    return true;\n  }\n\n  private check() {\n    return 0;\n  }\n} // end LLRBEmptyNode\n\nLLRBNode.EMPTY = new LLRBEmptyNode<AnyJs, AnyJs>();\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert, fail } from './assert';\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nvar SortedMap = /** @class */ (function () {\n    function SortedMap(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    SortedMap.prototype.insert = function (key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    };\n    // Returns a copy of the map, with the specified key removed.\n    SortedMap.prototype.remove = function (key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    };\n    // Returns the value of the node with the given key, or null.\n    SortedMap.prototype.get = function (key) {\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    };\n    // Returns the key of the item *before* the specified key, or null if key is\n    // the first item.\n    SortedMap.prototype.getPredecessorKey = function (key) {\n        var node = this.root;\n        var rightParent = null;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                if (!node.left.isEmpty()) {\n                    node = node.left;\n                    while (!node.right.isEmpty())\n                        node = node.right;\n                    return node.key;\n                }\n                else if (rightParent) {\n                    return rightParent.key;\n                }\n                else {\n                    return null; // first item.\n                }\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                rightParent = node;\n                node = node.right;\n            }\n        }\n        throw fail('Attempted to find predecessor key for a nonexistent key.' +\n            '  What gives?');\n    };\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    SortedMap.prototype.indexOf = function (key) {\n        // Number of nodes that were pruned when descending right\n        var prunedNodes = 0;\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    };\n    SortedMap.prototype.isEmpty = function () {\n        return this.root.isEmpty();\n    };\n    Object.defineProperty(SortedMap.prototype, \"size\", {\n        // Returns the total number of nodes in the map.\n        get: function () {\n            return this.root.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Returns the minimum key in the map.\n    SortedMap.prototype.minKey = function () {\n        return this.root.minKey();\n    };\n    // Returns the maximum key in the map.\n    SortedMap.prototype.maxKey = function () {\n        return this.root.maxKey();\n    };\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.inorderTraversal = function (action) {\n        return this.root.inorderTraversal(action);\n    };\n    SortedMap.prototype.forEach = function (fn) {\n        this.inorderTraversal(function (k, v) {\n            fn(k, v);\n            return false;\n        });\n    };\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.reverseTraversal = function (action) {\n        return this.root.reverseTraversal(action);\n    };\n    SortedMap.prototype.getIterator = function (resultGenerator) {\n        return new SortedMapIterator(this.root, null, this.comparator, false, resultGenerator);\n    };\n    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {\n        return new SortedMapIterator(this.root, key, this.comparator, false, resultGenerator);\n    };\n    SortedMap.prototype.getReverseIterator = function (resultGenerator) {\n        return new SortedMapIterator(this.root, null, this.comparator, true, resultGenerator);\n    };\n    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {\n        return new SortedMapIterator(this.root, key, this.comparator, true, resultGenerator);\n    };\n    return SortedMap;\n}()); // end SortedMap\nexport { SortedMap };\n// An iterator over an LLRBNode.\nvar SortedMapIterator = /** @class */ (function () {\n    function SortedMapIterator(node, startKey, comparator, isReverse, resultGenerator) {\n        this.resultGenerator = resultGenerator || null;\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        var cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse)\n                cmp *= -1;\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    SortedMapIterator.prototype.getNext = function () {\n        assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');\n        var node = this.nodeStack.pop();\n        var result;\n        if (this.resultGenerator)\n            result = this.resultGenerator(node.key, node.value);\n        else\n            result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    };\n    SortedMapIterator.prototype.hasNext = function () {\n        return this.nodeStack.length > 0;\n    };\n    SortedMapIterator.prototype.peek = function () {\n        if (this.nodeStack.length === 0)\n            return null;\n        var node = this.nodeStack[this.nodeStack.length - 1];\n        if (this.resultGenerator) {\n            return this.resultGenerator(node.key, node.value);\n        }\n        else {\n            return { key: node.key, value: node.value };\n        }\n    };\n    return SortedMapIterator;\n}()); // end SortedMapIterator\nexport { SortedMapIterator };\n// Represents a node in a Left-leaning Red-Black tree.\nvar LLRBNode = /** @class */ (function () {\n    function LLRBNode(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    LLRBNode.prototype.copy = function (key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    };\n    LLRBNode.prototype.isEmpty = function () {\n        return false;\n    };\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.inorderTraversal = function (action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    };\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.reverseTraversal = function (action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    };\n    // Returns the minimum node in the tree.\n    LLRBNode.prototype.min = function () {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.minKey = function () {\n        return this.min().key;\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.maxKey = function () {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    };\n    // Returns new tree, with the key/value added.\n    LLRBNode.prototype.insert = function (key, value, comparator) {\n        var n = this;\n        var cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.removeMin = function () {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        var n = this;\n        if (!n.left.isRed() && !n.left.left.isRed())\n            n = n.moveRedLeft();\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    };\n    // Returns new tree, with the specified item removed.\n    LLRBNode.prototype.remove = function (key, comparator) {\n        var smallest;\n        var n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed())\n                n = n.rotateRight();\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.isRed = function () {\n        return this.color;\n    };\n    // Returns new tree after performing any needed rotations.\n    LLRBNode.prototype.fixUp = function () {\n        var n = this;\n        if (n.right.isRed() && !n.left.isRed())\n            n = n.rotateLeft();\n        if (n.left.isRed() && n.left.left.isRed())\n            n = n.rotateRight();\n        if (n.left.isRed() && n.right.isRed())\n            n = n.colorFlip();\n        return n;\n    };\n    LLRBNode.prototype.moveRedLeft = function () {\n        var n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.moveRedRight = function () {\n        var n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.rotateLeft = function () {\n        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    };\n    LLRBNode.prototype.rotateRight = function () {\n        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    };\n    LLRBNode.prototype.colorFlip = function () {\n        var left = this.left.copy(null, null, !this.left.color, null, null);\n        var right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    };\n    // For testing.\n    LLRBNode.prototype.checkMaxDepth = function () {\n        var blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    LLRBNode.prototype.check = function () {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n        }\n        if (this.right.isRed()) {\n            throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n        }\n        var blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail('Black depths differ');\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    };\n    LLRBNode.EMPTY = null;\n    LLRBNode.RED = true;\n    LLRBNode.BLACK = false;\n    return LLRBNode;\n}()); // end LLRBNode\nexport { LLRBNode };\n// Represents an empty node (a leaf node in the Red-Black Tree).\nvar LLRBEmptyNode = /** @class */ (function () {\n    function LLRBEmptyNode() {\n        this.size = 0;\n    }\n    // Returns a copy of the current node.\n    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\n        return this;\n    };\n    // Returns a copy of the tree, with the specified key/value added.\n    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\n        return new LLRBNode(key, value);\n    };\n    // Returns a copy of the tree, with the specified key removed.\n    LLRBEmptyNode.prototype.remove = function (key, comparator) {\n        return this;\n    };\n    LLRBEmptyNode.prototype.isEmpty = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.inorderTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.reverseTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.minKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.maxKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.isRed = function () {\n        return false;\n    };\n    // For testing.\n    LLRBEmptyNode.prototype.checkMaxDepth = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.check = function () {\n        return 0;\n    };\n    return LLRBEmptyNode;\n}()); // end LLRBEmptyNode\nexport { LLRBEmptyNode };\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n\n"]}