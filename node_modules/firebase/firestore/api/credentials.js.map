{"version":3,"sources":["src/firestore/api/credentials.ts","firestore/api/credentials.js"],"names":["makeCredentialsProvider","OAuthToken","value","user","type","authHeaders","Authorization","EmptyCredentialsProvider","userListener","prototype","getToken","forceRefresh","resolve","setUserChangeListener","listener","UNAUTHENTICATED","removeUserChangeListener","FirebaseCredentialsProvider","app","_this","tokenListener","userCounter","newUser","getUser","currentUser","equals","INTERNAL","addAuthTokenListener","initialUserCounter","then","tokenData","ABORTED","accessToken","removeAuthTokenListener","getUid","currentUid","GoogleCredentialsProvider","authClient","reject","error","tokenLiteral","GOOGLE_CREDENTIALS","FirstPartyToken","gapi","sessionIndex","FIRST_PARTY","Object","defineProperty","get","enumerable","configurable","FirstPartyCredentialsProvider","credentials","client","INVALID_ARGUMENT"],"mappings":"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","file":"credentials.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { AnyJs } from '../util/misc';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\n// TODO(mikelehen): This should be split into multiple files and probably\n// moved to an auth/ folder to match other platforms.\n\nexport interface FirstPartyCredentialsSettings {\n  type: 'gapi';\n  client: Gapi;\n  sessionIndex: string;\n}\n\nexport interface GoogleAuthCredentialsSettings {\n  type: 'google-auth';\n  client: GoogleAuthClient;\n}\n\nexport interface ProviderCredentialsSettings {\n  type: 'provider';\n  client: CredentialsProvider;\n}\n\n/** Settings for private credentials */\nexport type CredentialsSettings =\n  | FirstPartyCredentialsSettings\n  | GoogleAuthCredentialsSettings\n  | ProviderCredentialsSettings;\n\nexport type TokenType = 'OAuth' | 'FirstParty';\nexport interface Token {\n  /** Type of token. */\n  type: TokenType;\n\n  /**\n   * The user with which the token is associated (used for persisting user\n   * state on disk, etc.).\n   */\n  user: User;\n\n  /** Extra header values to be passed along with a request */\n  authHeaders: { [header: string]: string };\n}\n\nexport class OAuthToken implements Token {\n  type = 'OAuth' as TokenType;\n  authHeaders: { [header: string]: string };\n  constructor(value: string, public user: User) {\n    this.authHeaders = { Authorization: `Bearer ${value}` };\n  }\n}\n\n/**\n * A Listener for user change events.\n */\nexport type UserListener = (user: User) => void;\n\n/**\n * Provides methods for getting the uid and token for the current user and\n * listening for changes.\n */\nexport interface CredentialsProvider {\n  /**\n   * Requests a token for the current user, optionally forcing a refreshed\n   * token to be fetched.\n   */\n  getToken(forceRefresh: boolean): Promise<Token | null>;\n\n  /**\n   * Specifies a listener to be notified of user changes (sign-in / sign-out).\n   * It immediately called once with the initial user.\n   */\n  setUserChangeListener(listener: UserListener): void;\n\n  /** Removes the previously-set user change listener. */\n  removeUserChangeListener(): void;\n}\n\n/** A CredentialsProvider that always yields an empty token. */\nexport class EmptyCredentialsProvider implements CredentialsProvider {\n  /**\n   * Stores the User listener registered with setUserChangeListener()\n   * This isn't actually necessary since the UID never changes, but we use this\n   * to verify the listen contract is adhered to in tests.\n   */\n  private userListener: UserListener | null = null;\n\n  constructor() {}\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    return Promise.resolve<Token | null>(null);\n  }\n\n  setUserChangeListener(listener: UserListener): void {\n    assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n    this.userListener = listener;\n    // Fire with initial user.\n    listener(User.UNAUTHENTICATED);\n  }\n\n  removeUserChangeListener(): void {\n    assert(\n      this.userListener !== null,\n      'removeUserChangeListener() when no listener registered'\n    );\n    this.userListener = null;\n  }\n}\n\nexport class FirebaseCredentialsProvider implements CredentialsProvider {\n  /**\n   * The auth token listener registered with FirebaseApp, retained here so we\n   * can unregister it.\n   */\n  private tokenListener: ((token: string | null) => void) | null = null;\n\n  /** Tracks the current User. */\n  private currentUser: User;\n\n  /**\n   * Counter used to detect if the user changed while a getToken request was\n   * outstanding.\n   */\n  private userCounter = 0;\n\n  /** The User listener registered with setUserChangeListener(). */\n  private userListener: UserListener | null = null;\n\n  constructor(private readonly app: firebase.app.App) {\n    // We listen for token changes but all we really care about is knowing when\n    // the uid may have changed.\n    this.tokenListener = () => {\n      const newUser = this.getUser();\n      if (!this.currentUser || !newUser.equals(this.currentUser)) {\n        this.currentUser = newUser;\n        this.userCounter++;\n        if (this.userListener) {\n          this.userListener(this.currentUser);\n        }\n      }\n    };\n\n    this.userCounter = 0;\n\n    // Will fire at least once where we set this.currentUser\n    this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n  }\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    assert(\n      this.tokenListener != null,\n      'getToken cannot be called after listener removed.'\n    );\n\n    // Take note of the current value of the userCounter so that this method can\n    // fail (with an ABORTED error) if there is a user change while the request\n    // is outstanding.\n    const initialUserCounter = this.userCounter;\n    return this.app.INTERNAL.getToken(forceRefresh).then(tokenData => {\n      // Cancel the request since the user changed while the request was\n      // outstanding so the response is likely for a previous user (which\n      // user, we can't be sure).\n      if (this.userCounter !== initialUserCounter) {\n        throw new FirestoreError(\n          Code.ABORTED,\n          'getToken aborted due to uid change.'\n        );\n      } else {\n        if (tokenData) {\n          assert(\n            typeof tokenData.accessToken === 'string',\n            'Invalid tokenData returned from getToken():' + tokenData\n          );\n          return new OAuthToken(tokenData.accessToken, this.currentUser);\n        } else {\n          return null;\n        }\n      }\n    });\n  }\n\n  setUserChangeListener(listener: UserListener): void {\n    assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n    this.userListener = listener;\n\n    // Fire the initial event, but only if we received the initial user\n    if (this.currentUser) {\n      listener(this.currentUser);\n    }\n  }\n\n  removeUserChangeListener(): void {\n    assert(\n      this.tokenListener != null,\n      'removeUserChangeListener() called twice'\n    );\n    assert(\n      this.userListener !== null,\n      'removeUserChangeListener() called when no listener registered'\n    );\n    this.app.INTERNAL.removeAuthTokenListener(this.tokenListener!);\n    this.tokenListener = null;\n    this.userListener = null;\n  }\n\n  private getUser(): User {\n    // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n    if (typeof this.app.INTERNAL.getUid !== 'function') {\n      fail(\n        'This version of the Firestore SDK requires at least version' +\n          ' 3.7.0 of firebase.js.'\n      );\n    }\n    const currentUid = this.app.INTERNAL.getUid();\n    assert(\n      currentUid === null || typeof currentUid === 'string',\n      'Received invalid UID: ' + currentUid\n    );\n    return new User(currentUid);\n  }\n}\n\n// Wrap a google-auth-library client as a CredentialsProvider.\n// NOTE: grpc-connection can natively accept a google-auth-library\n// client via createFromGoogleCredential(), but we opt to plumb the tokens\n// through our CredentialsProvider interface, at least for now.\nexport class GoogleCredentialsProvider implements CredentialsProvider {\n  constructor(private authClient: GoogleAuthClient) {}\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    return new Promise<Token | null>((resolve, reject) => {\n      // TODO(b/32935141): ideally this would be declared as an extern\n      this.authClient[\n        'getAccessToken'\n      ]((error: AnyJs, tokenLiteral: string) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(new OAuthToken(tokenLiteral, User.GOOGLE_CREDENTIALS));\n        }\n      });\n    });\n  }\n\n  // NOTE: A google-auth-library client represents an immutable \"user\", so\n  // once we fire the initial event, it'll never change.\n  setUserChangeListener(listener: UserListener): void {\n    // Fire with initial uid.\n    listener(User.GOOGLE_CREDENTIALS);\n  }\n\n  removeUserChangeListener(): void {}\n}\n\n/**\n * Very incomplete typing for an auth client from\n * https://github.com/google/google-auth-library-nodejs/\n */\nexport interface GoogleAuthClient {\n  getAccessToken(callback: (error?: Error, token?: string) => void): void;\n}\n// TODO(b/32935141): Ideally gapi type would be declared as an extern\n// tslint:disable-next-line:no-any\nexport type Gapi = any;\n\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\nexport class FirstPartyToken implements Token {\n  type = 'FirstParty' as TokenType;\n  user = User.FIRST_PARTY;\n\n  constructor(private gapi: Gapi, private sessionIndex: string) {\n    assert(\n      this.gapi &&\n        this.gapi['auth'] &&\n        this.gapi['auth']['getAuthHeaderValueForFirstParty'],\n      'unexpected gapi interface'\n    );\n  }\n\n  get authHeaders(): { [header: string]: string } {\n    return {\n      Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n      'X-Goog-AuthUser': this.sessionIndex\n    };\n  }\n}\n\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nexport class FirstPartyCredentialsProvider implements CredentialsProvider {\n  constructor(private gapi: Gapi, private sessionIndex: string) {\n    assert(\n      this.gapi &&\n        this.gapi['auth'] &&\n        this.gapi['auth']['getAuthHeaderValueForFirstParty'],\n      'unexpected gapi interface'\n    );\n  }\n\n  getToken(forceRefresh: boolean): Promise<Token | null> {\n    return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\n  }\n\n  // TODO(33108925): can someone switch users w/o a page refresh?\n  // TODO(33110621): need to understand token/session lifecycle\n  setUserChangeListener(listener: UserListener): void {\n    // Fire with initial uid.\n    listener(User.FIRST_PARTY);\n  }\n\n  removeUserChangeListener(): void {}\n}\n\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nexport function makeCredentialsProvider(credentials?: CredentialsSettings) {\n  if (!credentials) {\n    return new EmptyCredentialsProvider();\n  }\n\n  switch (credentials.type) {\n    case 'google-auth':\n      return new GoogleCredentialsProvider(credentials.client);\n\n    case 'gapi':\n      return new FirstPartyCredentialsProvider(\n        credentials.client,\n        credentials.sessionIndex || '0'\n      );\n\n    case 'provider':\n      return credentials.client;\n\n    default:\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'makeCredentialsProvider failed due to invalid credential type'\n      );\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { User } from '../auth/user';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { PromiseImpl as Promise } from '../../utils/promise';\nvar OAuthToken = /** @class */ (function () {\n    function OAuthToken(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.authHeaders = { Authorization: \"Bearer \" + value };\n    }\n    return OAuthToken;\n}());\nexport { OAuthToken };\n/** A CredentialsProvider that always yields an empty token. */\nvar EmptyCredentialsProvider = /** @class */ (function () {\n    function EmptyCredentialsProvider() {\n        /**\n         * Stores the User listener registered with setUserChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.userListener = null;\n    }\n    EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(null);\n    };\n    EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire with initial user.\n        listener(User.UNAUTHENTICATED);\n    };\n    EmptyCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');\n        this.userListener = null;\n    };\n    return EmptyCredentialsProvider;\n}());\nexport { EmptyCredentialsProvider };\nvar FirebaseCredentialsProvider = /** @class */ (function () {\n    function FirebaseCredentialsProvider(app) {\n        var _this = this;\n        this.app = app;\n        /**\n         * The auth token listener registered with FirebaseApp, retained here so we\n         * can unregister it.\n         */\n        this.tokenListener = null;\n        /**\n         * Counter used to detect if the user changed while a getToken request was\n         * outstanding.\n         */\n        this.userCounter = 0;\n        /** The User listener registered with setUserChangeListener(). */\n        this.userListener = null;\n        // We listen for token changes but all we really care about is knowing when\n        // the uid may have changed.\n        this.tokenListener = function () {\n            var newUser = _this.getUser();\n            if (!_this.currentUser || !newUser.equals(_this.currentUser)) {\n                _this.currentUser = newUser;\n                _this.userCounter++;\n                if (_this.userListener) {\n                    _this.userListener(_this.currentUser);\n                }\n            }\n        };\n        this.userCounter = 0;\n        // Will fire at least once where we set this.currentUser\n        this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n    }\n    FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');\n        // Take note of the current value of the userCounter so that this method can\n        // fail (with an ABORTED error) if there is a user change while the request\n        // is outstanding.\n        var initialUserCounter = this.userCounter;\n        return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {\n            // Cancel the request since the user changed while the request was\n            // outstanding so the response is likely for a previous user (which\n            // user, we can't be sure).\n            if (_this.userCounter !== initialUserCounter) {\n                throw new FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');\n            }\n            else {\n                if (tokenData) {\n                    assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);\n                    return new OAuthToken(tokenData.accessToken, _this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    };\n    FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire the initial event, but only if we received the initial user\n        if (this.currentUser) {\n            listener(this.currentUser);\n        }\n    };\n    FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.tokenListener != null, 'removeUserChangeListener() called twice');\n        assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');\n        this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);\n        this.tokenListener = null;\n        this.userListener = null;\n    };\n    FirebaseCredentialsProvider.prototype.getUser = function () {\n        // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n        if (typeof this.app.INTERNAL.getUid !== 'function') {\n            fail('This version of the Firestore SDK requires at least version' +\n                ' 3.7.0 of firebase.js.');\n        }\n        var currentUid = this.app.INTERNAL.getUid();\n        assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);\n        return new User(currentUid);\n    };\n    return FirebaseCredentialsProvider;\n}());\nexport { FirebaseCredentialsProvider };\n// Wrap a google-auth-library client as a CredentialsProvider.\n// NOTE: grpc-connection can natively accept a google-auth-library\n// client via createFromGoogleCredential(), but we opt to plumb the tokens\n// through our CredentialsProvider interface, at least for now.\nvar GoogleCredentialsProvider = /** @class */ (function () {\n    function GoogleCredentialsProvider(authClient) {\n        this.authClient = authClient;\n    }\n    GoogleCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // TODO(b/32935141): ideally this would be declared as an extern\n            _this.authClient['getAccessToken'](function (error, tokenLiteral) {\n                if (error) {\n                    reject(error);\n                }\n                else {\n                    resolve(new OAuthToken(tokenLiteral, User.GOOGLE_CREDENTIALS));\n                }\n            });\n        });\n    };\n    // NOTE: A google-auth-library client represents an immutable \"user\", so\n    // once we fire the initial event, it'll never change.\n    GoogleCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        // Fire with initial uid.\n        listener(User.GOOGLE_CREDENTIALS);\n    };\n    GoogleCredentialsProvider.prototype.removeUserChangeListener = function () { };\n    return GoogleCredentialsProvider;\n}());\nexport { GoogleCredentialsProvider };\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\nvar FirstPartyToken = /** @class */ (function () {\n    function FirstPartyToken(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    Object.defineProperty(FirstPartyToken.prototype, \"authHeaders\", {\n        get: function () {\n            return {\n                Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n                'X-Goog-AuthUser': this.sessionIndex\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FirstPartyToken;\n}());\nexport { FirstPartyToken };\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nvar FirstPartyCredentialsProvider = /** @class */ (function () {\n    function FirstPartyCredentialsProvider(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\n    };\n    // TODO(33108925): can someone switch users w/o a page refresh?\n    // TODO(33110621): need to understand token/session lifecycle\n    FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        // Fire with initial uid.\n        listener(User.FIRST_PARTY);\n    };\n    FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () { };\n    return FirstPartyCredentialsProvider;\n}());\nexport { FirstPartyCredentialsProvider };\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nexport function makeCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new EmptyCredentialsProvider();\n    }\n    switch (credentials.type) {\n        case 'google-auth':\n            return new GoogleCredentialsProvider(credentials.client);\n        case 'gapi':\n            return new FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');\n        case 'provider':\n            return credentials.client;\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n\n"]}