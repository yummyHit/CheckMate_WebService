{"version":3,"sources":["src/firestore/api/user_data_converter.ts","firestore/api/user_data_converter.js"],"names":["fieldPathFromArgument","objUtils","typeUtils","RESERVED_FIELD_REGEX","ParsedSetData","data","fieldMask","fieldTransforms","prototype","toMutations","key","precondition","mutations","push","length","ParsedUpdateData","UserDataSource","ParseContext","dataSource","methodName","path","undefined","validatePath","childContext","field","childPath","child","context","validatePathSegment","createError","reason","fieldDescription","isEmpty","toString","INVALID_ARGUMENT","i","get","segment","isWrite","test","Set","Update","DocumentKeyReference","databaseId","UserDataConverter","preConverter","parseSetData","input","options","_this","EMPTY_PATH","validatePlainObject","merge","updateData","EMPTY","forEach","value","_internalPath","runPreConverter","parsedValue","parseData","set","parseUpdateData","fieldMaskPaths","fieldPathFromDotSeparatedString","mask","parseUpdateVarargs","moreFieldsAndValues","keys","values","value_1","parseQueryValue","QueryValue","parsed","e","message","errorMessage","Array","parseArray","looksLikeJsonObject","parseObject","parseScalarValue","array","result","entryIndex","_i","array_1","entry","parsedEntry","INSTANCE","obj","val","insert","isSafeInteger","of","Date","fromDate","instance","description","error","Error"],"mappings":"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","file":"user_data_converter.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from 'firestore';\n\nimport { DatabaseId } from '../core/database_info';\nimport { Timestamp } from '../core/timestamp';\nimport { DocumentKey } from '../model/document_key';\nimport { FieldValue, ObjectValue } from '../model/field_value';\nimport {\n  ArrayValue,\n  BlobValue,\n  BooleanValue,\n  DoubleValue,\n  GeoPointValue,\n  IntegerValue,\n  NullValue,\n  RefValue,\n  StringValue,\n  TimestampValue\n} from '../model/field_value';\nimport {\n  FieldMask,\n  FieldTransform,\n  Mutation,\n  PatchMutation,\n  Precondition,\n  ServerTimestampTransform,\n  SetMutation,\n  TransformMutation\n} from '../model/mutation';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isPlainObject, valueDescription } from '../util/input_validation';\nimport { AnyJs, primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { Dict } from '../util/obj';\nimport { SortedMap } from '../util/sorted_map';\nimport * as typeUtils from '../util/types';\n\nimport { Blob } from './blob';\nimport {\n  FieldPath as ExternalFieldPath,\n  fromDotSeparatedString\n} from './field_path';\nimport {\n  DeleteFieldValueImpl,\n  FieldValueImpl,\n  ServerTimestampFieldValueImpl\n} from './field_value';\nimport { GeoPoint } from './geo_point';\n\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\n\n/** The result of parsing document data (e.g. for a setData call). */\nexport class ParsedSetData {\n  constructor(\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask | null,\n    readonly fieldTransforms: FieldTransform[]\n  ) {}\n\n  toMutations(key: DocumentKey, precondition: Precondition): Mutation[] {\n    const mutations = [] as Mutation[];\n    if (this.fieldMask !== null) {\n      mutations.push(\n        new PatchMutation(key, this.data, this.fieldMask, precondition)\n      );\n    } else {\n      mutations.push(new SetMutation(key, this.data, precondition));\n    }\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n    return mutations;\n  }\n}\n\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nexport class ParsedUpdateData {\n  constructor(\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask,\n    readonly fieldTransforms: FieldTransform[]\n  ) {}\n\n  toMutations(key: DocumentKey, precondition: Precondition): Mutation[] {\n    const mutations = [\n      new PatchMutation(key, this.data, this.fieldMask, precondition)\n    ] as Mutation[];\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n    return mutations;\n  }\n}\n\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nenum UserDataSource {\n  Set,\n  Update,\n  QueryValue // from a where clause or cursor bound\n}\n\n/** A \"context\" object passed around while parsing user data. */\nclass ParseContext {\n  readonly fieldTransforms: FieldTransform[];\n  readonly fieldMask: FieldPath[];\n  /**\n   * Initializes a ParseContext with the given source and path.\n   *\n   * @param dataSource Indicates what kind of API method this data came from.\n   * @param path A path within the object being parsed. This could be an empty\n   * path (in which case the context represents the root of the data being\n   * parsed), or a nonempty path (indicating the context represents a nested\n   * location within the data).\n   *\n   * TODO(b/34871131): We don't support array paths right now, so path can be\n   * null to indicate the context represents any location within an array (in\n   * which case certain features will not work and errors will be somewhat\n   * compromised).\n   * @param fieldTransforms A mutable list of field transforms encountered while\n   * parsing the data.\n   * @param fieldMask A mutable list of field paths encountered while parsing \n   * the data.\n   */\n  constructor(\n    readonly dataSource: UserDataSource,\n    readonly methodName: string,\n    readonly path: FieldPath | null,\n    fieldTransforms?: FieldTransform[],\n    fieldMask?: FieldPath[]\n  ) {\n    // Minor hack: If fieldTransforms is undefined, we assume this is an\n    // external call and we need to validate the entire path.\n    if (fieldTransforms === undefined) {\n      this.validatePath();\n    }\n    this.fieldTransforms = fieldTransforms || [];\n    this.fieldMask = fieldMask || [];\n  }\n\n  childContext(field: string | FieldPath | number): ParseContext {\n    let childPath: FieldPath | null;\n    if (typeof field === 'number') {\n      // TODO(b/34871131): We don't support array paths right now; so make path\n      // null.\n      childPath = null;\n    } else {\n      childPath = this.path == null ? null : this.path.child(field);\n    }\n    const context = new ParseContext(\n      this.dataSource,\n      this.methodName,\n      childPath,\n      this.fieldTransforms,\n      this.fieldMask\n    );\n    if (typeof field === 'string') {\n      // We only need to validate the new segment.\n      context.validatePathSegment(field);\n    } else if (typeof field === 'object' && field instanceof FieldPath) {\n      // Validate the whole path.\n      context.validatePath();\n    }\n    return context;\n  }\n\n  createError(reason: string): Error {\n    const fieldDescription =\n      this.path === null || this.path.isEmpty()\n        ? ''\n        : ` (found in field ${this.path.toString()})`;\n    return new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${this.methodName}() called with invalid data. ` +\n        reason +\n        fieldDescription\n    );\n  }\n\n  private validatePath() {\n    // TODO(b/34871131): Remove null check once we have proper paths for fields\n    // within arrays.\n    if (this.path === null) {\n      return;\n    }\n    for (let i = 0; i < this.path.length; i++) {\n      this.validatePathSegment(this.path.get(i));\n    }\n  }\n\n  private validatePathSegment(segment: string) {\n    if (this.isWrite() && RESERVED_FIELD_REGEX.test(segment)) {\n      throw this.createError('Document fields cannot begin and end with __');\n    }\n  }\n\n  private isWrite(): boolean {\n    return (\n      this.dataSource === UserDataSource.Set ||\n      this.dataSource === UserDataSource.Update\n    );\n  }\n}\n/**\n * An interface that allows arbitrary pre-converting of user data. This\n * abstraction allows for, e.g.:\n *  * The public API to convert DocumentReference objects to DocRef objects,\n *    avoiding a circular dependency between user_data_converter.ts and\n *    database.ts\n *  * Tests to convert test-only sentinels (e.g. '<DELETE>') into types\n *    compatible with UserDataConverter.\n *\n * Returns the converted value (can return back the input to act as a no-op).\n *\n * It can also throw an Error which will be wrapped into a friendly message.\n */\nexport type DataPreConverter = (input: AnyJs) => AnyJs;\n\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\nexport class DocumentKeyReference {\n  constructor(public databaseId: DatabaseId, public key: DocumentKey) {}\n}\n\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nexport class UserDataConverter {\n  constructor(private preConverter: DataPreConverter) {}\n\n  /** Parse document data (e.g. from a set() call). */\n  parseSetData(\n    methodName: string,\n    input: AnyJs,\n    options: firestore.SetOptions\n  ): ParsedSetData {\n    const context = new ParseContext(\n      UserDataSource.Set,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    const merge = options.merge !== undefined ? options.merge : false;\n\n    let updateData = ObjectValue.EMPTY;\n\n    objUtils.forEach(input as Dict<AnyJs>, (key, value) => {\n      const path = new ExternalFieldPath(key)._internalPath;\n\n      const childContext = context.childContext(path);\n      value = this.runPreConverter(value, childContext);\n\n      const parsedValue = this.parseData(value, childContext);\n      if (parsedValue) {\n        updateData = updateData.set(path, parsedValue);\n      }\n    });\n\n    const fieldMask = merge ? new FieldMask(context.fieldMask) : null;\n    return new ParsedSetData(updateData, fieldMask, context.fieldTransforms);\n  }\n\n  /** Parse update data (e.g. from an update() call). */\n  parseUpdateData(methodName: string, input: AnyJs): ParsedUpdateData {\n    const context = new ParseContext(\n      UserDataSource.Update,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    const fieldMaskPaths = [] as FieldPath[];\n    let updateData = ObjectValue.EMPTY;\n    objUtils.forEach(input as Dict<AnyJs>, (key, value) => {\n      const path = fieldPathFromDotSeparatedString(methodName, key);\n\n      const childContext = context.childContext(path);\n      value = this.runPreConverter(value, childContext);\n      if (value instanceof DeleteFieldValueImpl) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        const parsedValue = this.parseData(value, childContext);\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData = updateData.set(path, parsedValue);\n        }\n      }\n    });\n\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n  }\n\n  /** Parse update data from a list of field/value arguments. */\n  parseUpdateVarargs(\n    methodName: string,\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    moreFieldsAndValues: AnyJs[]\n  ): ParsedUpdateData {\n    const context = new ParseContext(\n      UserDataSource.Update,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    const keys = [fieldPathFromArgument(methodName, field)];\n    const values = [value];\n\n    if (moreFieldsAndValues.length % 2 !== 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Function ${methodName}() needs to be called with an even number ` +\n          'of arguments that alternate between field names and values.'\n      );\n    }\n\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\n      keys.push(\n        fieldPathFromArgument(methodName, moreFieldsAndValues[i] as\n          | string\n          | ExternalFieldPath)\n      );\n      values.push(moreFieldsAndValues[i + 1]);\n    }\n\n    const fieldMaskPaths = [] as FieldPath[];\n    let updateData = ObjectValue.EMPTY;\n\n    for (let i = 0; i < keys.length; ++i) {\n      const path = keys[i];\n      const childContext = context.childContext(path);\n      const value = this.runPreConverter(values[i], childContext);\n      if (value instanceof DeleteFieldValueImpl) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        const parsedValue = this.parseData(value, childContext);\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData = updateData.set(path, parsedValue);\n        }\n      }\n    }\n\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n  }\n\n  /**\n   * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n   * bound).\n   */\n  parseQueryValue(methodName: string, input: AnyJs): FieldValue {\n    const context = new ParseContext(\n      UserDataSource.QueryValue,\n      methodName,\n      FieldPath.EMPTY_PATH\n    );\n    const parsed = this.parseData(input, context);\n    assert(parsed != null, 'Parsed data should not be null.');\n    assert(\n      context.fieldTransforms.length === 0,\n      'Field transforms should have been disallowed.'\n    );\n    return parsed!;\n  }\n\n  /** Sends data through this.preConverter, handling any thrown errors. */\n  private runPreConverter(input: AnyJs, context: ParseContext): AnyJs {\n    try {\n      return this.preConverter(input);\n    } catch (e) {\n      const message = errorMessage(e);\n      throw context.createError(message);\n    }\n  }\n\n  /**\n   * Internal helper for parsing user data.\n   *\n   * @param input Data to be parsed.\n   * @param context A context object representing the current path being parsed,\n   * the source of the data being parsed, etc.\n   * @return The parsed value, or null if the value was a FieldValue sentinel\n   * that should not be included in the resulting parsed data.\n   */\n  private parseData(input: AnyJs, context: ParseContext): FieldValue | null {\n    input = this.runPreConverter(input, context);\n    if (input instanceof Array) {\n      // TODO(b/34871131): We may need a different way to detect nested arrays\n      // once we support array paths (at which point we should include the path\n      // containing the array in the error message).\n      if (!context.path) {\n        throw context.createError('Nested arrays are not supported');\n      }\n      // We don't support field mask paths more granular than the top-level\n      // array.\n      context.fieldMask.push(context.path);\n      return this.parseArray(input as AnyJs[], context);\n    } else if (looksLikeJsonObject(input)) {\n      validatePlainObject('Unsupported field value:', context, input);\n      return this.parseObject(input as Dict<AnyJs>, context);\n    } else {\n      // If context.path is null, we are inside an array and we should have\n      // already added the root of the array to the field mask.\n      if (context.path) {\n        context.fieldMask.push(context.path);\n      }\n      return this.parseScalarValue(input, context);\n    }\n  }\n\n  private parseArray(array: AnyJs[], context: ParseContext): FieldValue {\n    const result = [] as FieldValue[];\n    let entryIndex = 0;\n    for (const entry of array) {\n      let parsedEntry = this.parseData(entry, context.childContext(entryIndex));\n      if (parsedEntry == null) {\n        // Just include nulls in the array for fields being replaced with a\n        // sentinel.\n        parsedEntry = NullValue.INSTANCE;\n      }\n      result.push(parsedEntry);\n      entryIndex++;\n    }\n    return new ArrayValue(result);\n  }\n\n  private parseObject(obj: Dict<AnyJs>, context: ParseContext): FieldValue {\n    let result = new SortedMap<string, FieldValue>(primitiveComparator);\n    objUtils.forEach(obj, (key: string, val: AnyJs) => {\n      const parsedValue = this.parseData(val, context.childContext(key));\n      if (parsedValue != null) {\n        result = result.insert(key, parsedValue);\n      }\n    });\n    return new ObjectValue(result);\n  }\n\n  /**\n   * Helper to parse a scalar value (i.e. not an Object or Array)\n   *\n   * @return The parsed value, or null if the value was a FieldValue sentinel\n   * that should not be included in the resulting parsed data.\n   */\n  private parseScalarValue(\n    value: AnyJs,\n    context: ParseContext\n  ): FieldValue | null {\n    if (value === null) {\n      return NullValue.INSTANCE;\n    } else if (typeof value === 'number') {\n      if (typeUtils.isSafeInteger(value)) {\n        return new IntegerValue(value);\n      } else {\n        return new DoubleValue(value);\n      }\n    } else if (typeof value === 'boolean') {\n      return BooleanValue.of(value);\n    } else if (typeof value === 'string') {\n      return new StringValue(value);\n    } else if (value instanceof Date) {\n      return new TimestampValue(Timestamp.fromDate(value));\n    } else if (value instanceof GeoPoint) {\n      return new GeoPointValue(value);\n    } else if (value instanceof Blob) {\n      return new BlobValue(value);\n    } else if (value instanceof DocumentKeyReference) {\n      return new RefValue(value.databaseId, value.key);\n    } else if (value instanceof FieldValueImpl) {\n      if (value instanceof DeleteFieldValueImpl) {\n        // We shouldn't encounter delete sentinels here. Provide a good error.\n        if (context.dataSource !== UserDataSource.Update) {\n          throw context.createError(\n            'FieldValue.delete() can only be used with update()'\n          );\n        } else {\n          assert(\n            context.path == null || context.path.length > 0,\n            'FieldValue.delete() at the top level should have already' +\n              ' been handled.'\n          );\n          throw context.createError(\n            'FieldValue.delete() can only appear at the top level ' +\n              'of your update data'\n          );\n        }\n      } else if (value instanceof ServerTimestampFieldValueImpl) {\n        if (\n          context.dataSource !== UserDataSource.Set &&\n          context.dataSource !== UserDataSource.Update\n        ) {\n          throw context.createError(\n            'FieldValue.serverTimestamp() can only be used with set()' +\n              ' and update()'\n          );\n        }\n        if (context.path === null) {\n          throw context.createError(\n            'FieldValue.serverTimestamp() is not currently' +\n              ' supported inside arrays'\n          );\n        }\n        context.fieldTransforms.push(\n          new FieldTransform(context.path, ServerTimestampTransform.instance)\n        );\n\n        // Return null so this value is omitted from the parsed result.\n        return null;\n      } else {\n        return fail('Unknown FieldValue type: ' + value);\n      }\n    } else {\n      throw context.createError(\n        `Unsupported field value: ${valueDescription(value)}`\n      );\n    }\n  }\n}\n\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input: AnyJs): boolean {\n  return (\n    typeof input === 'object' &&\n    input !== null &&\n    !(input instanceof Array) &&\n    !(input instanceof Date) &&\n    !(input instanceof GeoPoint) &&\n    !(input instanceof Blob) &&\n    !(input instanceof DocumentKeyReference) &&\n    !(input instanceof FieldValueImpl)\n  );\n}\n\nfunction validatePlainObject(\n  message: string,\n  context: ParseContext,\n  input: AnyJs\n) {\n  if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n    const description = valueDescription(input);\n    if (description === 'an object') {\n      // Massage the error if it was an object.\n      throw context.createError(message + ' a custom object');\n    } else {\n      throw context.createError(message + ' ' + description);\n    }\n  }\n}\n\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nexport function fieldPathFromArgument(\n  methodName: string,\n  path: string | ExternalFieldPath\n): FieldPath {\n  if (path instanceof ExternalFieldPath) {\n    return path._internalPath;\n  } else if (typeof path === 'string') {\n    return fieldPathFromDotSeparatedString(methodName, path);\n  } else {\n    const message = 'Field path arguments must be of type string or FieldPath.';\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${methodName}() called with invalid data. ${message}`\n    );\n  }\n}\n\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nfunction fieldPathFromDotSeparatedString(\n  methodName: string,\n  path: string\n): FieldPath {\n  try {\n    return fromDotSeparatedString(path)._internalPath;\n  } catch (e) {\n    const message = errorMessage(e);\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${methodName}() called with invalid data. ${message}`\n    );\n  }\n}\n\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error: Error | object): string {\n  return error instanceof Error ? error.message : error.toString();\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Timestamp } from '../core/timestamp';\nimport { ObjectValue } from '../model/field_value';\nimport { ArrayValue, BlobValue, BooleanValue, DoubleValue, GeoPointValue, IntegerValue, NullValue, RefValue, StringValue, TimestampValue } from '../model/field_value';\nimport { FieldMask, FieldTransform, PatchMutation, ServerTimestampTransform, SetMutation, TransformMutation } from '../model/mutation';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isPlainObject, valueDescription } from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { SortedMap } from '../util/sorted_map';\nimport * as typeUtils from '../util/types';\nimport { Blob } from './blob';\nimport { FieldPath as ExternalFieldPath, fromDotSeparatedString } from './field_path';\nimport { DeleteFieldValueImpl, FieldValueImpl, ServerTimestampFieldValueImpl } from './field_value';\nimport { GeoPoint } from './geo_point';\nvar RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nvar ParsedSetData = /** @class */ (function () {\n    function ParsedSetData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedSetData.prototype.toMutations = function (key, precondition) {\n        var mutations = [];\n        if (this.fieldMask !== null) {\n            mutations.push(new PatchMutation(key, this.data, this.fieldMask, precondition));\n        }\n        else {\n            mutations.push(new SetMutation(key, this.data, precondition));\n        }\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedSetData;\n}());\nexport { ParsedSetData };\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nvar ParsedUpdateData = /** @class */ (function () {\n    function ParsedUpdateData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedUpdateData.prototype.toMutations = function (key, precondition) {\n        var mutations = [\n            new PatchMutation(key, this.data, this.fieldMask, precondition)\n        ];\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedUpdateData;\n}());\nexport { ParsedUpdateData };\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nvar UserDataSource;\n(function (UserDataSource) {\n    UserDataSource[UserDataSource[\"Set\"] = 0] = \"Set\";\n    UserDataSource[UserDataSource[\"Update\"] = 1] = \"Update\";\n    UserDataSource[UserDataSource[\"QueryValue\"] = 2] = \"QueryValue\"; // from a where clause or cursor bound\n})(UserDataSource || (UserDataSource = {}));\n/** A \"context\" object passed around while parsing user data. */\nvar ParseContext = /** @class */ (function () {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param dataSource Indicates what kind of API method this data came from.\n     * @param path A path within the object being parsed. This could be an empty\n     * path (in which case the context represents the root of the data being\n     * parsed), or a nonempty path (indicating the context represents a nested\n     * location within the data).\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     * @param fieldTransforms A mutable list of field transforms encountered while\n     * parsing the data.\n     * @param fieldMask A mutable list of field paths encountered while parsing\n     * the data.\n     */\n    function ParseContext(dataSource, methodName, path, fieldTransforms, fieldMask) {\n        this.dataSource = dataSource;\n        this.methodName = methodName;\n        this.path = path;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    ParseContext.prototype.childContext = function (field) {\n        var childPath;\n        if (typeof field === 'number') {\n            // TODO(b/34871131): We don't support array paths right now; so make path\n            // null.\n            childPath = null;\n        }\n        else {\n            childPath = this.path == null ? null : this.path.child(field);\n        }\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, this.fieldTransforms, this.fieldMask);\n        if (typeof field === 'string') {\n            // We only need to validate the new segment.\n            context.validatePathSegment(field);\n        }\n        else if (typeof field === 'object' && field instanceof FieldPath) {\n            // Validate the whole path.\n            context.validatePath();\n        }\n        return context;\n    };\n    ParseContext.prototype.createError = function (reason) {\n        var fieldDescription = this.path === null || this.path.isEmpty()\n            ? ''\n            : \" (found in field \" + this.path.toString() + \")\";\n        return new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" +\n            reason +\n            fieldDescription);\n    };\n    ParseContext.prototype.validatePath = function () {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (this.path === null) {\n            return;\n        }\n        for (var i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    };\n    ParseContext.prototype.validatePathSegment = function (segment) {\n        if (this.isWrite() && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with __');\n        }\n    };\n    ParseContext.prototype.isWrite = function () {\n        return (this.dataSource === UserDataSource.Set ||\n            this.dataSource === UserDataSource.Update);\n    };\n    return ParseContext;\n}());\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\nvar DocumentKeyReference = /** @class */ (function () {\n    function DocumentKeyReference(databaseId, key) {\n        this.databaseId = databaseId;\n        this.key = key;\n    }\n    return DocumentKeyReference;\n}());\nexport { DocumentKeyReference };\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nvar UserDataConverter = /** @class */ (function () {\n    function UserDataConverter(preConverter) {\n        this.preConverter = preConverter;\n    }\n    /** Parse document data (e.g. from a set() call). */\n    UserDataConverter.prototype.parseSetData = function (methodName, input, options) {\n        var _this = this;\n        var context = new ParseContext(UserDataSource.Set, methodName, FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var merge = options.merge !== undefined ? options.merge : false;\n        var updateData = ObjectValue.EMPTY;\n        objUtils.forEach(input, function (key, value) {\n            var path = new ExternalFieldPath(key)._internalPath;\n            var childContext = context.childContext(path);\n            value = _this.runPreConverter(value, childContext);\n            var parsedValue = _this.parseData(value, childContext);\n            if (parsedValue) {\n                updateData = updateData.set(path, parsedValue);\n            }\n        });\n        var fieldMask = merge ? new FieldMask(context.fieldMask) : null;\n        return new ParsedSetData(updateData, fieldMask, context.fieldTransforms);\n    };\n    /** Parse update data (e.g. from an update() call). */\n    UserDataConverter.prototype.parseUpdateData = function (methodName, input) {\n        var _this = this;\n        var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var fieldMaskPaths = [];\n        var updateData = ObjectValue.EMPTY;\n        objUtils.forEach(input, function (key, value) {\n            var path = fieldPathFromDotSeparatedString(methodName, key);\n            var childContext = context.childContext(path);\n            value = _this.runPreConverter(value, childContext);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = _this.parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        });\n        var mask = new FieldMask(fieldMaskPaths);\n        return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /** Parse update data from a list of field/value arguments. */\n    UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) {\n        var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);\n        var keys = [fieldPathFromArgument(methodName, field)];\n        var values = [value];\n        if (moreFieldsAndValues.length % 2 !== 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() needs to be called with an even number \" +\n                'of arguments that alternate between field names and values.');\n        }\n        for (var i = 0; i < moreFieldsAndValues.length; i += 2) {\n            keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));\n            values.push(moreFieldsAndValues[i + 1]);\n        }\n        var fieldMaskPaths = [];\n        var updateData = ObjectValue.EMPTY;\n        for (var i = 0; i < keys.length; ++i) {\n            var path = keys[i];\n            var childContext = context.childContext(path);\n            var value_1 = this.runPreConverter(values[i], childContext);\n            if (value_1 instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = this.parseData(value_1, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        }\n        var mask = new FieldMask(fieldMaskPaths);\n        return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /**\n     * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n     * bound).\n     */\n    UserDataConverter.prototype.parseQueryValue = function (methodName, input) {\n        var context = new ParseContext(UserDataSource.QueryValue, methodName, FieldPath.EMPTY_PATH);\n        var parsed = this.parseData(input, context);\n        assert(parsed != null, 'Parsed data should not be null.');\n        assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');\n        return parsed;\n    };\n    /** Sends data through this.preConverter, handling any thrown errors. */\n    UserDataConverter.prototype.runPreConverter = function (input, context) {\n        try {\n            return this.preConverter(input);\n        }\n        catch (e) {\n            var message = errorMessage(e);\n            throw context.createError(message);\n        }\n    };\n    /**\n     * Internal helper for parsing user data.\n     *\n     * @param input Data to be parsed.\n     * @param context A context object representing the current path being parsed,\n     * the source of the data being parsed, etc.\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseData = function (input, context) {\n        input = this.runPreConverter(input, context);\n        if (input instanceof Array) {\n            // TODO(b/34871131): We may need a different way to detect nested arrays\n            // once we support array paths (at which point we should include the path\n            // containing the array in the error message).\n            if (!context.path) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            // We don't support field mask paths more granular than the top-level\n            // array.\n            context.fieldMask.push(context.path);\n            return this.parseArray(input, context);\n        }\n        else if (looksLikeJsonObject(input)) {\n            validatePlainObject('Unsupported field value:', context, input);\n            return this.parseObject(input, context);\n        }\n        else {\n            // If context.path is null, we are inside an array and we should have\n            // already added the root of the array to the field mask.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseScalarValue(input, context);\n        }\n    };\n    UserDataConverter.prototype.parseArray = function (array, context) {\n        var result = [];\n        var entryIndex = 0;\n        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n            var entry = array_1[_i];\n            var parsedEntry = this.parseData(entry, context.childContext(entryIndex));\n            if (parsedEntry == null) {\n                // Just include nulls in the array for fields being replaced with a\n                // sentinel.\n                parsedEntry = NullValue.INSTANCE;\n            }\n            result.push(parsedEntry);\n            entryIndex++;\n        }\n        return new ArrayValue(result);\n    };\n    UserDataConverter.prototype.parseObject = function (obj, context) {\n        var _this = this;\n        var result = new SortedMap(primitiveComparator);\n        objUtils.forEach(obj, function (key, val) {\n            var parsedValue = _this.parseData(val, context.childContext(key));\n            if (parsedValue != null) {\n                result = result.insert(key, parsedValue);\n            }\n        });\n        return new ObjectValue(result);\n    };\n    /**\n     * Helper to parse a scalar value (i.e. not an Object or Array)\n     *\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseScalarValue = function (value, context) {\n        if (value === null) {\n            return NullValue.INSTANCE;\n        }\n        else if (typeof value === 'number') {\n            if (typeUtils.isSafeInteger(value)) {\n                return new IntegerValue(value);\n            }\n            else {\n                return new DoubleValue(value);\n            }\n        }\n        else if (typeof value === 'boolean') {\n            return BooleanValue.of(value);\n        }\n        else if (typeof value === 'string') {\n            return new StringValue(value);\n        }\n        else if (value instanceof Date) {\n            return new TimestampValue(Timestamp.fromDate(value));\n        }\n        else if (value instanceof GeoPoint) {\n            return new GeoPointValue(value);\n        }\n        else if (value instanceof Blob) {\n            return new BlobValue(value);\n        }\n        else if (value instanceof DocumentKeyReference) {\n            return new RefValue(value.databaseId, value.key);\n        }\n        else if (value instanceof FieldValueImpl) {\n            if (value instanceof DeleteFieldValueImpl) {\n                // We shouldn't encounter delete sentinels here. Provide a good error.\n                if (context.dataSource !== UserDataSource.Update) {\n                    throw context.createError('FieldValue.delete() can only be used with update()');\n                }\n                else {\n                    assert(context.path == null || context.path.length > 0, 'FieldValue.delete() at the top level should have already' +\n                        ' been handled.');\n                    throw context.createError('FieldValue.delete() can only appear at the top level ' +\n                        'of your update data');\n                }\n            }\n            else if (value instanceof ServerTimestampFieldValueImpl) {\n                if (context.dataSource !== UserDataSource.Set &&\n                    context.dataSource !== UserDataSource.Update) {\n                    throw context.createError('FieldValue.serverTimestamp() can only be used with set()' +\n                        ' and update()');\n                }\n                if (context.path === null) {\n                    throw context.createError('FieldValue.serverTimestamp() is not currently' +\n                        ' supported inside arrays');\n                }\n                context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance));\n                // Return null so this value is omitted from the parsed result.\n                return null;\n            }\n            else {\n                return fail('Unknown FieldValue type: ' + value);\n            }\n        }\n        else {\n            throw context.createError(\"Unsupported field value: \" + valueDescription(value));\n        }\n    };\n    return UserDataConverter;\n}());\nexport { UserDataConverter };\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof GeoPoint) &&\n        !(input instanceof Blob) &&\n        !(input instanceof DocumentKeyReference) &&\n        !(input instanceof FieldValueImpl));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        var description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nexport function fieldPathFromArgument(methodName, path) {\n    if (path instanceof ExternalFieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        var message = 'Field path arguments must be of type string or FieldPath.';\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path) {\n    try {\n        return fromDotSeparatedString(path)._internalPath;\n    }\n    catch (e) {\n        var message = errorMessage(e);\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error) {\n    return error instanceof Error ? error.message : error.toString();\n}\n\n\n"]}