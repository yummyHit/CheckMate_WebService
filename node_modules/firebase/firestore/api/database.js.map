{"version":3,"sources":["src/firestore/api/database.ts","firestore/api/database.js"],"names":["changesFromSnapshot","log","objUtils","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","DEFAULT_HOST","DEFAULT_SSL","FirestoreSettings","settings","host","undefined","ssl","INVALID_ARGUMENT","defaulted","credentials","equals","other","FirestoreConfig","Firestore","databaseIdOrApp","_this","INTERNAL","delete","_firestoreClient","shutdown","resolve","config","options","app","firebaseApp","databaseId","databaseIdFromApp","persistenceKey","name","external_1","projectId","database","_config","defineProperty","get","enumerable","configurable","settingsLiteral","arguments","contains","newSettings","FAILED_PRECONDITION","enablePersistence","configureClient","ensureClientConfigured","persistence","databaseInfo","preConverter","value","DocumentReference","thisDb","otherDb","firestore","_key","_dataConverter","getPlatform","start","collection","pathString","CollectionReference","fromString","doc","forPath","runTransaction","updateFunction","transaction","Transaction","batch","WriteBatch","getLogLevel","DEBUG","ERROR","SILENT","setLogLevel","level","LogLevel","_firestore","_transaction","documentRef","ref","validateReference","lookup","then","docs","length","DocumentSnapshot","set","validateSetOptions","parsed","parseSetData","update","fieldOrUpdateData","moreFieldsAndValues","_i","parseUpdateVarargs","parseUpdateData","_mutations","_committed","verifyNotCommitted","concat","toMutations","NONE","exists","commit","write","path","canonicalString","lastSegment","popLast","child","onSnapshot","args","includeMetadataChanges","observer","currArg","internalOptions","includeDocumentMetadataChanges","includeQueryMetadataChanges","next","error","complete","onSnapshotInternal","errHandler","err","console","bind","asyncObserver","snapshot","size","fromCache","internalListener","listen","atPath","mute","unlisten","reject","waitForSyncWhenOnline","snap","metadata","ABORTED","_document","_fromCache","data","NOT_FOUND","convertObject","fieldPath","field","convertValue","hasPendingWrites","hasLocalMutations","result","forEach","key","convertArray","internalValue","map","Query","_query","where","opStr","fieldValue","isKeyField","indexOf","_databaseId","parseQueryValue","filter","validateNewFilter","addFilter","orderBy","directionStr","direction","ASCENDING","DESCENDING","startAt","endAt","validateNewOrderBy","addOrderBy","limit","n","withLimit","docOrField","fields","bound","boundFromDocOrFields","withStartAt","startAfter","endBefore","withEndAt","methodName","before","boundFromDocument","allFields","boundFromFields","components","_a","push","values","explicitOrderBy","i","rawValue","orderByComponent","wrapped","QuerySnapshot","firestoreClient","isInequality","existingField","getInequalityFilterField","toString","firstOrderByField","getFirstOrderByField","validateOrderByAndInequalityMatch","inequalityField","inequality","_originalQuery","_snapshot","_cachedChanges","isEmpty","callback","thisArg","call","convertToDocumentImpl","_super","parentPath","newId","add","docRef","merge","oldDocs","lastDoc_1","index_1","docChanges","change","type","Added","query","docComparator","oldIndex","newIndex","indexTracker_1","Removed","resultChangeType","Modified","Metadata","PublicFirestore","PublicTransaction","PublicWriteBatch","PublicDocumentReference","PublicDocumentSnapshot","PublicQuery","PublicQuerySnapshot","PublicCollectionReference"],"mappings":"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","file":"database.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from 'firestore';\n\nimport { FieldPath as ExternalFieldPath } from './field_path';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { ListenOptions } from '../core/event_manager';\nimport { FirestoreClient } from '../core/firestore_client';\nimport {\n  Bound,\n  Direction,\n  fieldFilter,\n  Filter,\n  OrderBy,\n  Query as InternalQuery,\n  RelationFilter,\n  RelationOp\n} from '../core/query';\nimport { Transaction as InternalTransaction } from '../core/transaction';\nimport { ChangeType, ViewSnapshot } from '../core/view_snapshot';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport {\n  ArrayValue,\n  FieldValue,\n  ObjectValue,\n  RefValue\n} from '../model/field_value';\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { PlatformSupport } from '../platform/platform';\nimport { makeConstructorPrivate } from '../util/api';\nimport { assert, fail } from '../util/assert';\nimport { AsyncObserver } from '../util/async_observer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  invalidClassError,\n  validateArgType,\n  validateAtLeastNumberOfArgs,\n  validateBetweenNumberOfArgs,\n  validateDefined,\n  validateExactNumberOfArgs,\n  validateNamedOptionalType,\n  validateNamedType,\n  validateOptionalArgType,\n  validateOptionNames,\n  valueDescription\n} from '../util/input_validation';\nimport * as log from '../util/log';\nimport { LogLevel } from '../util/log';\nimport { AnyJs, AutoId } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { Rejecter, Resolver } from '../util/promise';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport {\n  CredentialsProvider,\n  CredentialsSettings,\n  EmptyCredentialsProvider,\n  FirebaseCredentialsProvider,\n  makeCredentialsProvider\n} from './credentials';\nimport {\n  CompleteFn,\n  ErrorFn,\n  isPartialObserver,\n  NextFn,\n  PartialObserver,\n  Unsubscribe\n} from './observer';\nimport {\n  DocumentKeyReference,\n  fieldPathFromArgument,\n  UserDataConverter\n} from './user_data_converter';\n\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\n\nconst DEFAULT_HOST = 'firestore.googleapis.com';\nconst DEFAULT_SSL = true;\n\n/** Undocumented, private additional settings not exposed in our public API. */\ninterface PrivateSettings extends firestore.Settings {\n  // Can be a google-auth-library or gapi client.\n  credentials?: CredentialsSettings;\n}\n\n/**\n * Options that can be provided in the Firestore constructor when not using\n * Firebase (aka standalone mode).\n */\nexport interface FirestoreDatabase {\n  projectId: string;\n  database?: string;\n}\n\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nclass FirestoreSettings {\n  /** The hostname to connect to. */\n  host: string;\n\n  /** Whether to use SSL when connecting. */\n  ssl: boolean;\n\n  // Can be a google-auth-library or gapi client.\n  // tslint:disable-next-line:no-any\n  credentials?: any;\n\n  constructor(settings: PrivateSettings) {\n    if (settings.host === undefined) {\n      if (settings.ssl !== undefined) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          \"Can't provide ssl option if host option is not set\"\n        );\n      }\n      this.host = DEFAULT_HOST;\n      this.ssl = DEFAULT_SSL;\n    } else {\n      validateNamedType('settings', 'string', 'host', settings.host);\n      this.host = settings.host;\n\n      validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n      this.ssl = objUtils.defaulted(settings.ssl, DEFAULT_SSL);\n    }\n    validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);\n\n    validateNamedOptionalType(\n      'settings',\n      'object',\n      'credentials',\n      settings.credentials\n    );\n    this.credentials = settings.credentials;\n  }\n\n  equals(other: FirestoreSettings): boolean {\n    return (\n      this.host === other.host &&\n      this.ssl === other.ssl &&\n      this.credentials === other.credentials\n    );\n  }\n}\n\nclass FirestoreConfig {\n  databaseId: DatabaseId;\n  persistenceKey: string;\n  credentials: CredentialsProvider;\n  firebaseApp: firebase.app.App;\n  settings: FirestoreSettings;\n  persistence: boolean;\n}\n\n/**\n * The root reference to the database.\n */\nexport class Firestore implements firestore.Firestore, FirebaseService {\n  private _config: FirestoreConfig;\n\n  // The firestore client instance. This will be available as soon as\n  // configureClient is called, but any calls against it will block until\n  // setup has completed.\n  //\n  // Operations on the _firestoreClient don't block on _firestoreReady. Those\n  // are already set to synchronize on the async queue.\n  private _firestoreClient: FirestoreClient | undefined;\n  public _dataConverter: UserDataConverter;\n\n  public get _databaseId(): DatabaseId {\n    return this._config.databaseId;\n  }\n\n  constructor(databaseIdOrApp: FirestoreDatabase | firebase.app.App) {\n    const config = new FirestoreConfig();\n    if (typeof (databaseIdOrApp as firebase.app.App).options === 'object') {\n      // This is very likely a Firebase app object\n      // TODO(b/34177605): Can we somehow use instanceof?\n      const app = databaseIdOrApp as firebase.app.App;\n      config.firebaseApp = app;\n      config.databaseId = Firestore.databaseIdFromApp(app);\n      config.persistenceKey = config.firebaseApp.name;\n      config.credentials = new FirebaseCredentialsProvider(app);\n    } else {\n      const external = databaseIdOrApp as FirestoreDatabase;\n      if (!external.projectId) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Must provide projectId'\n        );\n      }\n\n      config.databaseId = new DatabaseId(external.projectId, external.database);\n      // Use a default persistenceKey that lines up with firebase.app.App.\n      config.persistenceKey = '[DEFAULT]';\n      config.credentials = new EmptyCredentialsProvider();\n    }\n\n    config.settings = new FirestoreSettings({});\n    this._config = config;\n  }\n\n  settings(settingsLiteral: firestore.Settings): void {\n    validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n    validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n\n    if (\n      objUtils.contains(settingsLiteral as objUtils.Dict<{}>, 'persistence')\n    ) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        '\"persistence\" is now specified with a separate call to ' +\n          'firestore.enablePersistence().'\n      );\n    }\n\n    const newSettings = new FirestoreSettings(settingsLiteral);\n    if (this._firestoreClient && !this._config.settings.equals(newSettings)) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Firestore has already been started and its settings can no longer ' +\n          'be changed. You can only call settings() before calling any other ' +\n          'methods on a Firestore object.'\n      );\n    }\n\n    this._config.settings = newSettings;\n    if (newSettings.credentials !== undefined) {\n      this._config.credentials = makeCredentialsProvider(\n        newSettings.credentials\n      );\n    }\n  }\n\n  enablePersistence(): Promise<void> {\n    if (this._firestoreClient) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Firestore has already been started and persistence can no longer ' +\n          'be enabled. You can only call enablePersistence() before calling ' +\n          'any other methods on a Firestore object.'\n      );\n    }\n\n    return this.configureClient(/* persistence= */ true);\n  }\n\n  ensureClientConfigured(): FirestoreClient {\n    if (!this._firestoreClient) {\n      this.configureClient(/* persistence= */ false);\n    }\n    return this._firestoreClient as FirestoreClient;\n  }\n\n  private configureClient(persistence: boolean): Promise<void> {\n    assert(\n      !!this._config.settings.host,\n      'FirestoreSettings.host cannot be falsey'\n    );\n\n    assert(!this._firestoreClient, 'configureClient() called multiple times');\n\n    const databaseInfo = new DatabaseInfo(\n      this._config.databaseId,\n      this._config.persistenceKey,\n      this._config.settings.host,\n      this._config.settings.ssl\n    );\n\n    const preConverter = (value: AnyJs) => {\n      if (value instanceof DocumentReference) {\n        const thisDb = this._config.databaseId;\n        const otherDb = value.firestore._config.databaseId;\n        if (!otherDb.equals(thisDb)) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Document reference is for database ' +\n              `${otherDb.projectId}/${otherDb.database} but should be ` +\n              `for database ${thisDb.projectId}/${thisDb.database}`\n          );\n        }\n        return new DocumentKeyReference(this._config.databaseId, value._key);\n      } else {\n        return value;\n      }\n    };\n    this._dataConverter = new UserDataConverter(preConverter);\n\n    this._firestoreClient = new FirestoreClient(\n      PlatformSupport.getPlatform(),\n      databaseInfo,\n      this._config.credentials,\n      new AsyncQueue()\n    );\n    return this._firestoreClient.start(persistence);\n  }\n\n  private static databaseIdFromApp(app: firebase.app.App): DatabaseId {\n    const options = app.options as objUtils.Dict<{}>;\n    if (!objUtils.contains(options, 'projectId')) {\n      // TODO(b/62673263): We can safely remove the special handling of\n      // 'firestoreId' once alpha testers have upgraded.\n      if (objUtils.contains(options, 'firestoreId')) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          '\"firestoreId\" is now specified as \"projectId\" in ' +\n            'firebase.initializeApp.'\n        );\n      }\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        '\"projectId\" not provided in firebase.initializeApp.'\n      );\n    }\n\n    if (objUtils.contains(options, 'firestoreOptions')) {\n      // TODO(b/62673263): We can safely remove the special handling of\n      // 'firestoreOptions' once alpha testers have upgraded.\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        '\"firestoreOptions\" values are now specified with ' +\n          'Firestore.settings()'\n      );\n    }\n\n    const projectId = options['projectId'];\n    if (!projectId || typeof projectId !== 'string') {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'projectId must be a string in firebase.app.App.options'\n      );\n    }\n    return new DatabaseId(projectId);\n  }\n\n  get app(): firebase.app.App {\n    if (!this._config.firebaseApp) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n          'not available'\n      );\n    }\n    return this._config.firebaseApp;\n  }\n\n  INTERNAL = {\n    delete: (): Promise<void> => {\n      if (this._firestoreClient) {\n        return this._firestoreClient.shutdown();\n      } else {\n        return Promise.resolve();\n      }\n    }\n  };\n\n  collection(pathString: string): firestore.CollectionReference {\n    validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n    validateArgType('Firestore.collection', 'string', 1, pathString);\n    if (!pathString) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Must provide a non-empty collection path to collection()'\n      );\n    }\n\n    this.ensureClientConfigured();\n    return new CollectionReference(ResourcePath.fromString(pathString), this);\n  }\n\n  doc(pathString: string): firestore.DocumentReference {\n    validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n    validateArgType('Firestore.doc', 'string', 1, pathString);\n    if (!pathString) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Must provide a non-empty document path to doc()'\n      );\n    }\n    this.ensureClientConfigured();\n    return DocumentReference.forPath(ResourcePath.fromString(pathString), this);\n  }\n\n  runTransaction<T>(\n    updateFunction: (transaction: firestore.Transaction) => Promise<T>\n  ): Promise<T> {\n    validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n    validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n    return this.ensureClientConfigured().transaction(\n      (transaction: InternalTransaction) => {\n        return updateFunction(new Transaction(this, transaction));\n      }\n    );\n  }\n\n  batch(): firestore.WriteBatch {\n    this.ensureClientConfigured();\n\n    return new WriteBatch(this);\n  }\n\n  static get logLevel(): firestore.LogLevel {\n    switch (log.getLogLevel()) {\n      case LogLevel.DEBUG:\n        return 'debug';\n      case LogLevel.ERROR:\n        return 'error';\n      case LogLevel.SILENT:\n        return 'silent';\n      default:\n        return fail('Unknown log level: ' + log.getLogLevel());\n    }\n  }\n\n  static setLogLevel(level: firestore.LogLevel) {\n    validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n    validateArgType('Firestore.setLogLevel', 'string', 1, level);\n    switch (level) {\n      case 'debug':\n        log.setLogLevel(log.LogLevel.DEBUG);\n        break;\n      case 'error':\n        log.setLogLevel(log.LogLevel.ERROR);\n        break;\n      case 'silent':\n        log.setLogLevel(log.LogLevel.SILENT);\n        break;\n      default:\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid log level: ' + level\n        );\n    }\n  }\n}\n\n/**\n * A reference to a transaction.\n */\nexport class Transaction implements firestore.Transaction {\n  constructor(\n    private _firestore: Firestore,\n    private _transaction: InternalTransaction\n  ) {}\n\n  get(\n    documentRef: firestore.DocumentReference\n  ): Promise<firestore.DocumentSnapshot> {\n    validateExactNumberOfArgs('Transaction.get', arguments, 1);\n    const ref = validateReference(\n      'Transaction.get',\n      documentRef,\n      this._firestore\n    );\n    return this._transaction\n      .lookup([ref._key])\n      .then((docs: MaybeDocument[]) => {\n        if (!docs || docs.length !== 1) {\n          return fail('Mismatch in docs returned from document lookup.');\n        }\n        const doc = docs[0];\n        if (doc instanceof NoDocument) {\n          return new DocumentSnapshot(this._firestore, ref._key, null, false);\n        }\n        return new DocumentSnapshot(this._firestore, ref._key, doc, false);\n      });\n  }\n\n  set(\n    documentRef: firestore.DocumentReference,\n    value: firestore.DocumentData,\n    options?: firestore.SetOptions\n  ): Transaction {\n    validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n    const ref = validateReference(\n      'Transaction.set',\n      documentRef,\n      this._firestore\n    );\n    options = validateSetOptions('Transaction.set', options);\n    const parsed = this._firestore._dataConverter.parseSetData(\n      'Transaction.set',\n      value,\n      options\n    );\n    this._transaction.set(ref._key, parsed);\n    return this;\n  }\n\n  update(\n    documentRef: firestore.DocumentReference,\n    value: firestore.UpdateData\n  ): Transaction;\n  update(\n    documentRef: firestore.DocumentReference,\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): Transaction;\n  update(\n    documentRef: firestore.DocumentReference,\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): Transaction {\n    let ref;\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n      ref = validateReference(\n        'Transaction.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataConverter.parseUpdateVarargs(\n        'Transaction.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('Transaction.update', arguments, 2);\n      ref = validateReference(\n        'Transaction.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataConverter.parseUpdateData(\n        'Transaction.update',\n        fieldOrUpdateData\n      );\n    }\n\n    this._transaction.update(ref._key, parsed);\n    return this;\n  }\n\n  delete(documentRef: firestore.DocumentReference): Transaction {\n    validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n    const ref = validateReference(\n      'Transaction.delete',\n      documentRef,\n      this._firestore\n    );\n    this._transaction.delete(ref._key);\n    return this;\n  }\n}\n\nexport class WriteBatch implements firestore.WriteBatch {\n  private _mutations = [] as Mutation[];\n  private _committed = false;\n\n  constructor(private _firestore: Firestore) {}\n\n  set(\n    documentRef: firestore.DocumentReference,\n    value: firestore.DocumentData,\n    options?: firestore.SetOptions\n  ): WriteBatch {\n    validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n    this.verifyNotCommitted();\n    const ref = validateReference(\n      'WriteBatch.set',\n      documentRef,\n      this._firestore\n    );\n    options = validateSetOptions('WriteBatch.set', options);\n    const parsed = this._firestore._dataConverter.parseSetData(\n      'WriteBatch.set',\n      value,\n      options\n    );\n    this._mutations = this._mutations.concat(\n      parsed.toMutations(ref._key, Precondition.NONE)\n    );\n    return this;\n  }\n\n  update(\n    documentRef: firestore.DocumentReference,\n    value: firestore.UpdateData\n  ): WriteBatch;\n  update(\n    documentRef: firestore.DocumentReference,\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): WriteBatch;\n  update(\n    documentRef: firestore.DocumentReference,\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): WriteBatch {\n    this.verifyNotCommitted();\n\n    let ref;\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n      ref = validateReference(\n        'WriteBatch.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataConverter.parseUpdateVarargs(\n        'WriteBatch.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n      ref = validateReference(\n        'WriteBatch.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataConverter.parseUpdateData(\n        'WriteBatch.update',\n        fieldOrUpdateData\n      );\n    }\n\n    this._mutations = this._mutations.concat(\n      parsed.toMutations(ref._key, Precondition.exists(true))\n    );\n    return this;\n  }\n\n  delete(documentRef: firestore.DocumentReference): WriteBatch {\n    validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n    this.verifyNotCommitted();\n    const ref = validateReference(\n      'WriteBatch.delete',\n      documentRef,\n      this._firestore\n    );\n    this._mutations = this._mutations.concat(\n      new DeleteMutation(ref._key, Precondition.NONE)\n    );\n    return this;\n  }\n\n  commit(): Promise<void> {\n    this.verifyNotCommitted();\n    this._committed = true;\n    if (this._mutations.length > 0) {\n      return this._firestore.ensureClientConfigured().write(this._mutations);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  private verifyNotCommitted() {\n    if (this._committed) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'A write batch can no longer be used after commit() ' +\n          'has been called.'\n      );\n    }\n  }\n}\n\n/**\n * A reference to a particular document in a collection in the database.\n */\nexport class DocumentReference implements firestore.DocumentReference {\n  private _firestoreClient: FirestoreClient;\n\n  constructor(public _key: DocumentKey, readonly firestore: Firestore) {\n    this._firestoreClient = this.firestore.ensureClientConfigured();\n  }\n\n  static forPath(path: ResourcePath, firestore: Firestore) {\n    if (path.length % 2 !== 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid document reference. Document ' +\n          'references must have an even number of segments, but ' +\n          `${path.canonicalString()} has ${path.length}`\n      );\n    }\n    return new DocumentReference(new DocumentKey(path), firestore);\n  }\n\n  get id(): string {\n    return this._key.path.lastSegment();\n  }\n\n  get parent(): firestore.CollectionReference {\n    return new CollectionReference(this._key.path.popLast(), this.firestore);\n  }\n\n  get path(): string {\n    return this._key.path.canonicalString();\n  }\n\n  collection(pathString: string): firestore.CollectionReference {\n    validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n    validateArgType('DocumentReference.collection', 'string', 1, pathString);\n    if (!pathString) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Must provide a non-empty collection name to collection()'\n      );\n    }\n    const path = ResourcePath.fromString(pathString);\n    return new CollectionReference(this._key.path.child(path), this.firestore);\n  }\n\n  set(\n    value: firestore.DocumentData,\n    options?: firestore.SetOptions\n  ): Promise<void> {\n    validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n    options = validateSetOptions('DocumentReference.set', options);\n\n    const parsed = this.firestore._dataConverter.parseSetData(\n      'DocumentReference.set',\n      value,\n      options\n    );\n    return this._firestoreClient.write(\n      parsed.toMutations(this._key, Precondition.NONE)\n    );\n  }\n\n  update(value: firestore.UpdateData): Promise<void>;\n  update(\n    field: string | ExternalFieldPath,\n    value: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): Promise<void>;\n  update(\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: AnyJs,\n    ...moreFieldsAndValues: AnyJs[]\n  ): Promise<void> {\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n      parsed = this.firestore._dataConverter.parseUpdateVarargs(\n        'DocumentReference.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n      parsed = this.firestore._dataConverter.parseUpdateData(\n        'DocumentReference.update',\n        fieldOrUpdateData\n      );\n    }\n\n    return this._firestoreClient.write(\n      parsed.toMutations(this._key, Precondition.exists(true))\n    );\n  }\n\n  delete(): Promise<void> {\n    validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n    return this._firestoreClient.write([\n      new DeleteMutation(this._key, Precondition.NONE)\n    ]);\n  }\n\n  onSnapshot(\n    observer: PartialObserver<firestore.DocumentSnapshot>\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.DocumentListenOptions,\n    observer: PartialObserver<firestore.DocumentSnapshot>\n  ): Unsubscribe;\n  onSnapshot(\n    onNext: NextFn<firestore.DocumentSnapshot>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.DocumentListenOptions,\n    onNext: NextFn<firestore.DocumentSnapshot>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n\n  onSnapshot(...args: AnyJs[]): Unsubscribe {\n    validateBetweenNumberOfArgs(\n      'DocumentReference.onSnapshot',\n      arguments,\n      1,\n      4\n    );\n    let options: firestore.DocumentListenOptions = {\n      includeMetadataChanges: false\n    };\n    let observer: PartialObserver<firestore.DocumentSnapshot>;\n    let currArg = 0;\n    if (\n      typeof args[currArg] === 'object' &&\n      !isPartialObserver(args[currArg])\n    ) {\n      options = args[currArg] as firestore.DocumentListenOptions;\n      validateOptionNames('DocumentReference.onSnapshot', options, [\n        'includeMetadataChanges'\n      ]);\n      validateNamedOptionalType(\n        'DocumentReference.onSnapshot',\n        'boolean',\n        'includeMetadataChanges',\n        options.includeMetadataChanges\n      );\n      currArg++;\n    }\n\n    const internalOptions = {\n      includeDocumentMetadataChanges: options.includeMetadataChanges,\n      includeQueryMetadataChanges: options.includeMetadataChanges\n    };\n\n    if (isPartialObserver(args[currArg])) {\n      observer = args[currArg] as PartialObserver<firestore.DocumentSnapshot>;\n    } else {\n      validateArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg,\n        args[currArg]\n      );\n      validateOptionalArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg + 1,\n        args[currArg + 1]\n      );\n      validateOptionalArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg + 2,\n        args[currArg + 2]\n      );\n      observer = {\n        next: args[currArg] as NextFn<firestore.DocumentSnapshot>,\n        error: args[currArg + 1] as ErrorFn,\n        complete: args[currArg + 2] as CompleteFn\n      };\n    }\n    return this.onSnapshotInternal(internalOptions, observer);\n  }\n\n  private onSnapshotInternal(\n    options: ListenOptions,\n    observer: PartialObserver<firestore.DocumentSnapshot>\n  ): Unsubscribe {\n    let errHandler = (err: Error) => {\n      console.error('Uncaught Error in onSnapshot:', err);\n    };\n    if (observer.error) {\n      errHandler = observer.error.bind(observer);\n    }\n\n    const asyncObserver = new AsyncObserver<ViewSnapshot>({\n      next: snapshot => {\n        if (observer.next) {\n          assert(\n            snapshot.docs.size <= 1,\n            'Too many documents returned on a document query'\n          );\n          const doc = snapshot.docs.get(this._key);\n\n          observer.next(\n            new DocumentSnapshot(\n              this.firestore,\n              this._key,\n              doc,\n              snapshot.fromCache\n            )\n          );\n        }\n      },\n      error: errHandler\n    });\n    const internalListener = this._firestoreClient.listen(\n      InternalQuery.atPath(this._key.path),\n      asyncObserver,\n      options\n    );\n\n    return () => {\n      asyncObserver.mute();\n      this._firestoreClient.unlisten(internalListener);\n    };\n  }\n\n  get(): Promise<firestore.DocumentSnapshot> {\n    validateExactNumberOfArgs('DocumentReference.get', arguments, 0);\n    return new Promise(\n      (resolve: Resolver<firestore.DocumentSnapshot>, reject: Rejecter) => {\n        const unlisten = this.onSnapshotInternal(\n          {\n            includeQueryMetadataChanges: true,\n            includeDocumentMetadataChanges: true,\n            waitForSyncWhenOnline: true\n          },\n          {\n            next: (snap: firestore.DocumentSnapshot) => {\n              // Remove query first before passing event to user to avoid\n              // user actions affecting the now stale query.\n              unlisten();\n\n              if (!snap.exists && snap.metadata.fromCache) {\n                // TODO(dimond): If we're online and the document doesn't\n                // exist then we resolve with a doc.exists set to false. If\n                // we're offline however, we reject the Promise in this\n                // case. Two options: 1) Cache the negative response from\n                // the server so we can deliver that even when you're\n                // offline 2) Actually reject the Promise in the online case\n                // if the document doesn't exist.\n                reject(\n                  new FirestoreError(\n                    Code.ABORTED,\n                    'Failed to get document because the client is ' + 'offline.'\n                  )\n                );\n              } else {\n                resolve(snap);\n              }\n            },\n            error: reject\n          }\n        );\n      }\n    );\n  }\n}\n\nexport class DocumentSnapshot implements firestore.DocumentSnapshot {\n  constructor(\n    private _firestore: Firestore,\n    private _key: DocumentKey,\n    public _document: Document | null,\n    private _fromCache: boolean\n  ) {}\n\n  data(): firestore.DocumentData {\n    validateExactNumberOfArgs('DocumentSnapshot.data', arguments, 0);\n    if (!this._document) {\n      throw new FirestoreError(\n        Code.NOT_FOUND,\n        \"This document doesn't exist. Check doc.exists to make sure \" +\n          'the document exists before calling doc.data().'\n      );\n    }\n    return this.convertObject(this._document.data);\n  }\n\n  get(fieldPath: string | ExternalFieldPath): AnyJs {\n    validateExactNumberOfArgs('DocumentSnapshot.get', arguments, 1);\n    if (!this._document) {\n      throw new FirestoreError(\n        Code.NOT_FOUND,\n        \"This document doesn't exist. Check doc.exists to make sure \" +\n          'the document exists before calling doc.get().'\n      );\n    }\n    const value = this._document.data.field(\n      fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n    );\n    return value === undefined ? undefined : this.convertValue(value);\n  }\n\n  get id(): string {\n    return this._key.path.lastSegment();\n  }\n\n  get ref(): firestore.DocumentReference {\n    return new DocumentReference(this._key, this._firestore);\n  }\n\n  get exists(): boolean {\n    return this._document !== null;\n  }\n\n  get metadata(): firestore.SnapshotMetadata {\n    return {\n      hasPendingWrites:\n        this._document !== null && this._document.hasLocalMutations,\n      fromCache: this._fromCache\n    };\n  }\n\n  private convertObject(data: ObjectValue): firestore.DocumentData {\n    const result: firestore.DocumentData = {};\n    data.forEach((key, value) => {\n      result[key] = this.convertValue(value);\n    });\n    return result;\n  }\n\n  private convertValue(value: FieldValue): AnyJs {\n    if (value instanceof ObjectValue) {\n      return this.convertObject(value);\n    } else if (value instanceof ArrayValue) {\n      return this.convertArray(value);\n    } else if (value instanceof RefValue) {\n      const key = value.value();\n      const database = this._firestore.ensureClientConfigured().databaseId();\n      if (!value.databaseId.equals(database)) {\n        // TODO(b/64130202): Somehow support foreign references.\n        log.error(\n          `Document ${this._key.path} contains a document ` +\n            `reference within a different database (` +\n            `${value.databaseId.projectId}/${value.databaseId\n              .database}) which is not ` +\n            `supported. It will be treated as a reference in the current ` +\n            `database (${database.projectId}/${database.database}) ` +\n            `instead.`\n        );\n      }\n      return new DocumentReference(key, this._firestore);\n    } else {\n      return value.value();\n    }\n  }\n\n  private convertArray(data: ArrayValue): AnyJs[] {\n    return data.internalValue.map(value => {\n      return this.convertValue(value);\n    });\n  }\n}\n\nexport class Query implements firestore.Query {\n  constructor(public _query: InternalQuery, readonly firestore: Firestore) {}\n\n  where(\n    field: string | ExternalFieldPath,\n    opStr: firestore.WhereFilterOp,\n    value: AnyJs\n  ): firestore.Query {\n    validateExactNumberOfArgs('Query.where', arguments, 3);\n    validateArgType('Query.where', 'string', 2, opStr);\n    validateDefined('Query.where', 3, value);\n    let fieldValue;\n    const fieldPath = fieldPathFromArgument('Query.where', field);\n    if (fieldPath.isKeyField()) {\n      if (typeof value === 'string') {\n        if (value.indexOf('/') !== -1) {\n          // TODO(dimond): Allow slashes once ancestor queries are supported\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Function Query.where() requires its third parameter to be a ' +\n              'valid document ID if the first parameter is ' +\n              'FieldPath.documentId(), but it contains a slash.'\n          );\n        }\n        if (value === '') {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Function Query.where() requires its third parameter to be a ' +\n              'valid document ID if the first parameter is ' +\n              'FieldPath.documentId(), but it was an empty string.'\n          );\n        }\n        const path = this._query.path.child(new ResourcePath([value]));\n        assert(path.length % 2 === 0, 'Path should be a document key');\n        fieldValue = new RefValue(\n          this.firestore._databaseId,\n          new DocumentKey(path)\n        );\n      } else if (value instanceof DocumentReference) {\n        const ref = value as DocumentReference;\n        fieldValue = new RefValue(this.firestore._databaseId, ref._key);\n      } else {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Function Query.where() requires its third parameter to be a ` +\n            `string or a DocumentReference if the first parameter is ` +\n            `FieldPath.documentId(), but it was: ` +\n            `${valueDescription(value)}.`\n        );\n      }\n    } else {\n      fieldValue = this.firestore._dataConverter.parseQueryValue(\n        'Query.where',\n        value\n      );\n    }\n    const filter = fieldFilter(\n      fieldPath,\n      RelationOp.fromString(opStr),\n      fieldValue\n    );\n    this.validateNewFilter(filter);\n    return new Query(this._query.addFilter(filter), this.firestore);\n  }\n\n  orderBy(\n    field: string | ExternalFieldPath,\n    directionStr?: firestore.OrderByDirection\n  ): firestore.Query {\n    validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n    validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);\n    let direction: Direction;\n    if (directionStr === undefined || directionStr === 'asc') {\n      direction = Direction.ASCENDING;\n    } else if (directionStr === 'desc') {\n      direction = Direction.DESCENDING;\n    } else {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Function Query.orderBy() has unknown direction '${directionStr}', ` +\n          `expected 'asc' or 'desc'.`\n      );\n    }\n    if (this._query.startAt !== null) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You must not call Query.startAt() or ' +\n          'Query.startAfter() before calling Query.orderBy().'\n      );\n    }\n    if (this._query.endAt !== null) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You must not call Query.endAt() or ' +\n          'Query.endBefore() before calling Query.orderBy().'\n      );\n    }\n    const fieldPath = fieldPathFromArgument('Query.orderBy', field);\n    const orderBy = new OrderBy(fieldPath, direction);\n    this.validateNewOrderBy(orderBy);\n    return new Query(this._query.addOrderBy(orderBy), this.firestore);\n  }\n\n  limit(n: number): firestore.Query {\n    validateExactNumberOfArgs('Query.limit', arguments, 1);\n    validateArgType('Query.limit', 'number', 1, n);\n    if (n <= 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid Query. Query limit (${n}) is invalid. Limit must be ` +\n          'positive.'\n      );\n    }\n    return new Query(this._query.withLimit(n), this.firestore);\n  }\n\n  startAt(\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    ...fields: AnyJs[]\n  ): firestore.Query {\n    validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.startAt',\n      docOrField,\n      fields,\n      /*before=*/ true\n    );\n    return new Query(this._query.withStartAt(bound), this.firestore);\n  }\n\n  startAfter(\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    ...fields: AnyJs[]\n  ): firestore.Query {\n    validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.startAfter',\n      docOrField,\n      fields,\n      /*before=*/ false\n    );\n    return new Query(this._query.withStartAt(bound), this.firestore);\n  }\n\n  endBefore(\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    ...fields: AnyJs[]\n  ): firestore.Query {\n    validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.endBefore',\n      docOrField,\n      fields,\n      /*before=*/ true\n    );\n    return new Query(this._query.withEndAt(bound), this.firestore);\n  }\n\n  endAt(\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    ...fields: AnyJs[]\n  ): firestore.Query {\n    validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.endAt',\n      docOrField,\n      fields,\n      /*before=*/ false\n    );\n    return new Query(this._query.withEndAt(bound), this.firestore);\n  }\n\n  /** Helper function to create a bound from a document or fields */\n  private boundFromDocOrFields(\n    methodName: string,\n    docOrField: AnyJs | firestore.DocumentSnapshot,\n    fields: AnyJs[],\n    before: boolean\n  ): Bound {\n    validateDefined(methodName, 1, docOrField);\n    if (docOrField instanceof DocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Too many arguments provided to ${methodName}().`\n        );\n      }\n      const snap = docOrField;\n      if (!snap.exists) {\n        throw new FirestoreError(\n          Code.NOT_FOUND,\n          `Can't use a DocumentSnapshot that doesn't exist for ` +\n            `${methodName}().`\n        );\n      }\n      return this.boundFromDocument(methodName, snap._document!, before);\n    } else {\n      const allFields = [docOrField].concat(fields);\n      return this.boundFromFields(methodName, allFields, before);\n    }\n  }\n\n  /**\n   * Create a Bound from a query and a document.\n   *\n   * Note that the Bound will always include the key of the document\n   * and so only the provided document will compare equal to the returned\n   * position.\n   *\n   * Will throw if the document does not contain all fields of the order by\n   * of the query.\n   */\n  private boundFromDocument(\n    methodName: string,\n    doc: Document,\n    before: boolean\n  ): Bound {\n    const components: FieldValue[] = [];\n\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const orderBy of this._query.orderBy) {\n      if (orderBy.field.isKeyField()) {\n        components.push(new RefValue(this.firestore._databaseId, doc.key));\n      } else {\n        const value = doc.field(orderBy.field);\n        if (value !== undefined) {\n          components.push(value);\n        } else {\n          const field = orderBy.field.canonicalString();\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. You are trying to start or end a query using a ` +\n              `document for which the field '${field}' (used as the ` +\n              `orderBy) does not exist.`\n          );\n        }\n      }\n    }\n    return new Bound(components, before);\n  }\n\n  /**\n   * Converts a list of field values to a Bound for the given query.\n   */\n  private boundFromFields(\n    methodName: string,\n    values: AnyJs[],\n    before: boolean\n  ): Bound {\n    // Use explicit order by's because it has to match the query the user made\n    const orderBy = this._query.explicitOrderBy;\n    if (values.length > orderBy.length) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Too many arguments provided to ${methodName}(). ` +\n          `The number of arguments must be less than or equal to the ` +\n          `number of Query.orderBy() clauses`\n      );\n    }\n\n    const components: FieldValue[] = [];\n    for (let i = 0; i < values.length; i++) {\n      const rawValue = values[i];\n      const orderByComponent = orderBy[i];\n      if (orderByComponent.field.isKeyField()) {\n        if (typeof rawValue !== 'string') {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. Expected a string for document ID in ` +\n              `${methodName}(), but got a ${typeof rawValue}`\n          );\n        }\n        if (rawValue.indexOf('/') !== -1) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. Document ID '${rawValue}' contains a slash in ` +\n              `${methodName}()`\n          );\n        }\n        const key = new DocumentKey(this._query.path.child(rawValue));\n        components.push(new RefValue(this.firestore._databaseId, key));\n      } else {\n        const wrapped = this.firestore._dataConverter.parseQueryValue(\n          methodName,\n          rawValue\n        );\n        components.push(wrapped);\n      }\n    }\n\n    return new Bound(components, before);\n  }\n\n  onSnapshot(observer: PartialObserver<firestore.QuerySnapshot>): Unsubscribe;\n  onSnapshot(\n    options: firestore.QueryListenOptions,\n    observer: PartialObserver<firestore.QuerySnapshot>\n  ): Unsubscribe;\n  onSnapshot(\n    onNext: NextFn<firestore.QuerySnapshot>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.QueryListenOptions,\n    onNext: NextFn<firestore.QuerySnapshot>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n\n  onSnapshot(...args: AnyJs[]): Unsubscribe {\n    validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n    let options: firestore.QueryListenOptions = {};\n    let observer: PartialObserver<firestore.QuerySnapshot>;\n    let currArg = 0;\n    if (\n      typeof args[currArg] === 'object' &&\n      !isPartialObserver(args[currArg])\n    ) {\n      options = args[currArg] as firestore.QueryListenOptions;\n      validateOptionNames('Query.onSnapshot', options, [\n        'includeQueryMetadataChanges',\n        'includeDocumentMetadataChanges'\n      ]);\n      validateNamedOptionalType(\n        'Query.onSnapshot',\n        'boolean',\n        'includeDocumentMetadataChanges',\n        options.includeDocumentMetadataChanges\n      );\n      validateNamedOptionalType(\n        'Query.onSnapshot',\n        'boolean',\n        'includeQueryMetadataChanges',\n        options.includeQueryMetadataChanges\n      );\n      currArg++;\n    }\n\n    if (isPartialObserver(args[currArg])) {\n      observer = args[currArg] as PartialObserver<firestore.QuerySnapshot>;\n    } else {\n      validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n      validateOptionalArgType(\n        'Query.onSnapshot',\n        'function',\n        currArg + 1,\n        args[currArg + 1]\n      );\n      validateOptionalArgType(\n        'Query.onSnapshot',\n        'function',\n        currArg + 2,\n        args[currArg + 2]\n      );\n      observer = {\n        next: args[currArg] as NextFn<firestore.QuerySnapshot>,\n        error: args[currArg + 1] as ErrorFn,\n        complete: args[currArg + 2] as CompleteFn\n      };\n    }\n    return this.onSnapshotInternal(options, observer);\n  }\n\n  private onSnapshotInternal(\n    options: ListenOptions,\n    observer: PartialObserver<firestore.QuerySnapshot>\n  ): Unsubscribe {\n    let errHandler = (err: Error) => {\n      console.error('Uncaught Error in onSnapshot:', err);\n    };\n    if (observer.error) {\n      errHandler = observer.error.bind(observer);\n    }\n\n    const asyncObserver = new AsyncObserver<ViewSnapshot>({\n      next: (result: ViewSnapshot): void => {\n        if (observer.next) {\n          observer.next(new QuerySnapshot(this.firestore, this._query, result));\n        }\n      },\n      error: errHandler\n    });\n\n    const firestoreClient = this.firestore.ensureClientConfigured();\n    const internalListener = firestoreClient.listen(\n      this._query,\n      asyncObserver,\n      options\n    );\n    return () => {\n      asyncObserver.mute();\n      firestoreClient.unlisten(internalListener);\n    };\n  }\n\n  get(): Promise<firestore.QuerySnapshot> {\n    validateExactNumberOfArgs('Query.get', arguments, 0);\n    return new Promise(\n      (resolve: Resolver<firestore.QuerySnapshot>, reject: Rejecter) => {\n        const unlisten = this.onSnapshotInternal(\n          {\n            includeDocumentMetadataChanges: false,\n            includeQueryMetadataChanges: true,\n            waitForSyncWhenOnline: true\n          },\n          {\n            next: (result: firestore.QuerySnapshot) => {\n              // Remove query first before passing event to user to avoid\n              // user actions affecting the now stale query.\n              unlisten();\n\n              resolve(result);\n            },\n            error: reject\n          }\n        );\n      }\n    );\n  }\n\n  private validateNewFilter(filter: Filter): void {\n    if (filter instanceof RelationFilter && filter.isInequality()) {\n      const existingField = this._query.getInequalityFilterField();\n      if (existingField !== null && !existingField.equals(filter.field)) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid query. All where filters with an inequality' +\n            ' (<, <=, >, or >=) must be on the same field. But you have' +\n            ` inequality filters on '${existingField.toString()}'` +\n            ` and '${filter.field.toString()}'`\n        );\n      }\n\n      const firstOrderByField = this._query.getFirstOrderByField();\n      if (firstOrderByField !== null) {\n        this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);\n      }\n    }\n  }\n\n  private validateNewOrderBy(orderBy: OrderBy): void {\n    if (this._query.getFirstOrderByField() === null) {\n      // This is the first order by. It must match any inequality.\n      const inequalityField = this._query.getInequalityFilterField();\n      if (inequalityField !== null) {\n        this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n      }\n    }\n  }\n\n  private validateOrderByAndInequalityMatch(\n    inequality: FieldPath,\n    orderBy: FieldPath\n  ): void {\n    if (!orderBy.equals(inequality)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. You have a where filter with an inequality ` +\n          `(<, <=, >, or >=) on field '${inequality.toString()}' ` +\n          `and so you must also use '${inequality.toString()}' ` +\n          `as your first Query.orderBy(), but your first Query.orderBy() ` +\n          `is on field '${orderBy.toString()}' instead.`\n      );\n    }\n  }\n}\n\nexport class QuerySnapshot implements firestore.QuerySnapshot {\n  private _cachedChanges: firestore.DocumentChange[] | null = null;\n\n  readonly metadata: firestore.SnapshotMetadata;\n\n  constructor(\n    private _firestore: Firestore,\n    private _originalQuery: InternalQuery,\n    private _snapshot: ViewSnapshot\n  ) {\n    this.metadata = {\n      fromCache: _snapshot.fromCache,\n      hasPendingWrites: _snapshot.hasPendingWrites\n    };\n  }\n\n  get docs(): firestore.DocumentSnapshot[] {\n    const result: firestore.DocumentSnapshot[] = [];\n    this.forEach(doc => result.push(doc));\n    return result;\n  }\n\n  get empty(): boolean {\n    return this._snapshot.docs.isEmpty();\n  }\n\n  get size(): number {\n    return this._snapshot.docs.size;\n  }\n\n  forEach(\n    callback: (result: firestore.DocumentSnapshot) => void,\n    thisArg?: AnyJs\n  ): void {\n    validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n    validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n    this._snapshot.docs.forEach(doc => {\n      callback.call(thisArg, this.convertToDocumentImpl(doc));\n    });\n  }\n\n  get query(): firestore.Query {\n    return new Query(this._originalQuery, this._firestore);\n  }\n\n  get docChanges(): firestore.DocumentChange[] {\n    if (!this._cachedChanges) {\n      this._cachedChanges = changesFromSnapshot(\n        this._firestore,\n        this._snapshot\n      );\n    }\n    return this._cachedChanges;\n  }\n\n  private convertToDocumentImpl(doc: Document): DocumentSnapshot {\n    return new DocumentSnapshot(\n      this._firestore,\n      doc.key,\n      doc,\n      this.metadata.fromCache\n    );\n  }\n}\n\nexport class CollectionReference extends Query\n  implements firestore.CollectionReference {\n  constructor(path: ResourcePath, firestore: Firestore) {\n    super(InternalQuery.atPath(path), firestore);\n    if (path.length % 2 !== 1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid collection reference. Collection ' +\n          'references must have an odd number of segments, but ' +\n          `${path.canonicalString()} has ${path.length}`\n      );\n    }\n  }\n\n  get id(): string {\n    return this._query.path.lastSegment();\n  }\n\n  get parent(): firestore.DocumentReference | null {\n    const parentPath = this._query.path.popLast();\n    if (parentPath.isEmpty()) {\n      return null;\n    } else {\n      return new DocumentReference(new DocumentKey(parentPath), this.firestore);\n    }\n  }\n\n  get path(): string {\n    return this._query.path.canonicalString();\n  }\n\n  doc(pathString?: string): firestore.DocumentReference {\n    validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);\n    validateOptionalArgType('CollectionReference.doc', 'string', 1, pathString);\n    if (pathString === undefined) {\n      pathString = AutoId.newId();\n    }\n    if (typeof pathString !== 'string' || pathString === '') {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Document path must be a non-empty string'\n      );\n    }\n    const path = ResourcePath.fromString(pathString);\n    return DocumentReference.forPath(\n      this._query.path.child(path),\n      this.firestore\n    );\n  }\n\n  add(value: firestore.DocumentData): Promise<firestore.DocumentReference> {\n    validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n    validateArgType('CollectionReference.add', 'object', 1, value);\n    const docRef = this.doc();\n    return docRef.set(value).then(() => docRef);\n  }\n}\n\nfunction validateSetOptions(\n  methodName: string,\n  options: firestore.SetOptions | undefined\n): firestore.SetOptions {\n  if (options === undefined) {\n    return {\n      merge: false\n    };\n  }\n\n  validateOptionNames(methodName, options, ['merge']);\n  validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n  return options;\n}\n\nfunction validateReference(\n  methodName: string,\n  documentRef: firestore.DocumentReference,\n  firestore: Firestore\n): DocumentReference {\n  if (!(documentRef instanceof DocumentReference)) {\n    throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n  } else if (documentRef.firestore !== firestore) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Provided document reference is from a different Firestore instance.'\n    );\n  } else {\n    return documentRef;\n  }\n}\n\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\nexport function changesFromSnapshot(\n  firestore: Firestore,\n  snapshot: ViewSnapshot\n): firestore.DocumentChange[] {\n  if (snapshot.oldDocs.isEmpty()) {\n    // Special case the first snapshot because index calculation is easy and\n    // fast\n    let lastDoc: Document;\n    let index = 0;\n    return snapshot.docChanges.map(change => {\n      const doc = new DocumentSnapshot(\n        firestore,\n        change.doc.key,\n        change.doc,\n        snapshot.fromCache\n      );\n      assert(\n        change.type === ChangeType.Added,\n        'Invalid event type for first snapshot'\n      );\n      assert(\n        !lastDoc || snapshot.query.docComparator(lastDoc, change.doc) < 0,\n        'Got added events in wrong order'\n      );\n      lastDoc = change.doc;\n      return {\n        type: 'added' as firestore.DocumentChangeType,\n        doc,\n        oldIndex: -1,\n        newIndex: index++\n      };\n    });\n  } else {\n    // A DocumentSet that is updated incrementally as changes are applied to use\n    // to lookup the index of a document.\n    let indexTracker = snapshot.oldDocs;\n    return snapshot.docChanges.map(change => {\n      const doc = new DocumentSnapshot(\n        firestore,\n        change.doc.key,\n        change.doc,\n        snapshot.fromCache\n      );\n      let oldIndex = -1;\n      let newIndex = -1;\n      if (change.type !== ChangeType.Added) {\n        oldIndex = indexTracker.indexOf(change.doc.key);\n        assert(oldIndex >= 0, 'Index for document not found');\n        indexTracker = indexTracker.delete(change.doc.key);\n      }\n      if (change.type !== ChangeType.Removed) {\n        indexTracker = indexTracker.add(change.doc);\n        newIndex = indexTracker.indexOf(change.doc.key);\n      }\n      return { type: resultChangeType(change.type), doc, oldIndex, newIndex };\n    });\n  }\n}\n\nfunction resultChangeType(type: ChangeType): firestore.DocumentChangeType {\n  switch (type) {\n    case ChangeType.Added:\n      return 'added';\n    case ChangeType.Modified:\n    case ChangeType.Metadata:\n      return 'modified';\n    case ChangeType.Removed:\n      return 'removed';\n    default:\n      return fail('Unknown change type: ' + type);\n  }\n}\n\n// Export the classes with a private constructor (it will fail if invoked\n// at runtime). Note that this still allows instanceof checks.\n\n// We're treating the variables as class names, so disable checking for lower\n// case variable names.\n// tslint:disable:variable-name\nexport const PublicFirestore = makeConstructorPrivate(\n  Firestore,\n  'Use firebase.firestore() instead.'\n);\nexport const PublicTransaction = makeConstructorPrivate(\n  Transaction,\n  'Use firebase.firestore().runTransaction() instead.'\n);\nexport const PublicWriteBatch = makeConstructorPrivate(\n  WriteBatch,\n  'Use firebase.firestore().batch() instead.'\n);\nexport const PublicDocumentReference = makeConstructorPrivate(\n  DocumentReference,\n  'Use firebase.firestore().doc() instead.'\n);\nexport const PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);\nexport const PublicQuery = makeConstructorPrivate(Query);\nexport const PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);\nexport const PublicCollectionReference = makeConstructorPrivate(\n  CollectionReference,\n  'Use firebase.firestore().collection() instead.'\n);\n// tslint:enable:variable-name\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { FieldPath as ExternalFieldPath } from './field_path';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { FirestoreClient } from '../core/firestore_client';\nimport { Bound, Direction, fieldFilter, OrderBy, Query as InternalQuery, RelationFilter, RelationOp } from '../core/query';\nimport { ChangeType } from '../core/view_snapshot';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { ArrayValue, ObjectValue, RefValue } from '../model/field_value';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { ResourcePath } from '../model/path';\nimport { PlatformSupport } from '../platform/platform';\nimport { makeConstructorPrivate } from '../util/api';\nimport { assert, fail } from '../util/assert';\nimport { AsyncObserver } from '../util/async_observer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { invalidClassError, validateArgType, validateAtLeastNumberOfArgs, validateBetweenNumberOfArgs, validateDefined, validateExactNumberOfArgs, validateNamedOptionalType, validateNamedType, validateOptionalArgType, validateOptionNames, valueDescription } from '../util/input_validation';\nimport * as log from '../util/log';\nimport { LogLevel } from '../util/log';\nimport { AutoId } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { PromiseImpl as Promise } from '../../utils/promise';\nimport { EmptyCredentialsProvider, FirebaseCredentialsProvider, makeCredentialsProvider } from './credentials';\nimport { isPartialObserver } from './observer';\nimport { DocumentKeyReference, fieldPathFromArgument, UserDataConverter } from './user_data_converter';\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\nvar DEFAULT_HOST = 'firestore.googleapis.com';\nvar DEFAULT_SSL = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nvar FirestoreSettings = /** @class */ (function () {\n    function FirestoreSettings(settings) {\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            validateNamedType('settings', 'string', 'host', settings.host);\n            this.host = settings.host;\n            validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n            this.ssl = objUtils.defaulted(settings.ssl, DEFAULT_SSL);\n        }\n        validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);\n        validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);\n        this.credentials = settings.credentials;\n    }\n    FirestoreSettings.prototype.equals = function (other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials);\n    };\n    return FirestoreSettings;\n}());\nvar FirestoreConfig = /** @class */ (function () {\n    function FirestoreConfig() {\n    }\n    return FirestoreConfig;\n}());\n/**\n * The root reference to the database.\n */\nvar Firestore = /** @class */ (function () {\n    function Firestore(databaseIdOrApp) {\n        var _this = this;\n        this.INTERNAL = {\n            delete: function () {\n                if (_this._firestoreClient) {\n                    return _this._firestoreClient.shutdown();\n                }\n                else {\n                    return Promise.resolve();\n                }\n            }\n        };\n        var config = new FirestoreConfig();\n        if (typeof databaseIdOrApp.options === 'object') {\n            // This is very likely a Firebase app object\n            // TODO(b/34177605): Can we somehow use instanceof?\n            var app = databaseIdOrApp;\n            config.firebaseApp = app;\n            config.databaseId = Firestore.databaseIdFromApp(app);\n            config.persistenceKey = config.firebaseApp.name;\n            config.credentials = new FirebaseCredentialsProvider(app);\n        }\n        else {\n            var external_1 = databaseIdOrApp;\n            if (!external_1.projectId) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');\n            }\n            config.databaseId = new DatabaseId(external_1.projectId, external_1.database);\n            // Use a default persistenceKey that lines up with firebase.app.App.\n            config.persistenceKey = '[DEFAULT]';\n            config.credentials = new EmptyCredentialsProvider();\n        }\n        config.settings = new FirestoreSettings({});\n        this._config = config;\n    }\n    Object.defineProperty(Firestore.prototype, \"_databaseId\", {\n        get: function () {\n            return this._config.databaseId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.prototype.settings = function (settingsLiteral) {\n        validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n        validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n        if (objUtils.contains(settingsLiteral, 'persistence')) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to ' +\n                'firestore.enablePersistence().');\n        }\n        var newSettings = new FirestoreSettings(settingsLiteral);\n        if (this._firestoreClient && !this._config.settings.equals(newSettings)) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only call settings() before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._config.settings = newSettings;\n        if (newSettings.credentials !== undefined) {\n            this._config.credentials = makeCredentialsProvider(newSettings.credentials);\n        }\n    };\n    Firestore.prototype.enablePersistence = function () {\n        if (this._firestoreClient) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' +\n                'be enabled. You can only call enablePersistence() before calling ' +\n                'any other methods on a Firestore object.');\n        }\n        return this.configureClient(/* persistence= */ true);\n    };\n    Firestore.prototype.ensureClientConfigured = function () {\n        if (!this._firestoreClient) {\n            this.configureClient(/* persistence= */ false);\n        }\n        return this._firestoreClient;\n    };\n    Firestore.prototype.configureClient = function (persistence) {\n        var _this = this;\n        assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');\n        assert(!this._firestoreClient, 'configureClient() called multiple times');\n        var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);\n        var preConverter = function (value) {\n            if (value instanceof DocumentReference) {\n                var thisDb = _this._config.databaseId;\n                var otherDb = value.firestore._config.databaseId;\n                if (!otherDb.equals(thisDb)) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' +\n                        (otherDb.projectId + \"/\" + otherDb.database + \" but should be \") +\n                        (\"for database \" + thisDb.projectId + \"/\" + thisDb.database));\n                }\n                return new DocumentKeyReference(_this._config.databaseId, value._key);\n            }\n            else {\n                return value;\n            }\n        };\n        this._dataConverter = new UserDataConverter(preConverter);\n        this._firestoreClient = new FirestoreClient(PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, new AsyncQueue());\n        return this._firestoreClient.start(persistence);\n    };\n    Firestore.databaseIdFromApp = function (app) {\n        var options = app.options;\n        if (!objUtils.contains(options, 'projectId')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreId' once alpha testers have upgraded.\n            if (objUtils.contains(options, 'firestoreId')) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreId\" is now specified as \"projectId\" in ' +\n                    'firebase.initializeApp.');\n            }\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n        }\n        if (objUtils.contains(options, 'firestoreOptions')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreOptions' once alpha testers have upgraded.\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreOptions\" values are now specified with ' +\n                'Firestore.settings()');\n        }\n        var projectId = options['projectId'];\n        if (!projectId || typeof projectId !== 'string') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in firebase.app.App.options');\n        }\n        return new DatabaseId(projectId);\n    };\n    Object.defineProperty(Firestore.prototype, \"app\", {\n        get: function () {\n            if (!this._config.firebaseApp) {\n                throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                    'not available');\n            }\n            return this._config.firebaseApp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n        validateArgType('Firestore.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');\n        }\n        this.ensureClientConfigured();\n        return new CollectionReference(ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.doc = function (pathString) {\n        validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n        validateArgType('Firestore.doc', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');\n        }\n        this.ensureClientConfigured();\n        return DocumentReference.forPath(ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.runTransaction = function (updateFunction) {\n        var _this = this;\n        validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n        validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n        return this.ensureClientConfigured().transaction(function (transaction) {\n            return updateFunction(new Transaction(_this, transaction));\n        });\n    };\n    Firestore.prototype.batch = function () {\n        this.ensureClientConfigured();\n        return new WriteBatch(this);\n    };\n    Object.defineProperty(Firestore, \"logLevel\", {\n        get: function () {\n            switch (log.getLogLevel()) {\n                case LogLevel.DEBUG:\n                    return 'debug';\n                case LogLevel.ERROR:\n                    return 'error';\n                case LogLevel.SILENT:\n                    return 'silent';\n                default:\n                    return fail('Unknown log level: ' + log.getLogLevel());\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.setLogLevel = function (level) {\n        validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n        validateArgType('Firestore.setLogLevel', 'string', 1, level);\n        switch (level) {\n            case 'debug':\n                log.setLogLevel(log.LogLevel.DEBUG);\n                break;\n            case 'error':\n                log.setLogLevel(log.LogLevel.ERROR);\n                break;\n            case 'silent':\n                log.setLogLevel(log.LogLevel.SILENT);\n                break;\n            default:\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);\n        }\n    };\n    return Firestore;\n}());\nexport { Firestore };\n/**\n * A reference to a transaction.\n */\nvar Transaction = /** @class */ (function () {\n    function Transaction(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n    }\n    Transaction.prototype.get = function (documentRef) {\n        var _this = this;\n        validateExactNumberOfArgs('Transaction.get', arguments, 1);\n        var ref = validateReference('Transaction.get', documentRef, this._firestore);\n        return this._transaction\n            .lookup([ref._key])\n            .then(function (docs) {\n            if (!docs || docs.length !== 1) {\n                return fail('Mismatch in docs returned from document lookup.');\n            }\n            var doc = docs[0];\n            if (doc instanceof NoDocument) {\n                return new DocumentSnapshot(_this._firestore, ref._key, null, false);\n            }\n            return new DocumentSnapshot(_this._firestore, ref._key, doc, false);\n        });\n    };\n    Transaction.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n        var ref = validateReference('Transaction.set', documentRef, this._firestore);\n        options = validateSetOptions('Transaction.set', options);\n        var parsed = this._firestore._dataConverter.parseSetData('Transaction.set', value, options);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('Transaction.update', arguments, 2);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n        var ref = validateReference('Transaction.delete', documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    };\n    return Transaction;\n}());\nexport { Transaction };\nvar WriteBatch = /** @class */ (function () {\n    function WriteBatch(_firestore) {\n        this._firestore = _firestore;\n        this._mutations = [];\n        this._committed = false;\n    }\n    WriteBatch.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.set', documentRef, this._firestore);\n        options = validateSetOptions('WriteBatch.set', options);\n        var parsed = this._firestore._dataConverter.parseSetData('WriteBatch.set', value, options);\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        this.verifyNotCommitted();\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);\n        }\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.exists(true)));\n        return this;\n    };\n    WriteBatch.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.commit = function () {\n        this.verifyNotCommitted();\n        this._committed = true;\n        if (this._mutations.length > 0) {\n            return this._firestore.ensureClientConfigured().write(this._mutations);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    WriteBatch.prototype.verifyNotCommitted = function () {\n        if (this._committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    };\n    return WriteBatch;\n}());\nexport { WriteBatch };\n/**\n * A reference to a particular document in a collection in the database.\n */\nvar DocumentReference = /** @class */ (function () {\n    function DocumentReference(_key, firestore) {\n        this._key = _key;\n        this.firestore = firestore;\n        this._firestoreClient = this.firestore.ensureClientConfigured();\n    }\n    DocumentReference.forPath = function (path, firestore) {\n        if (path.length % 2 !== 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' +\n                'references must have an even number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return new DocumentReference(new DocumentKey(path), firestore);\n    };\n    Object.defineProperty(DocumentReference.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"parent\", {\n        get: function () {\n            return new CollectionReference(this._key.path.popLast(), this.firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"path\", {\n        get: function () {\n            return this._key.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentReference.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n        validateArgType('DocumentReference.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');\n        }\n        var path = ResourcePath.fromString(pathString);\n        return new CollectionReference(this._key.path.child(path), this.firestore);\n    };\n    DocumentReference.prototype.set = function (value, options) {\n        validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n        options = validateSetOptions('DocumentReference.set', options);\n        var parsed = this.firestore._dataConverter.parseSetData('DocumentReference.set', value, options);\n        return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.NONE));\n    };\n    DocumentReference.prototype.update = function (fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 2] = arguments[_i];\n        }\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n            parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n            parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);\n        }\n        return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.exists(true)));\n    };\n    DocumentReference.prototype.delete = function () {\n        validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n        return this._firestoreClient.write([\n            new DeleteMutation(this._key, Precondition.NONE)\n        ]);\n    };\n    DocumentReference.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);\n        var options = {\n            includeMetadataChanges: false\n        };\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('DocumentReference.onSnapshot', options, [\n                'includeMetadataChanges'\n            ]);\n            validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);\n            currArg++;\n        }\n        var internalOptions = {\n            includeDocumentMetadataChanges: options.includeMetadataChanges,\n            includeQueryMetadataChanges: options.includeMetadataChanges\n        };\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(internalOptions, observer);\n    };\n    DocumentReference.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (snapshot) {\n                if (observer.next) {\n                    assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');\n                    var doc = snapshot.docs.get(_this._key);\n                    observer.next(new DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));\n                }\n            },\n            error: errHandler\n        });\n        var internalListener = this._firestoreClient.listen(InternalQuery.atPath(this._key.path), asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            _this._firestoreClient.unlisten(internalListener);\n        };\n    };\n    DocumentReference.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('DocumentReference.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeQueryMetadataChanges: true,\n                includeDocumentMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (snap) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    if (!snap.exists && snap.metadata.fromCache) {\n                        // TODO(dimond): If we're online and the document doesn't\n                        // exist then we resolve with a doc.exists set to false. If\n                        // we're offline however, we reject the Promise in this\n                        // case. Two options: 1) Cache the negative response from\n                        // the server so we can deliver that even when you're\n                        // offline 2) Actually reject the Promise in the online case\n                        // if the document doesn't exist.\n                        reject(new FirestoreError(Code.ABORTED, 'Failed to get document because the client is ' + 'offline.'));\n                    }\n                    else {\n                        resolve(snap);\n                    }\n                },\n                error: reject\n            });\n        });\n    };\n    return DocumentReference;\n}());\nexport { DocumentReference };\nvar DocumentSnapshot = /** @class */ (function () {\n    function DocumentSnapshot(_firestore, _key, _document, _fromCache) {\n        this._firestore = _firestore;\n        this._key = _key;\n        this._document = _document;\n        this._fromCache = _fromCache;\n    }\n    DocumentSnapshot.prototype.data = function () {\n        validateExactNumberOfArgs('DocumentSnapshot.data', arguments, 0);\n        if (!this._document) {\n            throw new FirestoreError(Code.NOT_FOUND, \"This document doesn't exist. Check doc.exists to make sure \" +\n                'the document exists before calling doc.data().');\n        }\n        return this.convertObject(this._document.data);\n    };\n    DocumentSnapshot.prototype.get = function (fieldPath) {\n        validateExactNumberOfArgs('DocumentSnapshot.get', arguments, 1);\n        if (!this._document) {\n            throw new FirestoreError(Code.NOT_FOUND, \"This document doesn't exist. Check doc.exists to make sure \" +\n                'the document exists before calling doc.get().');\n        }\n        var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n        return value === undefined ? undefined : this.convertValue(value);\n    };\n    Object.defineProperty(DocumentSnapshot.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"ref\", {\n        get: function () {\n            return new DocumentReference(this._key, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"exists\", {\n        get: function () {\n            return this._document !== null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"metadata\", {\n        get: function () {\n            return {\n                hasPendingWrites: this._document !== null && this._document.hasLocalMutations,\n                fromCache: this._fromCache\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentSnapshot.prototype.convertObject = function (data) {\n        var _this = this;\n        var result = {};\n        data.forEach(function (key, value) {\n            result[key] = _this.convertValue(value);\n        });\n        return result;\n    };\n    DocumentSnapshot.prototype.convertValue = function (value) {\n        if (value instanceof ObjectValue) {\n            return this.convertObject(value);\n        }\n        else if (value instanceof ArrayValue) {\n            return this.convertArray(value);\n        }\n        else if (value instanceof RefValue) {\n            var key = value.value();\n            var database = this._firestore.ensureClientConfigured().databaseId();\n            if (!value.databaseId.equals(database)) {\n                // TODO(b/64130202): Somehow support foreign references.\n                log.error(\"Document \" + this._key.path + \" contains a document \" +\n                    \"reference within a different database (\" +\n                    (value.databaseId.projectId + \"/\" + value.databaseId\n                        .database + \") which is not \") +\n                    \"supported. It will be treated as a reference in the current \" +\n                    (\"database (\" + database.projectId + \"/\" + database.database + \") \") +\n                    \"instead.\");\n            }\n            return new DocumentReference(key, this._firestore);\n        }\n        else {\n            return value.value();\n        }\n    };\n    DocumentSnapshot.prototype.convertArray = function (data) {\n        var _this = this;\n        return data.internalValue.map(function (value) {\n            return _this.convertValue(value);\n        });\n    };\n    return DocumentSnapshot;\n}());\nexport { DocumentSnapshot };\nvar Query = /** @class */ (function () {\n    function Query(_query, firestore) {\n        this._query = _query;\n        this.firestore = firestore;\n    }\n    Query.prototype.where = function (field, opStr, value) {\n        validateExactNumberOfArgs('Query.where', arguments, 3);\n        validateArgType('Query.where', 'string', 2, opStr);\n        validateDefined('Query.where', 3, value);\n        var fieldValue;\n        var fieldPath = fieldPathFromArgument('Query.where', field);\n        if (fieldPath.isKeyField()) {\n            if (typeof value === 'string') {\n                if (value.indexOf('/') !== -1) {\n                    // TODO(dimond): Allow slashes once ancestor queries are supported\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it contains a slash.');\n                }\n                if (value === '') {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it was an empty string.');\n                }\n                var path = this._query.path.child(new ResourcePath([value]));\n                assert(path.length % 2 === 0, 'Path should be a document key');\n                fieldValue = new RefValue(this.firestore._databaseId, new DocumentKey(path));\n            }\n            else if (value instanceof DocumentReference) {\n                var ref = value;\n                fieldValue = new RefValue(this.firestore._databaseId, ref._key);\n            }\n            else {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a \" +\n                    \"string or a DocumentReference if the first parameter is \" +\n                    \"FieldPath.documentId(), but it was: \" +\n                    (valueDescription(value) + \".\"));\n            }\n        }\n        else {\n            fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);\n        }\n        var filter = fieldFilter(fieldPath, RelationOp.fromString(opStr), fieldValue);\n        this.validateNewFilter(filter);\n        return new Query(this._query.addFilter(filter), this.firestore);\n    };\n    Query.prototype.orderBy = function (field, directionStr) {\n        validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n        validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);\n        var direction;\n        if (directionStr === undefined || directionStr === 'asc') {\n            direction = Direction.ASCENDING;\n        }\n        else if (directionStr === 'desc') {\n            direction = Direction.DESCENDING;\n        }\n        else {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + directionStr + \"', \" +\n                \"expected 'asc' or 'desc'.\");\n        }\n        if (this._query.startAt !== null) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' +\n                'Query.startAfter() before calling Query.orderBy().');\n        }\n        if (this._query.endAt !== null) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' +\n                'Query.endBefore() before calling Query.orderBy().');\n        }\n        var fieldPath = fieldPathFromArgument('Query.orderBy', field);\n        var orderBy = new OrderBy(fieldPath, direction);\n        this.validateNewOrderBy(orderBy);\n        return new Query(this._query.addOrderBy(orderBy), this.firestore);\n    };\n    Query.prototype.limit = function (n) {\n        validateExactNumberOfArgs('Query.limit', arguments, 1);\n        validateArgType('Query.limit', 'number', 1, n);\n        if (n <= 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + n + \") is invalid. Limit must be \" +\n                'positive.');\n        }\n        return new Query(this._query.withLimit(n), this.firestore);\n    };\n    Query.prototype.startAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.startAfter = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.endBefore = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.endAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    /** Helper function to create a bound from a document or fields */\n    Query.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) {\n        validateDefined(methodName, 1, docOrField);\n        if (docOrField instanceof DocumentSnapshot) {\n            if (fields.length > 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"().\");\n            }\n            var snap = docOrField;\n            if (!snap.exists) {\n                throw new FirestoreError(Code.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" +\n                    (methodName + \"().\"));\n            }\n            return this.boundFromDocument(methodName, snap._document, before);\n        }\n        else {\n            var allFields = [docOrField].concat(fields);\n            return this.boundFromFields(methodName, allFields, before);\n        }\n    };\n    /**\n     * Create a Bound from a query and a document.\n     *\n     * Note that the Bound will always include the key of the document\n     * and so only the provided document will compare equal to the returned\n     * position.\n     *\n     * Will throw if the document does not contain all fields of the order by\n     * of the query.\n     */\n    Query.prototype.boundFromDocument = function (methodName, doc, before) {\n        var components = [];\n        // Because people expect to continue/end a query at the exact document\n        // provided, we need to use the implicit sort order rather than the explicit\n        // sort order, because it's guaranteed to contain the document key. That way\n        // the position becomes unambiguous and the query continues/ends exactly at\n        // the provided document. Without the key (by using the explicit sort\n        // orders), multiple documents could match the position, yielding duplicate\n        // results.\n        for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            if (orderBy.field.isKeyField()) {\n                components.push(new RefValue(this.firestore._databaseId, doc.key));\n            }\n            else {\n                var value = doc.field(orderBy.field);\n                if (value !== undefined) {\n                    components.push(value);\n                }\n                else {\n                    var field = orderBy.field.canonicalString();\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a \" +\n                        (\"document for which the field '\" + field + \"' (used as the \") +\n                        \"orderBy) does not exist.\");\n                }\n            }\n        }\n        return new Bound(components, before);\n    };\n    /**\n     * Converts a list of field values to a Bound for the given query.\n     */\n    Query.prototype.boundFromFields = function (methodName, values, before) {\n        // Use explicit order by's because it has to match the query the user made\n        var orderBy = this._query.explicitOrderBy;\n        if (values.length > orderBy.length) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"(). \" +\n                \"The number of arguments must be less than or equal to the \" +\n                \"number of Query.orderBy() clauses\");\n        }\n        var components = [];\n        for (var i = 0; i < values.length; i++) {\n            var rawValue = values[i];\n            var orderByComponent = orderBy[i];\n            if (orderByComponent.field.isKeyField()) {\n                if (typeof rawValue !== 'string') {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" +\n                        (methodName + \"(), but got a \" + typeof rawValue));\n                }\n                if (rawValue.indexOf('/') !== -1) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Document ID '\" + rawValue + \"' contains a slash in \" +\n                        (methodName + \"()\"));\n                }\n                var key = new DocumentKey(this._query.path.child(rawValue));\n                components.push(new RefValue(this.firestore._databaseId, key));\n            }\n            else {\n                var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);\n                components.push(wrapped);\n            }\n        }\n        return new Bound(components, before);\n    };\n    Query.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n        var options = {};\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('Query.onSnapshot', options, [\n                'includeQueryMetadataChanges',\n                'includeDocumentMetadataChanges'\n            ]);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeDocumentMetadataChanges', options.includeDocumentMetadataChanges);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeQueryMetadataChanges', options.includeQueryMetadataChanges);\n            currArg++;\n        }\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(options, observer);\n    };\n    Query.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (result) {\n                if (observer.next) {\n                    observer.next(new QuerySnapshot(_this.firestore, _this._query, result));\n                }\n            },\n            error: errHandler\n        });\n        var firestoreClient = this.firestore.ensureClientConfigured();\n        var internalListener = firestoreClient.listen(this._query, asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            firestoreClient.unlisten(internalListener);\n        };\n    };\n    Query.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('Query.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeDocumentMetadataChanges: false,\n                includeQueryMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (result) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    resolve(result);\n                },\n                error: reject\n            });\n        });\n    };\n    Query.prototype.validateNewFilter = function (filter) {\n        if (filter instanceof RelationFilter && filter.isInequality()) {\n            var existingField = this._query.getInequalityFilterField();\n            if (existingField !== null && !existingField.equals(filter.field)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' +\n                    ' (<, <=, >, or >=) must be on the same field. But you have' +\n                    (\" inequality filters on '\" + existingField.toString() + \"'\") +\n                    (\" and '\" + filter.field.toString() + \"'\"));\n            }\n            var firstOrderByField = this._query.getFirstOrderByField();\n            if (firstOrderByField !== null) {\n                this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);\n            }\n        }\n    };\n    Query.prototype.validateNewOrderBy = function (orderBy) {\n        if (this._query.getFirstOrderByField() === null) {\n            // This is the first order by. It must match any inequality.\n            var inequalityField = this._query.getInequalityFilterField();\n            if (inequalityField !== null) {\n                this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n            }\n        }\n    };\n    Query.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) {\n        if (!orderBy.equals(inequality)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality \" +\n                (\"(<, <=, >, or >=) on field '\" + inequality.toString() + \"' \") +\n                (\"and so you must also use '\" + inequality.toString() + \"' \") +\n                \"as your first Query.orderBy(), but your first Query.orderBy() \" +\n                (\"is on field '\" + orderBy.toString() + \"' instead.\"));\n        }\n    };\n    return Query;\n}());\nexport { Query };\nvar QuerySnapshot = /** @class */ (function () {\n    function QuerySnapshot(_firestore, _originalQuery, _snapshot) {\n        this._firestore = _firestore;\n        this._originalQuery = _originalQuery;\n        this._snapshot = _snapshot;\n        this._cachedChanges = null;\n        this.metadata = {\n            fromCache: _snapshot.fromCache,\n            hasPendingWrites: _snapshot.hasPendingWrites\n        };\n    }\n    Object.defineProperty(QuerySnapshot.prototype, \"docs\", {\n        get: function () {\n            var result = [];\n            this.forEach(function (doc) { return result.push(doc); });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"empty\", {\n        get: function () {\n            return this._snapshot.docs.isEmpty();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"size\", {\n        get: function () {\n            return this._snapshot.docs.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QuerySnapshot.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n        validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n        this._snapshot.docs.forEach(function (doc) {\n            callback.call(thisArg, _this.convertToDocumentImpl(doc));\n        });\n    };\n    Object.defineProperty(QuerySnapshot.prototype, \"query\", {\n        get: function () {\n            return new Query(this._originalQuery, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"docChanges\", {\n        get: function () {\n            if (!this._cachedChanges) {\n                this._cachedChanges = changesFromSnapshot(this._firestore, this._snapshot);\n            }\n            return this._cachedChanges;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QuerySnapshot.prototype.convertToDocumentImpl = function (doc) {\n        return new DocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);\n    };\n    return QuerySnapshot;\n}());\nexport { QuerySnapshot };\nvar CollectionReference = /** @class */ (function (_super) {\n    __extends(CollectionReference, _super);\n    function CollectionReference(path, firestore) {\n        var _this = _super.call(this, InternalQuery.atPath(path), firestore) || this;\n        if (path.length % 2 !== 1) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' +\n                'references must have an odd number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return _this;\n    }\n    Object.defineProperty(CollectionReference.prototype, \"id\", {\n        get: function () {\n            return this._query.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"parent\", {\n        get: function () {\n            var parentPath = this._query.path.popLast();\n            if (parentPath.isEmpty()) {\n                return null;\n            }\n            else {\n                return new DocumentReference(new DocumentKey(parentPath), this.firestore);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"path\", {\n        get: function () {\n            return this._query.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CollectionReference.prototype.doc = function (pathString) {\n        validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);\n        validateOptionalArgType('CollectionReference.doc', 'string', 1, pathString);\n        if (pathString === undefined) {\n            pathString = AutoId.newId();\n        }\n        if (typeof pathString !== 'string' || pathString === '') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');\n        }\n        var path = ResourcePath.fromString(pathString);\n        return DocumentReference.forPath(this._query.path.child(path), this.firestore);\n    };\n    CollectionReference.prototype.add = function (value) {\n        validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n        validateArgType('CollectionReference.add', 'object', 1, value);\n        var docRef = this.doc();\n        return docRef.set(value).then(function () { return docRef; });\n    };\n    return CollectionReference;\n}(Query));\nexport { CollectionReference };\nfunction validateSetOptions(methodName, options) {\n    if (options === undefined) {\n        return {\n            merge: false\n        };\n    }\n    validateOptionNames(methodName, options, ['merge']);\n    validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n    return options;\n}\nfunction validateReference(methodName, documentRef, firestore) {\n    if (!(documentRef instanceof DocumentReference)) {\n        throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n    }\n    else if (documentRef.firestore !== firestore) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\nexport function changesFromSnapshot(firestore, snapshot) {\n    if (snapshot.oldDocs.isEmpty()) {\n        // Special case the first snapshot because index calculation is easy and\n        // fast\n        var lastDoc_1;\n        var index_1 = 0;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');\n            assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');\n            lastDoc_1 = change.doc;\n            return {\n                type: 'added',\n                doc: doc,\n                oldIndex: -1,\n                newIndex: index_1++\n            };\n        });\n    }\n    else {\n        // A DocumentSet that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        var indexTracker_1 = snapshot.oldDocs;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            var oldIndex = -1;\n            var newIndex = -1;\n            if (change.type !== ChangeType.Added) {\n                oldIndex = indexTracker_1.indexOf(change.doc.key);\n                assert(oldIndex >= 0, 'Index for document not found');\n                indexTracker_1 = indexTracker_1.delete(change.doc.key);\n            }\n            if (change.type !== ChangeType.Removed) {\n                indexTracker_1 = indexTracker_1.add(change.doc);\n                newIndex = indexTracker_1.indexOf(change.doc.key);\n            }\n            return { type: resultChangeType(change.type), doc: doc, oldIndex: oldIndex, newIndex: newIndex };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case ChangeType.Added:\n            return 'added';\n        case ChangeType.Modified:\n        case ChangeType.Metadata:\n            return 'modified';\n        case ChangeType.Removed:\n            return 'removed';\n        default:\n            return fail('Unknown change type: ' + type);\n    }\n}\n// Export the classes with a private constructor (it will fail if invoked\n// at runtime). Note that this still allows instanceof checks.\n// We're treating the variables as class names, so disable checking for lower\n// case variable names.\n// tslint:disable:variable-name\nexport var PublicFirestore = makeConstructorPrivate(Firestore, 'Use firebase.firestore() instead.');\nexport var PublicTransaction = makeConstructorPrivate(Transaction, 'Use firebase.firestore().runTransaction() instead.');\nexport var PublicWriteBatch = makeConstructorPrivate(WriteBatch, 'Use firebase.firestore().batch() instead.');\nexport var PublicDocumentReference = makeConstructorPrivate(DocumentReference, 'Use firebase.firestore().doc() instead.');\nexport var PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);\nexport var PublicQuery = makeConstructorPrivate(Query);\nexport var PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);\nexport var PublicCollectionReference = makeConstructorPrivate(CollectionReference, 'Use firebase.firestore().collection() instead.');\n// tslint:enable:variable-name\n\n\n"]}