{"version":3,"sources":["src/firestore/platform_browser/webchannel_connection.ts"],"names":["log","LOG_TAG","RPC_URL_VERSION","X_GOOG_API_CLIENT_VALUE","XHR_TIMEOUT_SECS","WebChannelConnection","info","databaseId","pool","proto","ssl","baseUrl","host","prototype","modifyHeadersForRequest","headers","token","header","authHeaders","hasOwnProperty","projectId","database","invoke","rpcName","request","_this","url","makeUrl","resolve","reject","getObject","xhr","listenOnce","COMPLETE","getLastErrorCode","NO_ERROR","json","getResponseJson","debug","JSON","stringify","TIMEOUT","error","DEADLINE_EXCEEDED","HTTP_ERROR","status_1","getStatus","getResponseText","getStatusText","UNAVAILABLE","getLastError","releaseObject","requestString","send","openStream","rpcService","RPC_STREAM_SERVICE_MAPPING","rpcUrlName","RPC_STREAM_NAME_MAPPING","urlParts","webchannelTransport","backgroundChannelTest","httpSessionIdParam","initMessageHeaders","sendRawJson","supportsCrossDomainXhr","join","channel","createWebChannel","opened","closed","streamBridge","sendFn","msg","open","closeFn","close","unguardedEventListen","type","fn","listen","param","e","setTimeout","EventType","OPEN","CLOSE","callOnClose","ERROR","err","MESSAGE","msgData","data","status_2","status","code","message","undefined","INTERNAL","callOnMessage","callOnOpen","push","Write","Listen"],"mappings":"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","file":"webchannel_connection.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ErrorCode,\n  EventType,\n  WebChannel,\n  XhrIoPool,\n  createWebChannelTransport\n} from '@firebase/webchannel-wrapper';\n\nimport { Token } from '../api/credentials';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { SDK_VERSION } from '../core/version';\nimport { Connection, Stream } from '../remote/connection';\nimport {\n  mapCodeFromHttpStatus,\n  mapCodeFromRpcStatus\n} from '../remote/rpc_error';\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { Rejecter, Resolver } from '../util/promise';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nconst LOG_TAG = 'Connection';\n\nconst RPC_URL_VERSION = 'v1beta1';\n\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nconst X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;\n\nconst XHR_TIMEOUT_SECS = 15;\n\nexport class WebChannelConnection implements Connection {\n  private readonly databaseId: DatabaseId;\n  private readonly baseUrl: string;\n  private readonly pool: XhrIoPool;\n\n  /**\n   * Mapping from RPC name to service providing the RPC.\n   * For streaming RPCs only.\n   */\n  private static RPC_STREAM_SERVICE_MAPPING: { [rpc: string]: string } = {\n    Write: 'google.firestore.v1beta1.Firestore',\n    Listen: 'google.firestore.v1beta1.Firestore'\n  };\n\n  /**\n   * Mapping from RPC name to actual RPC name in URLs.\n   * For streaming RPCs only.\n   */\n  private static RPC_STREAM_NAME_MAPPING: { [rpc: string]: string } = {\n    Write: 'Write',\n    Listen: 'Listen'\n  };\n\n  constructor(info: DatabaseInfo) {\n    this.databaseId = info.databaseId;\n    this.pool = new XhrIoPool();\n    const proto = info.ssl ? 'https' : 'http';\n    this.baseUrl = proto + '://' + info.host;\n  }\n\n  /**\n   * Modifies the headers for a request, adding any authorization token if\n   * present and any additional headers for the request.\n   */\n  private modifyHeadersForRequest(\n    headers: { [key: string]: string },\n    token: Token | null\n  ) {\n    if (token) {\n      for (const header in token.authHeaders) {\n        if (token.authHeaders.hasOwnProperty(header)) {\n          headers[header] = token.authHeaders[header];\n        }\n      }\n    }\n    headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;\n    // This header is used to improve routing and project isolation by the\n    // backend.\n    headers['google-cloud-resource-prefix'] =\n      `projects/${this.databaseId.projectId}/` +\n      `databases/${this.databaseId.database}`;\n  }\n\n  invoke(rpcName: string, request: any, token: Token | null): Promise<any> {\n    const url = this.makeUrl(rpcName);\n\n    return new Promise((resolve: Resolver<any>, reject: Rejecter) => {\n      this.pool.getObject((xhr: any) => {\n        xhr.listenOnce(EventType.COMPLETE, () => {\n          try {\n            switch (xhr.getLastErrorCode()) {\n              case ErrorCode.NO_ERROR:\n                const json = xhr.getResponseJson();\n                log.debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                resolve(json);\n                break;\n              case ErrorCode.TIMEOUT:\n                log.error('RPC \"' + rpcName + '\" timed out, retrying.');\n                reject(\n                  new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out')\n                );\n                break;\n              case ErrorCode.HTTP_ERROR:\n                const status = xhr.getStatus();\n                log.error(\n                  'RPC \"' + rpcName + '\" failed with status:',\n                  status,\n                  'response text:',\n                  xhr.getResponseText()\n                );\n                if (status > 0) {\n                  reject(\n                    new FirestoreError(\n                      mapCodeFromHttpStatus(status),\n                      'Server responded with status ' + xhr.getStatusText()\n                    )\n                  );\n                } else {\n                  // If we received an HTTP_ERROR but there's no status code,\n                  // it's most probably a connection issue, let's retry.\n                  log.error(LOG_TAG, 'RPC \"' + rpcName + '\" failed, retrying.');\n                  reject(\n                    new FirestoreError(Code.UNAVAILABLE, 'Connection failed.')\n                  );\n                }\n                break;\n              default:\n                fail(\n                  'RPC \"' +\n                    rpcName +\n                    '\" failed with unanticipated ' +\n                    'webchannel error ' +\n                    xhr.getLastErrorCode() +\n                    ': ' +\n                    xhr.getLastError() +\n                    ', giving up.'\n                );\n            }\n          } finally {\n            log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n            this.pool.releaseObject(xhr);\n          }\n        });\n\n        const requestString = JSON.stringify(request);\n        log.debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);\n        // Content-Type: text/plain will avoid preflight requests which might\n        // mess with CORS and redirects by proxies. If we add custom headers\n        // we will need to change this code to potentially use the\n        // $httpOverwrite parameter supported by ESF to avoid\n        // triggering preflight requests.\n        const headers: any = { 'Content-Type': 'text/plain' };\n\n        this.modifyHeadersForRequest(headers, token);\n\n        xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n      });\n    });\n  }\n\n  openStream(rpcName: string, token: Token | null): Stream<any, any> {\n    const rpcService = WebChannelConnection.RPC_STREAM_SERVICE_MAPPING[rpcName];\n    const rpcUrlName = WebChannelConnection.RPC_STREAM_NAME_MAPPING[rpcName];\n    if (!rpcService || !rpcUrlName) {\n      fail('Unknown RPC name: ' + rpcName);\n    }\n    const urlParts = [\n      this.baseUrl,\n      '/',\n      rpcService,\n      '/',\n      rpcUrlName,\n      '/channel'\n    ];\n    const webchannelTransport = createWebChannelTransport();\n    const request = {\n      // Background channel test avoids the initial two test calls and decreases\n      // initial cold start time.\n      // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n      // we should monitor closely for any reports.\n      backgroundChannelTest: true,\n      // Required for backend stickiness, routing behavior is based on this\n      // parameter.\n      httpSessionIdParam: 'gsessionid',\n      initMessageHeaders: {},\n      sendRawJson: true,\n      supportsCrossDomainXhr: true\n    };\n    this.modifyHeadersForRequest(request.initMessageHeaders, token);\n    const url = urlParts.join('');\n    log.debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);\n    // tslint:disable-next-line:no-any Because listen isn't defined on it.\n    const channel = webchannelTransport.createWebChannel(url, request) as any;\n\n    // WebChannel supports sending the first message with the handshake - saving\n    // a network round trip. However, it will have to call send in the same\n    // JS event loop as open. In order to enforce this, we delay actually\n    // opening the WebChannel until send is called. Whether we have called\n    // open is tracked with this variable.\n    let opened = false;\n\n    // A flag to determine whether the stream was closed (by us or through an\n    // error/close event) to avoid delivering multiple close events or sending\n    // on a closed stream\n    let closed = false;\n\n    // tslint:disable-next-line:no-any\n    const streamBridge = new StreamBridge<any, any>({\n      sendFn: (msg: any) => {\n        if (!closed) {\n          if (!opened) {\n            log.debug(LOG_TAG, 'Opening WebChannel transport.');\n            channel.open();\n            opened = true;\n          }\n          log.debug(LOG_TAG, 'WebChannel sending:', msg);\n          channel.send(msg);\n        } else {\n          log.debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n        }\n      },\n      closeFn: () => channel.close()\n    });\n\n    // Closure events are guarded and exceptions are swallowed, so catch any\n    // exception and rethrow using a setTimeout so they become visible again.\n    // Note that eventually this function could go away if we are confident\n    // enough the code is exception free.\n    const unguardedEventListen = (\n      type: WebChannel.EventType,\n      fn: (param: any) => void\n    ) => {\n      // TODO(dimond): closure typing seems broken because WebChannel does\n      // not implement goog.events.Listenable\n      channel.listen(type, (param: any) => {\n        try {\n          fn(param);\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          }, 0);\n        }\n      });\n    };\n\n    unguardedEventListen(WebChannel.EventType.OPEN, () => {\n      if (!closed) {\n        log.debug(LOG_TAG, 'WebChannel transport opened.');\n      }\n    });\n\n    unguardedEventListen(WebChannel.EventType.CLOSE, () => {\n      if (!closed) {\n        closed = true;\n        log.debug(LOG_TAG, 'WebChannel transport closed');\n        streamBridge.callOnClose();\n      }\n    });\n\n    unguardedEventListen(WebChannel.EventType.ERROR, (err: any) => {\n      if (!closed) {\n        closed = true;\n        log.debug(LOG_TAG, 'WebChannel transport errored:', err);\n        streamBridge.callOnClose(\n          new FirestoreError(\n            Code.UNAVAILABLE,\n            'The operation could not be completed'\n          )\n        );\n      }\n    });\n\n    unguardedEventListen(WebChannel.EventType.MESSAGE, (msg: any) => {\n      if (!closed) {\n        // WebChannel delivers message events as array. If batching\n        // is not enabled (it's off by default) each message will be\n        // delivered alone, resulting in a single element array.\n        const msgData = msg.data[0];\n        assert(!!msgData, 'Got a webchannel message without data.');\n        // TODO(b/35143891): There is a bug in One Platform that caused errors\n        // (and only errors) to be wrapped in an extra array. To be forward\n        // compatible with the bug we need to check either condition. The latter\n        // can be removed once the fix has been rolled out.\n        const error = msgData.error || (msgData[0] && msgData[0].error);\n        if (error) {\n          log.debug(LOG_TAG, 'WebChannel received error:', error);\n          // error.status will be a string like 'OK' or 'NOT_FOUND'.\n          const status: string = error.status;\n          let code = mapCodeFromRpcStatus(status);\n          let message = error.message;\n          if (code === undefined) {\n            code = Code.INTERNAL;\n            message =\n              'Unknown error status: ' +\n              status +\n              ' with message ' +\n              error.message;\n          }\n          // Mark closed so no further events are propagated\n          closed = true;\n          streamBridge.callOnClose(new FirestoreError(code, message));\n          channel.close();\n        } else {\n          log.debug(LOG_TAG, 'WebChannel received:', msgData);\n          streamBridge.callOnMessage(msgData);\n        }\n      }\n    });\n\n    setTimeout(() => {\n      // Technically we could/should wait for the WebChannel opened event,\n      // but because we want to send the first message with the WebChannel\n      // handshake we pretend the channel opened here (asynchronously), and\n      // then delay the actual open until the first message is sent.\n      streamBridge.callOnOpen();\n    }, 0);\n    return streamBridge;\n  }\n\n  // visible for testing\n  makeUrl(rpcName: string): string {\n    const url = [this.baseUrl, '/', RPC_URL_VERSION];\n    url.push('/projects/');\n    url.push(this.databaseId.projectId);\n\n    url.push('/databases/');\n    url.push(this.databaseId.database);\n    url.push('/documents');\n\n    url.push(':');\n    url.push(rpcName);\n    return url.join('');\n  }\n}\n"]}