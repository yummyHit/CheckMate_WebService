{"version":3,"sources":["src/firestore/core/event_manager.ts","firestore/core/event_manager.js"],"names":["QueryListenersInfo","listeners","EventManager","syncEngine","queries","q","canonicalId","onlineState","Unknown","subscribe","onChange","bind","onError","prototype","listen","listener","query","firstListen","queryInfo","get","set","push","onOnlineStateChanged","viewSnap","onViewSnapshot","then","targetId","resolve","unlisten","lastListen","i","indexOf","splice","length","delete","viewSnaps","_i","viewSnaps_1","_a","_b","error","forEach","_","QueryListener","queryObserver","options","raisedInitialEvent","snap","docChanges","syncStateChanged","includeDocumentMetadataChanges","docChange","type","Metadata","docs","oldDocs","fromCache","hasPendingWrites","shouldRaiseInitialEvent","raiseInitialEvent","shouldRaiseEvent","next","maybeOnline","Failed","waitForSyncWhenOnline","isEmpty","hasPendingWritesChanged","includeQueryMetadataChanges","emptySet","getInitialViewChanges","result","doc","Added"],"mappings":"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","file":"event_manager.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from './query';\nimport { SyncEngine } from './sync_engine';\nimport { OnlineState, TargetId } from './types';\nimport { DocumentViewChange } from './view_snapshot';\nimport { ChangeType, ViewSnapshot } from './view_snapshot';\nimport { DocumentSet } from '../model/document_set';\nimport { assert } from '../util/assert';\nimport { EventHandler } from '../util/misc';\nimport * as obj from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nclass QueryListenersInfo {\n  public viewSnap: ViewSnapshot | null;\n  public targetId: TargetId;\n  public listeners: QueryListener[] = [];\n}\n\n/**\n * Interface for handling events from the EventManager.\n */\nexport interface Observer<T> {\n  next: EventHandler<T>;\n  error: EventHandler<Error>;\n}\n\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\nexport class EventManager {\n  private queries = new ObjectMap<Query, QueryListenersInfo>(q =>\n    q.canonicalId()\n  );\n\n  private onlineState: OnlineState = OnlineState.Unknown;\n\n  constructor(private syncEngine: SyncEngine) {\n    this.syncEngine.subscribe(\n      this.onChange.bind(this),\n      this.onError.bind(this)\n    );\n  }\n\n  listen(listener: QueryListener): Promise<TargetId> {\n    const query = listener.query;\n    let firstListen = false;\n\n    let queryInfo = this.queries.get(query);\n    if (!queryInfo) {\n      firstListen = true;\n      queryInfo = new QueryListenersInfo();\n      this.queries.set(query, queryInfo);\n    }\n    queryInfo.listeners.push(listener);\n\n    listener.onOnlineStateChanged(this.onlineState);\n\n    if (queryInfo.viewSnap) listener.onViewSnapshot(queryInfo.viewSnap);\n\n    if (firstListen) {\n      return this.syncEngine.listen(query).then(targetId => {\n        queryInfo!.targetId = targetId;\n        return targetId;\n      });\n    } else {\n      return Promise.resolve(queryInfo.targetId);\n    }\n  }\n\n  unlisten(listener: QueryListener): Promise<void> {\n    const query = listener.query;\n    let lastListen = false;\n\n    const queryInfo = this.queries.get(query);\n    if (queryInfo) {\n      const i = queryInfo.listeners.indexOf(listener);\n      if (i >= 0) {\n        queryInfo.listeners.splice(i, 1);\n        lastListen = queryInfo.listeners.length === 0;\n      }\n    }\n\n    if (lastListen) {\n      this.queries.delete(query);\n      return this.syncEngine.unlisten(query);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  onChange(viewSnaps: ViewSnapshot[]): void {\n    for (const viewSnap of viewSnaps) {\n      const query = viewSnap.query;\n      const queryInfo = this.queries.get(query);\n      if (queryInfo) {\n        for (const listener of queryInfo.listeners) {\n          listener.onViewSnapshot(viewSnap);\n        }\n        queryInfo.viewSnap = viewSnap;\n      }\n    }\n  }\n\n  onError(query: Query, error: Error): void {\n    const queryInfo = this.queries.get(query);\n    if (queryInfo) {\n      for (const listener of queryInfo.listeners) {\n        listener.onError(error);\n      }\n    }\n\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n    // after an error.\n    this.queries.delete(query);\n  }\n\n  onOnlineStateChanged(onlineState: OnlineState): void {\n    this.onlineState = onlineState;\n    this.queries.forEach((_, queryInfo) => {\n      for (const listener of queryInfo.listeners) {\n        listener.onOnlineStateChanged(onlineState);\n      }\n    });\n  }\n}\n\nexport interface ListenOptions {\n  /** Raise events when only metadata of documents changes */\n  readonly includeDocumentMetadataChanges?: boolean;\n\n  /** Raise events when only metadata of the query changes */\n  readonly includeQueryMetadataChanges?: boolean;\n\n  /**\n   * Wait for a sync with the server when online, but still raise events while\n   * offline.\n   */\n  readonly waitForSyncWhenOnline?: boolean;\n}\n\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nexport class QueryListener {\n  /**\n   * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n   * observer. This flag is set to true once we've actually raised an event.\n   */\n  private raisedInitialEvent = false;\n\n  private options: ListenOptions;\n\n  private snap: ViewSnapshot;\n\n  private onlineState: OnlineState = OnlineState.Unknown;\n\n  constructor(\n    readonly query: Query,\n    private queryObserver: Observer<ViewSnapshot>,\n    options?: ListenOptions\n  ) {\n    this.options = options || {};\n  }\n\n  onViewSnapshot(snap: ViewSnapshot): void {\n    assert(\n      snap.docChanges.length > 0 || snap.syncStateChanged,\n      'We got a new snapshot with no changes?'\n    );\n\n    if (!this.options.includeDocumentMetadataChanges) {\n      // Remove the metadata only changes.\n      const docChanges: DocumentViewChange[] = [];\n      for (const docChange of snap.docChanges) {\n        if (docChange.type !== ChangeType.Metadata) {\n          docChanges.push(docChange);\n        }\n      }\n      snap = {\n        query: snap.query,\n        docs: snap.docs,\n        oldDocs: snap.oldDocs,\n        docChanges,\n        fromCache: snap.fromCache,\n        hasPendingWrites: snap.hasPendingWrites,\n        syncStateChanged: snap.syncStateChanged\n      };\n    }\n\n    if (!this.raisedInitialEvent) {\n      if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n        this.raiseInitialEvent(snap);\n      }\n    } else if (this.shouldRaiseEvent(snap)) {\n      this.queryObserver.next(snap);\n    }\n\n    this.snap = snap;\n  }\n\n  onError(error: Error): void {\n    this.queryObserver.error(error);\n  }\n\n  onOnlineStateChanged(onlineState: OnlineState): void {\n    this.onlineState = onlineState;\n    if (\n      this.snap &&\n      !this.raisedInitialEvent &&\n      this.shouldRaiseInitialEvent(this.snap, onlineState)\n    ) {\n      this.raiseInitialEvent(this.snap);\n    }\n  }\n\n  private shouldRaiseInitialEvent(\n    snap: ViewSnapshot,\n    onlineState: OnlineState\n  ): boolean {\n    assert(\n      !this.raisedInitialEvent,\n      'Determining whether to raise first event but already had first event'\n    );\n\n    // Always raise the first event when we're synced\n    if (!snap.fromCache) {\n      return true;\n    }\n\n    // NOTE: We consider OnlineState.Unknown as online (it should become Failed\n    // or Online if we wait long enough).\n    const maybeOnline = onlineState !== OnlineState.Failed;\n    // Don't raise the event if we're online, aren't synced yet (checked\n    // above) and are waiting for a sync.\n    if (this.options.waitForSyncWhenOnline && maybeOnline) {\n      assert(\n        snap.fromCache,\n        'Waiting for sync, but snapshot is not from cache'\n      );\n      return false;\n    }\n\n    // Raise data from cache if we have any documents or we are offline\n    return !snap.docs.isEmpty() || onlineState === OnlineState.Failed;\n  }\n\n  private shouldRaiseEvent(snap: ViewSnapshot): boolean {\n    // We don't need to handle includeDocumentMetadataChanges here because\n    // the Metadata only changes have already been stripped out if needed.\n    // At this point the only changes we will see are the ones we should\n    // propagate.\n    if (snap.docChanges.length > 0) {\n      return true;\n    }\n\n    const hasPendingWritesChanged =\n      this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n    if (snap.syncStateChanged || hasPendingWritesChanged) {\n      return this.options.includeQueryMetadataChanges === true;\n    }\n\n    // Generally we should have hit one of the cases above, but it's possible\n    // to get here if there were only metadata docChanges and they got\n    // stripped out.\n    return false;\n  }\n\n  private raiseInitialEvent(snap: ViewSnapshot): void {\n    assert(\n      !this.raisedInitialEvent,\n      'Trying to raise initial events for second time'\n    );\n    snap = {\n      query: snap.query,\n      docs: snap.docs,\n      oldDocs: DocumentSet.emptySet(snap.docs),\n      docChanges: QueryListener.getInitialViewChanges(snap),\n      fromCache: snap.fromCache,\n      hasPendingWrites: snap.hasPendingWrites,\n      syncStateChanged: true\n    };\n    this.raisedInitialEvent = true;\n    this.queryObserver.next(snap);\n  }\n\n  /** Returns changes as if all documents in the snap were added. */\n  private static getInitialViewChanges(\n    snap: ViewSnapshot\n  ): DocumentViewChange[] {\n    const result: DocumentViewChange[] = [];\n    snap.docs.forEach(doc => {\n      result.push({ type: ChangeType.Added, doc });\n    });\n    return result;\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OnlineState } from './types';\nimport { ChangeType } from './view_snapshot';\nimport { DocumentSet } from '../model/document_set';\nimport { assert } from '../util/assert';\nimport { ObjectMap } from '../util/obj_map';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nvar QueryListenersInfo = /** @class */ (function () {\n    function QueryListenersInfo() {\n        this.listeners = [];\n    }\n    return QueryListenersInfo;\n}());\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\nvar EventManager = /** @class */ (function () {\n    function EventManager(syncEngine) {\n        this.syncEngine = syncEngine;\n        this.queries = new ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.onlineState = OnlineState.Unknown;\n        this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));\n    }\n    EventManager.prototype.listen = function (listener) {\n        var query = listener.query;\n        var firstListen = false;\n        var queryInfo = this.queries.get(query);\n        if (!queryInfo) {\n            firstListen = true;\n            queryInfo = new QueryListenersInfo();\n            this.queries.set(query, queryInfo);\n        }\n        queryInfo.listeners.push(listener);\n        listener.onOnlineStateChanged(this.onlineState);\n        if (queryInfo.viewSnap)\n            listener.onViewSnapshot(queryInfo.viewSnap);\n        if (firstListen) {\n            return this.syncEngine.listen(query).then(function (targetId) {\n                queryInfo.targetId = targetId;\n                return targetId;\n            });\n        }\n        else {\n            return Promise.resolve(queryInfo.targetId);\n        }\n    };\n    EventManager.prototype.unlisten = function (listener) {\n        var query = listener.query;\n        var lastListen = false;\n        var queryInfo = this.queries.get(query);\n        if (queryInfo) {\n            var i = queryInfo.listeners.indexOf(listener);\n            if (i >= 0) {\n                queryInfo.listeners.splice(i, 1);\n                lastListen = queryInfo.listeners.length === 0;\n            }\n        }\n        if (lastListen) {\n            this.queries.delete(query);\n            return this.syncEngine.unlisten(query);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    EventManager.prototype.onChange = function (viewSnaps) {\n        for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {\n            var viewSnap = viewSnaps_1[_i];\n            var query = viewSnap.query;\n            var queryInfo = this.queries.get(query);\n            if (queryInfo) {\n                for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {\n                    var listener = _b[_a];\n                    listener.onViewSnapshot(viewSnap);\n                }\n                queryInfo.viewSnap = viewSnap;\n            }\n        }\n    };\n    EventManager.prototype.onError = function (query, error) {\n        var queryInfo = this.queries.get(query);\n        if (queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.onError(error);\n            }\n        }\n        // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n        // after an error.\n        this.queries.delete(query);\n    };\n    EventManager.prototype.onOnlineStateChanged = function (onlineState) {\n        this.onlineState = onlineState;\n        this.queries.forEach(function (_, queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.onOnlineStateChanged(onlineState);\n            }\n        });\n    };\n    return EventManager;\n}());\nexport { EventManager };\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nvar QueryListener = /** @class */ (function () {\n    function QueryListener(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.onlineState = OnlineState.Unknown;\n        this.options = options || {};\n    }\n    QueryListener.prototype.onViewSnapshot = function (snap) {\n        assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');\n        if (!this.options.includeDocumentMetadataChanges) {\n            // Remove the metadata only changes.\n            var docChanges = [];\n            for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {\n                var docChange = _a[_i];\n                if (docChange.type !== ChangeType.Metadata) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = {\n                query: snap.query,\n                docs: snap.docs,\n                oldDocs: snap.oldDocs,\n                docChanges: docChanges,\n                fromCache: snap.fromCache,\n                hasPendingWrites: snap.hasPendingWrites,\n                syncStateChanged: snap.syncStateChanged\n            };\n        }\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n        }\n        this.snap = snap;\n    };\n    QueryListener.prototype.onError = function (error) {\n        this.queryObserver.error(error);\n    };\n    QueryListener.prototype.onOnlineStateChanged = function (onlineState) {\n        this.onlineState = onlineState;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n        }\n    };\n    QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) {\n        assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event');\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Failed\n        // or Online if we wait long enough).\n        var maybeOnline = onlineState !== OnlineState.Failed;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');\n            return false;\n        }\n        // Raise data from cache if we have any documents or we are offline\n        return !snap.docs.isEmpty() || onlineState === OnlineState.Failed;\n    };\n    QueryListener.prototype.shouldRaiseEvent = function (snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeQueryMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    };\n    QueryListener.prototype.raiseInitialEvent = function (snap) {\n        assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');\n        snap = {\n            query: snap.query,\n            docs: snap.docs,\n            oldDocs: DocumentSet.emptySet(snap.docs),\n            docChanges: QueryListener.getInitialViewChanges(snap),\n            fromCache: snap.fromCache,\n            hasPendingWrites: snap.hasPendingWrites,\n            syncStateChanged: true\n        };\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    };\n    /** Returns changes as if all documents in the snap were added. */\n    QueryListener.getInitialViewChanges = function (snap) {\n        var result = [];\n        snap.docs.forEach(function (doc) {\n            result.push({ type: ChangeType.Added, doc: doc });\n        });\n        return result;\n    };\n    return QueryListener;\n}());\nexport { QueryListener };\n\n\n"]}