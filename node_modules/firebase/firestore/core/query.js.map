{"version":3,"sources":["src/firestore/core/query.ts","firestore/core/query.js"],"names":["fieldFilter","Query","path","explicitOrderBy","filters","limit","startAt","endAt","memoizedCanonicalId","memoizedOrderBy","assertValidBound","atPath","Object","defineProperty","prototype","get","inequalityField","getInequalityFilterField","firstOrderByField","getFirstOrderByField","isKeyField","KEY_ORDERING_ASC","OrderBy","equals","foundKeyOrdering","_i","_a","length","orderBy","push","field","lastDirection","dir","Direction","ASCENDING","KEY_ORDERING_DESC","enumerable","configurable","addFilter","filter","RelationFilter","isInequality","isDocumentKey","newFilters","concat","slice","addOrderBy","newOrderBy","withLimit","withStartAt","bound","withEndAt","canonicalId","canonicalString","_b","_c","toString","str","join","other","i","docComparator","d1","d2","comparedOnKeyField","comp","compare","matches","doc","matchesAncestor","matchesOrderBy","matchesFilters","matchesBounds","hasLimit","isDocumentQuery","docPath","key","isPrefixOf","undefined","sortsBeforeDocument","position","RelationOp","name","fromString","op","LESS_THAN","LESS_THAN_OR_EQUAL","EQUAL","GREATER_THAN_OR_EQUAL","GREATER_THAN","value","refValue","comparison","comparator","matchesComparison","val","matchesValue","typeOrder","compareTo","NullFilter","NanFilter","isNaN","INSTANCE","INVALID_ARGUMENT","NAN","DESCENDING","Bound","before","component","orderByComponent","docValue","thisPosition","otherPosition","isKeyOrderBy","compareByKey","compareByField","keyField"],"mappings":"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","file":"query.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport {\n  DoubleValue,\n  FieldValue,\n  NullValue,\n  RefValue\n} from '../model/field_value';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isNullOrUndefined } from '../util/types';\n\nexport class Query {\n  static atPath(path: ResourcePath): Query {\n    return new Query(path);\n  }\n\n  private memoizedCanonicalId: string | null = null;\n  private memoizedOrderBy: OrderBy[] | null = null;\n\n  constructor(\n    readonly path: ResourcePath,\n    readonly explicitOrderBy: OrderBy[] = [],\n    readonly filters: Filter[] = [],\n    readonly limit: number | null = null,\n    readonly startAt: Bound | null = null,\n    readonly endAt: Bound | null = null\n  ) {\n    if (this.startAt) {\n      this.assertValidBound(this.startAt);\n    }\n    if (this.endAt) {\n      this.assertValidBound(this.endAt);\n    }\n  }\n\n  get orderBy(): OrderBy[] {\n    if (this.memoizedOrderBy === null) {\n      const inequalityField = this.getInequalityFilterField();\n      const firstOrderByField = this.getFirstOrderByField();\n      if (inequalityField !== null && firstOrderByField === null) {\n        // In order to implicitly add key ordering, we must also add the\n        // inequality filter field for it to be a valid query.\n        // Note that the default inequality field and key ordering is ascending.\n        if (inequalityField.isKeyField()) {\n          this.memoizedOrderBy = [KEY_ORDERING_ASC];\n        } else {\n          this.memoizedOrderBy = [\n            new OrderBy(inequalityField),\n            KEY_ORDERING_ASC\n          ];\n        }\n      } else {\n        assert(\n          inequalityField === null ||\n            (firstOrderByField !== null &&\n              inequalityField.equals(firstOrderByField)),\n          'First orderBy should match inequality field.'\n        );\n        this.memoizedOrderBy = [];\n        let foundKeyOrdering = false;\n        for (const orderBy of this.explicitOrderBy) {\n          this.memoizedOrderBy.push(orderBy);\n          if (orderBy.field.isKeyField()) {\n            foundKeyOrdering = true;\n          }\n        }\n        if (!foundKeyOrdering) {\n          // The order of the implicit key ordering always matches the last\n          // explicit order by\n          const lastDirection =\n            this.explicitOrderBy.length > 0\n              ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir\n              : Direction.ASCENDING;\n          this.memoizedOrderBy.push(\n            lastDirection === Direction.ASCENDING\n              ? KEY_ORDERING_ASC\n              : KEY_ORDERING_DESC\n          );\n        }\n      }\n    }\n    return this.memoizedOrderBy;\n  }\n\n  addFilter(filter: Filter): Query {\n    assert(\n      this.getInequalityFilterField() == null ||\n        !(filter instanceof RelationFilter) ||\n        !filter.isInequality() ||\n        filter.field.equals(this.getInequalityFilterField()!),\n      'Query must only have one inequality field.'\n    );\n\n    assert(\n      !DocumentKey.isDocumentKey(this.path),\n      'No filtering allowed for document query'\n    );\n    const newFilters = this.filters.concat([filter]);\n    return new Query(\n      this.path,\n      this.explicitOrderBy.slice(),\n      newFilters,\n      this.limit,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  addOrderBy(orderBy: OrderBy): Query {\n    assert(\n      !DocumentKey.isDocumentKey(this.path),\n      'No ordering allowed for document query'\n    );\n    assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');\n    // TODO(dimond): validate that orderBy does not list the same key twice.\n    const newOrderBy = this.explicitOrderBy.concat([orderBy]);\n    return new Query(\n      this.path,\n      newOrderBy,\n      this.filters.slice(),\n      this.limit,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  withLimit(limit: number | null): Query {\n    return new Query(\n      this.path,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      limit,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  withStartAt(bound: Bound): Query {\n    return new Query(\n      this.path,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      this.limit,\n      bound,\n      this.endAt\n    );\n  }\n\n  withEndAt(bound: Bound): Query {\n    return new Query(\n      this.path,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      this.limit,\n      this.startAt,\n      bound\n    );\n  }\n\n  // TODO(b/29183165): This is used to get a unique string from a query to, for\n  // example, use as a dictionary key, but the implementation is subject to\n  // collisions. Make it collision-free.\n  canonicalId(): string {\n    if (this.memoizedCanonicalId === null) {\n      let canonicalId = this.path.canonicalString();\n      canonicalId += '|f:';\n      for (const filter of this.filters) {\n        canonicalId += filter.canonicalId();\n        canonicalId += ',';\n      }\n      canonicalId += '|ob:';\n      // TODO(dimond): make this collision resistant\n      for (const orderBy of this.orderBy) {\n        canonicalId += orderBy.canonicalId();\n        canonicalId += ',';\n      }\n      if (!isNullOrUndefined(this.limit)) {\n        canonicalId += '|l:';\n        canonicalId += this.limit!;\n      }\n      if (this.startAt) {\n        canonicalId += '|lb:';\n        canonicalId += this.startAt.canonicalId();\n      }\n      if (this.endAt) {\n        canonicalId += '|ub:';\n        canonicalId += this.endAt.canonicalId();\n      }\n      this.memoizedCanonicalId = canonicalId;\n    }\n    return this.memoizedCanonicalId;\n  }\n\n  toString(): string {\n    let str = 'Query(' + this.path.canonicalString();\n    if (this.filters.length > 0) {\n      str += `, filters: [${this.filters.join(', ')}]`;\n    }\n    if (!isNullOrUndefined(this.limit)) {\n      str += ', limit: ' + this.limit;\n    }\n    if (this.explicitOrderBy.length > 0) {\n      str += `, orderBy: [${this.explicitOrderBy.join(', ')}]`;\n    }\n    if (this.startAt) {\n      str += ', startAt: ' + this.startAt.canonicalId();\n    }\n    if (this.endAt) {\n      str += ', endAt: ' + this.endAt.canonicalId();\n    }\n\n    return str + ')';\n  }\n\n  equals(other: Query): boolean {\n    if (this.limit !== other.limit) {\n      return false;\n    }\n\n    if (this.orderBy.length !== other.orderBy.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.orderBy.length; i++) {\n      if (!this.orderBy[i].equals(other.orderBy[i])) {\n        return false;\n      }\n    }\n\n    if (this.filters.length !== other.filters.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.filters.length; i++) {\n      if (!this.filters[i].equals(other.filters[i])) {\n        return false;\n      }\n    }\n\n    if (!this.path.equals(other.path)) {\n      return false;\n    }\n\n    if (\n      this.startAt !== null\n        ? !this.startAt.equals(other.startAt)\n        : other.startAt !== null\n    ) {\n      return false;\n    }\n\n    return this.endAt !== null\n      ? this.endAt.equals(other.endAt)\n      : other.endAt === null;\n  }\n\n  docComparator(d1: Document, d2: Document): number {\n    let comparedOnKeyField = false;\n    for (const orderBy of this.orderBy) {\n      const comp = orderBy.compare(d1, d2);\n      if (comp !== 0) return comp;\n      comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n    }\n    // Assert that we actually compared by key\n    assert(\n      comparedOnKeyField,\n      \"orderBy used that doesn't compare on key field\"\n    );\n    return 0;\n  }\n\n  matches(doc: Document): boolean {\n    return (\n      this.matchesAncestor(doc) &&\n      this.matchesOrderBy(doc) &&\n      this.matchesFilters(doc) &&\n      this.matchesBounds(doc)\n    );\n  }\n\n  hasLimit(): boolean {\n    return !isNullOrUndefined(this.limit);\n  }\n\n  getFirstOrderByField(): FieldPath | null {\n    return this.explicitOrderBy.length > 0\n      ? this.explicitOrderBy[0].field\n      : null;\n  }\n\n  getInequalityFilterField(): FieldPath | null {\n    for (const filter of this.filters) {\n      if (filter instanceof RelationFilter && filter.isInequality()) {\n        return filter.field;\n      }\n    }\n    return null;\n  }\n\n  isDocumentQuery(): boolean {\n    return DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;\n  }\n\n  private matchesAncestor(doc: Document): boolean {\n    const docPath = doc.key.path;\n    if (DocumentKey.isDocumentKey(this.path)) {\n      // exact match for document queries\n      return this.path.equals(docPath);\n    } else {\n      // shallow ancestor queries by default\n      return (\n        this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1\n      );\n    }\n  }\n\n  /**\n   * A document must have a value for every ordering clause in order to show up\n   * in the results.\n   */\n  private matchesOrderBy(doc: Document): boolean {\n    for (const orderBy of this.explicitOrderBy) {\n      // order by key always matches\n      if (\n        !orderBy.field.isKeyField() &&\n        doc.field(orderBy.field) === undefined\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private matchesFilters(doc: Document): boolean {\n    for (const filter of this.filters) {\n      if (!filter.matches(doc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Makes sure a document is within the bounds, if provided.\n   */\n  private matchesBounds(doc: Document): boolean {\n    if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n      return false;\n    }\n    if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n      return false;\n    }\n    return true;\n  }\n\n  private assertValidBound(bound: Bound): void {\n    assert(\n      bound.position.length <= this.orderBy.length,\n      'Bound is longer than orderBy'\n    );\n  }\n}\n\nexport interface Filter {\n  matches(doc: Document): boolean;\n  canonicalId(): string;\n  equals(filter: Filter): boolean;\n}\n\nexport class RelationOp {\n  static LESS_THAN = new RelationOp('<');\n  static LESS_THAN_OR_EQUAL = new RelationOp('<=');\n  static EQUAL = new RelationOp('==');\n  static GREATER_THAN = new RelationOp('>');\n  static GREATER_THAN_OR_EQUAL = new RelationOp('>=');\n\n  static fromString(op: string): RelationOp {\n    switch (op) {\n      case '<':\n        return RelationOp.LESS_THAN;\n      case '<=':\n        return RelationOp.LESS_THAN_OR_EQUAL;\n      case '==':\n        return RelationOp.EQUAL;\n      case '>=':\n        return RelationOp.GREATER_THAN_OR_EQUAL;\n      case '>':\n        return RelationOp.GREATER_THAN;\n      default:\n        return fail('Unknown relation: ' + op);\n    }\n  }\n\n  constructor(public name: string) {}\n\n  toString(): string {\n    return this.name;\n  }\n\n  equals(other: RelationOp): boolean {\n    return this.name === other.name;\n  }\n}\n\nexport class RelationFilter implements Filter {\n  constructor(\n    public field: FieldPath,\n    public op: RelationOp,\n    public value: FieldValue\n  ) {}\n\n  matches(doc: Document): boolean {\n    if (this.field.isKeyField()) {\n      assert(\n        this.value instanceof RefValue,\n        'Comparing on key, but filter value not a RefValue'\n      );\n      const refValue = this.value as RefValue;\n      const comparison = DocumentKey.comparator(doc.key, refValue.key);\n      return this.matchesComparison(comparison);\n    } else {\n      const val = doc.field(this.field);\n      return val !== undefined && this.matchesValue(val);\n    }\n  }\n\n  private matchesValue(value: FieldValue): boolean {\n    // Only compare types with matching backend order (such as double and int).\n    if (this.value.typeOrder !== value.typeOrder) {\n      return false;\n    }\n    return this.matchesComparison(value.compareTo(this.value));\n  }\n\n  private matchesComparison(comparison: number) {\n    switch (this.op) {\n      case RelationOp.LESS_THAN:\n        return comparison < 0;\n      case RelationOp.LESS_THAN_OR_EQUAL:\n        return comparison <= 0;\n      case RelationOp.EQUAL:\n        return comparison === 0;\n      case RelationOp.GREATER_THAN:\n        return comparison > 0;\n      case RelationOp.GREATER_THAN_OR_EQUAL:\n        return comparison >= 0;\n      default:\n        return fail('Unknown relation op' + this.op);\n    }\n  }\n\n  isInequality(): boolean {\n    return this.op !== RelationOp.EQUAL;\n  }\n\n  canonicalId(): string {\n    // TODO(b/29183165): Technically, this won't be unique if two values have\n    // the same description, such as the int 3 and the string \"3\". So we should\n    // add the types in here somehow, too.\n    return (\n      this.field.canonicalString() + this.op.toString() + this.value.toString()\n    );\n  }\n\n  equals(other: Filter): boolean {\n    if (other instanceof RelationFilter) {\n      return (\n        this.op.equals(other.op) &&\n        this.field.equals(other.field) &&\n        this.value.equals(other.value)\n      );\n    } else {\n      return false;\n    }\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} ${this.op} ${this.value.value()}`;\n  }\n}\n\n/**\n * Filter that matches 'null' values.\n */\nexport class NullFilter implements Filter {\n  constructor(public field: FieldPath) {}\n\n  matches(doc: Document): boolean {\n    const val = doc.field(this.field);\n    return val !== undefined && val.value() === null;\n  }\n\n  canonicalId(): string {\n    return this.field.canonicalString() + ' IS null';\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} IS null`;\n  }\n\n  equals(other: Filter): boolean {\n    if (other instanceof NullFilter) {\n      return this.field.equals(other.field);\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Filter that matches 'NaN' values.\n */\nexport class NanFilter implements Filter {\n  constructor(public field: FieldPath) {}\n\n  matches(doc: Document): boolean {\n    const val = doc.field(this.field).value();\n    return typeof val === 'number' && isNaN(val);\n  }\n\n  canonicalId(): string {\n    return this.field.canonicalString() + ' IS NaN';\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} IS NaN`;\n  }\n\n  equals(other: Filter): boolean {\n    if (other instanceof NanFilter) {\n      return this.field.equals(other.field);\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Creates a filter based on the provided arguments.\n */\nexport function fieldFilter(\n  field: FieldPath,\n  op: RelationOp,\n  value: FieldValue\n) {\n  if (value.equals(NullValue.INSTANCE)) {\n    if (op !== RelationOp.EQUAL) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You can only perform equals ' + 'comparisons on null.'\n      );\n    }\n    return new NullFilter(field);\n  } else if (value.equals(DoubleValue.NAN)) {\n    if (op !== RelationOp.EQUAL) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You can only perform equals ' + 'comparisons on NaN.'\n      );\n    }\n    return new NanFilter(field);\n  } else {\n    return new RelationFilter(field, op, value);\n  }\n}\n\n/**\n * The direction of sorting in an order by.\n */\nexport class Direction {\n  static ASCENDING = new Direction('asc');\n  static DESCENDING = new Direction('desc');\n\n  private constructor(public name: string) {}\n\n  toString(): string {\n    return this.name;\n  }\n}\n\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nexport class Bound {\n  constructor(readonly position: FieldValue[], readonly before: boolean) {}\n\n  canonicalId(): string {\n    // TODO(b/29183165): Make this collision robust.\n    let canonicalId = this.before ? 'b:' : 'a:';\n    for (const component of this.position) {\n      canonicalId += component.toString();\n    }\n    return canonicalId;\n  }\n\n  /**\n   * Returns true if a document sorts before a bound using the provided sort\n   * order.\n   */\n  sortsBeforeDocument(orderBy: OrderBy[], doc: Document): boolean {\n    assert(\n      this.position.length <= orderBy.length,\n      \"Bound has more components than query's orderBy\"\n    );\n    let comparison = 0;\n    for (let i = 0; i < this.position.length; i++) {\n      const orderByComponent = orderBy[i];\n      const component = this.position[i];\n      if (orderByComponent.field.isKeyField()) {\n        assert(\n          component instanceof RefValue,\n          'Bound has a non-key value where the key path is being used.'\n        );\n        comparison = DocumentKey.comparator(\n          (component as RefValue).key,\n          doc.key\n        );\n      } else {\n        const docValue = doc.field(orderByComponent.field);\n        assert(\n          docValue !== undefined,\n          'Field should exist since document matched the orderBy already.'\n        );\n        comparison = component.compareTo(docValue);\n      }\n      if (orderByComponent.dir === Direction.DESCENDING) {\n        comparison = comparison * -1;\n      }\n      if (comparison !== 0) {\n        break;\n      }\n    }\n    return this.before ? comparison <= 0 : comparison < 0;\n  }\n\n  equals(other: Bound | null): boolean {\n    if (other === null) {\n      return false;\n    }\n    if (\n      this.before !== other.before ||\n      this.position.length !== other.position.length\n    ) {\n      return false;\n    }\n    for (let i = 0; i < this.position.length; i++) {\n      const thisPosition = this.position[i];\n      const otherPosition = other.position[i];\n      return thisPosition.equals(otherPosition);\n    }\n    return true;\n  }\n}\n\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nexport class OrderBy {\n  readonly dir: Direction;\n  private readonly isKeyOrderBy: boolean;\n\n  constructor(public readonly field: FieldPath, dir?: Direction) {\n    if (dir === undefined) {\n      dir = Direction.ASCENDING;\n    }\n    this.dir = dir;\n    this.isKeyOrderBy = field.isKeyField();\n  }\n\n  compare(d1: Document, d2: Document): number {\n    const comparison = this.isKeyOrderBy\n      ? Document.compareByKey(d1, d2)\n      : Document.compareByField(this.field, d1, d2);\n    switch (this.dir) {\n      case Direction.ASCENDING:\n        return comparison;\n      case Direction.DESCENDING:\n        return -1 * comparison;\n      default:\n        return fail('Unknown direction: ' + this.dir);\n    }\n  }\n\n  canonicalId(): string {\n    // TODO(b/29183165): Make this collision robust.\n    return this.field.canonicalString() + this.dir.toString();\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} (${this.dir})`;\n  }\n\n  equals(other: OrderBy): boolean {\n    return this.dir === other.dir && this.field.equals(other.field);\n  }\n}\n\nconst KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);\nconst KEY_ORDERING_DESC = new OrderBy(\n  FieldPath.keyField(),\n  Direction.DESCENDING\n);\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DoubleValue, NullValue, RefValue } from '../model/field_value';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isNullOrUndefined } from '../util/types';\nvar Query = /** @class */ (function () {\n    function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {\n        if (explicitOrderBy === void 0) { explicitOrderBy = []; }\n        if (filters === void 0) { filters = []; }\n        if (limit === void 0) { limit = null; }\n        if (startAt === void 0) { startAt = null; }\n        if (endAt === void 0) { endAt = null; }\n        this.path = path;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n        this.memoizedOrderBy = null;\n        if (this.startAt) {\n            this.assertValidBound(this.startAt);\n        }\n        if (this.endAt) {\n            this.assertValidBound(this.endAt);\n        }\n    }\n    Query.atPath = function (path) {\n        return new Query(path);\n    };\n    Object.defineProperty(Query.prototype, \"orderBy\", {\n        get: function () {\n            if (this.memoizedOrderBy === null) {\n                var inequalityField = this.getInequalityFilterField();\n                var firstOrderByField = this.getFirstOrderByField();\n                if (inequalityField !== null && firstOrderByField === null) {\n                    // In order to implicitly add key ordering, we must also add the\n                    // inequality filter field for it to be a valid query.\n                    // Note that the default inequality field and key ordering is ascending.\n                    if (inequalityField.isKeyField()) {\n                        this.memoizedOrderBy = [KEY_ORDERING_ASC];\n                    }\n                    else {\n                        this.memoizedOrderBy = [\n                            new OrderBy(inequalityField),\n                            KEY_ORDERING_ASC\n                        ];\n                    }\n                }\n                else {\n                    assert(inequalityField === null ||\n                        (firstOrderByField !== null &&\n                            inequalityField.equals(firstOrderByField)), 'First orderBy should match inequality field.');\n                    this.memoizedOrderBy = [];\n                    var foundKeyOrdering = false;\n                    for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n                        var orderBy = _a[_i];\n                        this.memoizedOrderBy.push(orderBy);\n                        if (orderBy.field.isKeyField()) {\n                            foundKeyOrdering = true;\n                        }\n                    }\n                    if (!foundKeyOrdering) {\n                        // The order of the implicit key ordering always matches the last\n                        // explicit order by\n                        var lastDirection = this.explicitOrderBy.length > 0\n                            ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir\n                            : Direction.ASCENDING;\n                        this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING\n                            ? KEY_ORDERING_ASC\n                            : KEY_ORDERING_DESC);\n                    }\n                }\n            }\n            return this.memoizedOrderBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Query.prototype.addFilter = function (filter) {\n        assert(this.getInequalityFilterField() == null ||\n            !(filter instanceof RelationFilter) ||\n            !filter.isInequality() ||\n            filter.field.equals(this.getInequalityFilterField()), 'Query must only have one inequality field.');\n        assert(!DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');\n        var newFilters = this.filters.concat([filter]);\n        return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.addOrderBy = function (orderBy) {\n        assert(!DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');\n        assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');\n        // TODO(dimond): validate that orderBy does not list the same key twice.\n        var newOrderBy = this.explicitOrderBy.concat([orderBy]);\n        return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withLimit = function (limit) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withStartAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);\n    };\n    Query.prototype.withEndAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);\n    };\n    // TODO(b/29183165): This is used to get a unique string from a query to, for\n    // example, use as a dictionary key, but the implementation is subject to\n    // collisions. Make it collision-free.\n    Query.prototype.canonicalId = function () {\n        if (this.memoizedCanonicalId === null) {\n            var canonicalId = this.path.canonicalString();\n            canonicalId += '|f:';\n            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n                var filter = _a[_i];\n                canonicalId += filter.canonicalId();\n                canonicalId += ',';\n            }\n            canonicalId += '|ob:';\n            // TODO(dimond): make this collision resistant\n            for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {\n                var orderBy = _c[_b];\n                canonicalId += orderBy.canonicalId();\n                canonicalId += ',';\n            }\n            if (!isNullOrUndefined(this.limit)) {\n                canonicalId += '|l:';\n                canonicalId += this.limit;\n            }\n            if (this.startAt) {\n                canonicalId += '|lb:';\n                canonicalId += this.startAt.canonicalId();\n            }\n            if (this.endAt) {\n                canonicalId += '|ub:';\n                canonicalId += this.endAt.canonicalId();\n            }\n            this.memoizedCanonicalId = canonicalId;\n        }\n        return this.memoizedCanonicalId;\n    };\n    Query.prototype.toString = function () {\n        var str = 'Query(' + this.path.canonicalString();\n        if (this.filters.length > 0) {\n            str += \", filters: [\" + this.filters.join(', ') + \"]\";\n        }\n        if (!isNullOrUndefined(this.limit)) {\n            str += ', limit: ' + this.limit;\n        }\n        if (this.explicitOrderBy.length > 0) {\n            str += \", orderBy: [\" + this.explicitOrderBy.join(', ') + \"]\";\n        }\n        if (this.startAt) {\n            str += ', startAt: ' + this.startAt.canonicalId();\n        }\n        if (this.endAt) {\n            str += ', endAt: ' + this.endAt.canonicalId();\n        }\n        return str + ')';\n    };\n    Query.prototype.equals = function (other) {\n        if (this.limit !== other.limit) {\n            return false;\n        }\n        if (this.orderBy.length !== other.orderBy.length) {\n            return false;\n        }\n        for (var i = 0; i < this.orderBy.length; i++) {\n            if (!this.orderBy[i].equals(other.orderBy[i])) {\n                return false;\n            }\n        }\n        if (this.filters.length !== other.filters.length) {\n            return false;\n        }\n        for (var i = 0; i < this.filters.length; i++) {\n            if (!this.filters[i].equals(other.filters[i])) {\n                return false;\n            }\n        }\n        if (!this.path.equals(other.path)) {\n            return false;\n        }\n        if (this.startAt !== null\n            ? !this.startAt.equals(other.startAt)\n            : other.startAt !== null) {\n            return false;\n        }\n        return this.endAt !== null\n            ? this.endAt.equals(other.endAt)\n            : other.endAt === null;\n    };\n    Query.prototype.docComparator = function (d1, d2) {\n        var comparedOnKeyField = false;\n        for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            var comp = orderBy.compare(d1, d2);\n            if (comp !== 0)\n                return comp;\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        // Assert that we actually compared by key\n        assert(comparedOnKeyField, \"orderBy used that doesn't compare on key field\");\n        return 0;\n    };\n    Query.prototype.matches = function (doc) {\n        return (this.matchesAncestor(doc) &&\n            this.matchesOrderBy(doc) &&\n            this.matchesFilters(doc) &&\n            this.matchesBounds(doc));\n    };\n    Query.prototype.hasLimit = function () {\n        return !isNullOrUndefined(this.limit);\n    };\n    Query.prototype.getFirstOrderByField = function () {\n        return this.explicitOrderBy.length > 0\n            ? this.explicitOrderBy[0].field\n            : null;\n    };\n    Query.prototype.getInequalityFilterField = function () {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (filter instanceof RelationFilter && filter.isInequality()) {\n                return filter.field;\n            }\n        }\n        return null;\n    };\n    Query.prototype.isDocumentQuery = function () {\n        return DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;\n    };\n    Query.prototype.matchesAncestor = function (doc) {\n        var docPath = doc.key.path;\n        if (DocumentKey.isDocumentKey(this.path)) {\n            // exact match for document queries\n            return this.path.equals(docPath);\n        }\n        else {\n            // shallow ancestor queries by default\n            return (this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1);\n        }\n    };\n    /**\n     * A document must have a value for every ordering clause in order to show up\n     * in the results.\n     */\n    Query.prototype.matchesOrderBy = function (doc) {\n        for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            // order by key always matches\n            if (!orderBy.field.isKeyField() &&\n                doc.field(orderBy.field) === undefined) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Query.prototype.matchesFilters = function (doc) {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (!filter.matches(doc)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Makes sure a document is within the bounds, if provided.\n     */\n    Query.prototype.matchesBounds = function (doc) {\n        if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        return true;\n    };\n    Query.prototype.assertValidBound = function (bound) {\n        assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');\n    };\n    return Query;\n}());\nexport { Query };\nvar RelationOp = /** @class */ (function () {\n    function RelationOp(name) {\n        this.name = name;\n    }\n    RelationOp.fromString = function (op) {\n        switch (op) {\n            case '<':\n                return RelationOp.LESS_THAN;\n            case '<=':\n                return RelationOp.LESS_THAN_OR_EQUAL;\n            case '==':\n                return RelationOp.EQUAL;\n            case '>=':\n                return RelationOp.GREATER_THAN_OR_EQUAL;\n            case '>':\n                return RelationOp.GREATER_THAN;\n            default:\n                return fail('Unknown relation: ' + op);\n        }\n    };\n    RelationOp.prototype.toString = function () {\n        return this.name;\n    };\n    RelationOp.prototype.equals = function (other) {\n        return this.name === other.name;\n    };\n    RelationOp.LESS_THAN = new RelationOp('<');\n    RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');\n    RelationOp.EQUAL = new RelationOp('==');\n    RelationOp.GREATER_THAN = new RelationOp('>');\n    RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');\n    return RelationOp;\n}());\nexport { RelationOp };\nvar RelationFilter = /** @class */ (function () {\n    function RelationFilter(field, op, value) {\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    RelationFilter.prototype.matches = function (doc) {\n        if (this.field.isKeyField()) {\n            assert(this.value instanceof RefValue, 'Comparing on key, but filter value not a RefValue');\n            var refValue = this.value;\n            var comparison = DocumentKey.comparator(doc.key, refValue.key);\n            return this.matchesComparison(comparison);\n        }\n        else {\n            var val = doc.field(this.field);\n            return val !== undefined && this.matchesValue(val);\n        }\n    };\n    RelationFilter.prototype.matchesValue = function (value) {\n        // Only compare types with matching backend order (such as double and int).\n        if (this.value.typeOrder !== value.typeOrder) {\n            return false;\n        }\n        return this.matchesComparison(value.compareTo(this.value));\n    };\n    RelationFilter.prototype.matchesComparison = function (comparison) {\n        switch (this.op) {\n            case RelationOp.LESS_THAN:\n                return comparison < 0;\n            case RelationOp.LESS_THAN_OR_EQUAL:\n                return comparison <= 0;\n            case RelationOp.EQUAL:\n                return comparison === 0;\n            case RelationOp.GREATER_THAN:\n                return comparison > 0;\n            case RelationOp.GREATER_THAN_OR_EQUAL:\n                return comparison >= 0;\n            default:\n                return fail('Unknown relation op' + this.op);\n        }\n    };\n    RelationFilter.prototype.isInequality = function () {\n        return this.op !== RelationOp.EQUAL;\n    };\n    RelationFilter.prototype.canonicalId = function () {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (this.field.canonicalString() + this.op.toString() + this.value.toString());\n    };\n    RelationFilter.prototype.equals = function (other) {\n        if (other instanceof RelationFilter) {\n            return (this.op.equals(other.op) &&\n                this.field.equals(other.field) &&\n                this.value.equals(other.value));\n        }\n        else {\n            return false;\n        }\n    };\n    RelationFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n    };\n    return RelationFilter;\n}());\nexport { RelationFilter };\n/**\n * Filter that matches 'null' values.\n */\nvar NullFilter = /** @class */ (function () {\n    function NullFilter(field) {\n        this.field = field;\n    }\n    NullFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field);\n        return val !== undefined && val.value() === null;\n    };\n    NullFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS null';\n    };\n    NullFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS null\";\n    };\n    NullFilter.prototype.equals = function (other) {\n        if (other instanceof NullFilter) {\n            return this.field.equals(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NullFilter;\n}());\nexport { NullFilter };\n/**\n * Filter that matches 'NaN' values.\n */\nvar NanFilter = /** @class */ (function () {\n    function NanFilter(field) {\n        this.field = field;\n    }\n    NanFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field).value();\n        return typeof val === 'number' && isNaN(val);\n    };\n    NanFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS NaN';\n    };\n    NanFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS NaN\";\n    };\n    NanFilter.prototype.equals = function (other) {\n        if (other instanceof NanFilter) {\n            return this.field.equals(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NanFilter;\n}());\nexport { NanFilter };\n/**\n * Creates a filter based on the provided arguments.\n */\nexport function fieldFilter(field, op, value) {\n    if (value.equals(NullValue.INSTANCE)) {\n        if (op !== RelationOp.EQUAL) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on null.');\n        }\n        return new NullFilter(field);\n    }\n    else if (value.equals(DoubleValue.NAN)) {\n        if (op !== RelationOp.EQUAL) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on NaN.');\n        }\n        return new NanFilter(field);\n    }\n    else {\n        return new RelationFilter(field, op, value);\n    }\n}\n/**\n * The direction of sorting in an order by.\n */\nvar Direction = /** @class */ (function () {\n    function Direction(name) {\n        this.name = name;\n    }\n    Direction.prototype.toString = function () {\n        return this.name;\n    };\n    Direction.ASCENDING = new Direction('asc');\n    Direction.DESCENDING = new Direction('desc');\n    return Direction;\n}());\nexport { Direction };\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nvar Bound = /** @class */ (function () {\n    function Bound(position, before) {\n        this.position = position;\n        this.before = before;\n    }\n    Bound.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        var canonicalId = this.before ? 'b:' : 'a:';\n        for (var _i = 0, _a = this.position; _i < _a.length; _i++) {\n            var component = _a[_i];\n            canonicalId += component.toString();\n        }\n        return canonicalId;\n    };\n    /**\n     * Returns true if a document sorts before a bound using the provided sort\n     * order.\n     */\n    Bound.prototype.sortsBeforeDocument = function (orderBy, doc) {\n        assert(this.position.length <= orderBy.length, \"Bound has more components than query's orderBy\");\n        var comparison = 0;\n        for (var i = 0; i < this.position.length; i++) {\n            var orderByComponent = orderBy[i];\n            var component = this.position[i];\n            if (orderByComponent.field.isKeyField()) {\n                assert(component instanceof RefValue, 'Bound has a non-key value where the key path is being used.');\n                comparison = DocumentKey.comparator(component.key, doc.key);\n            }\n            else {\n                var docValue = doc.field(orderByComponent.field);\n                assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');\n                comparison = component.compareTo(docValue);\n            }\n            if (orderByComponent.dir === Direction.DESCENDING) {\n                comparison = comparison * -1;\n            }\n            if (comparison !== 0) {\n                break;\n            }\n        }\n        return this.before ? comparison <= 0 : comparison < 0;\n    };\n    Bound.prototype.equals = function (other) {\n        if (other === null) {\n            return false;\n        }\n        if (this.before !== other.before ||\n            this.position.length !== other.position.length) {\n            return false;\n        }\n        for (var i = 0; i < this.position.length; i++) {\n            var thisPosition = this.position[i];\n            var otherPosition = other.position[i];\n            return thisPosition.equals(otherPosition);\n        }\n        return true;\n    };\n    return Bound;\n}());\nexport { Bound };\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nvar OrderBy = /** @class */ (function () {\n    function OrderBy(field, dir) {\n        this.field = field;\n        if (dir === undefined) {\n            dir = Direction.ASCENDING;\n        }\n        this.dir = dir;\n        this.isKeyOrderBy = field.isKeyField();\n    }\n    OrderBy.prototype.compare = function (d1, d2) {\n        var comparison = this.isKeyOrderBy\n            ? Document.compareByKey(d1, d2)\n            : Document.compareByField(this.field, d1, d2);\n        switch (this.dir) {\n            case Direction.ASCENDING:\n                return comparison;\n            case Direction.DESCENDING:\n                return -1 * comparison;\n            default:\n                return fail('Unknown direction: ' + this.dir);\n        }\n    };\n    OrderBy.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        return this.field.canonicalString() + this.dir.toString();\n    };\n    OrderBy.prototype.toString = function () {\n        return this.field.canonicalString() + \" (\" + this.dir + \")\";\n    };\n    OrderBy.prototype.equals = function (other) {\n        return this.dir === other.dir && this.field.equals(other.field);\n    };\n    return OrderBy;\n}());\nexport { OrderBy };\nvar KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);\nvar KEY_ORDERING_DESC = new OrderBy(FieldPath.keyField(), Direction.DESCENDING);\n\n\n"]}