{"version":3,"sources":["src/firestore/core/timestamp.ts","firestore/core/timestamp.js"],"names":["isoRegExp","RegExp","Timestamp","seconds","nanos","now","fromEpochMilliseconds","Date","fromDate","date","getTime","milliseconds","Math","floor","fromISOString","utc","fraction","exec","nanoStr","substr","parseInt","prototype","toDate","toEpochMilliseconds","compareTo","other","equals","toString"],"mappings":"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","file":"timestamp.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\n\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\nexport class Timestamp {\n  static now(): Timestamp {\n    return Timestamp.fromEpochMilliseconds(Date.now());\n  }\n\n  static fromDate(date: Date): Timestamp {\n    return Timestamp.fromEpochMilliseconds(date.getTime());\n  }\n\n  static fromEpochMilliseconds(milliseconds: number): Timestamp {\n    const seconds = Math.floor(milliseconds / 1000);\n    const nanos = (milliseconds - seconds * 1000) * 1e6;\n    return new Timestamp(seconds, nanos);\n  }\n\n  static fromISOString(utc: string): Timestamp {\n    // The date string can have higher precision (nanos) than the Date class\n    // (millis), so we do some custom parsing here.\n\n    // Parse the nanos right out of the string.\n    let nanos = 0;\n    const fraction = isoRegExp.exec(utc);\n    assert(!!fraction, 'invalid timestamp: ' + utc);\n    if (fraction![1]) {\n      // Pad the fraction out to 9 digits (nanos).\n      let nanoStr = fraction![1];\n      nanoStr = (nanoStr + '000000000').substr(0, 9);\n      nanos = parseInt(nanoStr, 10);\n    }\n\n    // Parse the date to get the seconds.\n    const date = new Date(utc);\n    const seconds = Math.floor(date.getTime() / 1000);\n\n    return new Timestamp(seconds, nanos);\n  }\n\n  constructor(readonly seconds: number, readonly nanos: number) {\n    assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n    assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos);\n    // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n    assert(\n      seconds >= -62135596800,\n      'timestamp seconds out of range: ' + seconds\n    );\n    // This will break in the year 10,000.\n    assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n  }\n\n  toDate(): Date {\n    return new Date(this.toEpochMilliseconds());\n  }\n\n  toEpochMilliseconds(): number {\n    return this.seconds * 1000 + this.nanos / 1e6;\n  }\n\n  compareTo(other: Timestamp): number {\n    if (this.seconds === other.seconds) {\n      return primitiveComparator(this.nanos, other.nanos);\n    }\n    return primitiveComparator(this.seconds, other.seconds);\n  }\n\n  equals(other: Timestamp): boolean {\n    return other.seconds === this.seconds && other.nanos === this.nanos;\n  }\n\n  toString(): string {\n    return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nvar isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\nvar Timestamp = /** @class */ (function () {\n    function Timestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n        assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n        assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos);\n        // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n        assert(seconds >= -62135596800, 'timestamp seconds out of range: ' + seconds);\n        // This will break in the year 10,000.\n        assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n    }\n    Timestamp.now = function () {\n        return Timestamp.fromEpochMilliseconds(Date.now());\n    };\n    Timestamp.fromDate = function (date) {\n        return Timestamp.fromEpochMilliseconds(date.getTime());\n    };\n    Timestamp.fromEpochMilliseconds = function (milliseconds) {\n        var seconds = Math.floor(milliseconds / 1000);\n        var nanos = (milliseconds - seconds * 1000) * 1e6;\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.fromISOString = function (utc) {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        var nanos = 0;\n        var fraction = isoRegExp.exec(utc);\n        assert(!!fraction, 'invalid timestamp: ' + utc);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            var nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = parseInt(nanoStr, 10);\n        }\n        // Parse the date to get the seconds.\n        var date = new Date(utc);\n        var seconds = Math.floor(date.getTime() / 1000);\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.prototype.toDate = function () {\n        return new Date(this.toEpochMilliseconds());\n    };\n    Timestamp.prototype.toEpochMilliseconds = function () {\n        return this.seconds * 1000 + this.nanos / 1e6;\n    };\n    Timestamp.prototype.compareTo = function (other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanos, other.nanos);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    };\n    Timestamp.prototype.equals = function (other) {\n        return other.seconds === this.seconds && other.nanos === this.nanos;\n    };\n    Timestamp.prototype.toString = function () {\n        return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n    };\n    return Timestamp;\n}());\nexport { Timestamp };\n\n\n"]}