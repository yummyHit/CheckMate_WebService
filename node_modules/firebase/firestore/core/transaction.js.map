{"version":3,"sources":["src/firestore/core/transaction.ts","firestore/core/transaction.js"],"names":["Transaction","datastore","readVersions","mutations","committed","prototype","recordVersion","doc","docVersion","version","forDeletedDoc","existingVersion","get","key","equals","ABORTED","insert","lookup","keys","_this","reject","length","then","docs","forEach","write","FAILED_PRECONDITION","concat","precondition","updateTime","NONE","preconditionForUpdate","exists","set","data","toMutations","update","delete","commit","unwritten","mutation","remove","isEmpty","Error"],"mappings":"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","file":"transaction.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParsedSetData, ParsedUpdateData } from '../api/user_data_converter';\nimport { SnapshotVersion } from './snapshot_version';\nimport { documentVersionMap } from '../model/collections';\nimport { NoDocument } from '../model/document';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { Datastore } from '../remote/datastore';\nimport { Code, FirestoreError } from '../util/error';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nexport class Transaction {\n  // The version of each document that was read during this transaction.\n  private readVersions = documentVersionMap();\n  private mutations: Mutation[] = [];\n  private committed = false;\n\n  constructor(private datastore: Datastore) {}\n\n  private recordVersion(doc: MaybeDocument) {\n    let docVersion = doc.version;\n    if (doc instanceof NoDocument) {\n      // For deleted docs, we must use baseVersion 0 when we overwrite them.\n      docVersion = SnapshotVersion.forDeletedDoc();\n    }\n    const existingVersion = this.readVersions.get(doc.key);\n    if (existingVersion !== null) {\n      if (!docVersion.equals(existingVersion)) {\n        // This transaction will fail no matter what.\n        throw new FirestoreError(\n          Code.ABORTED,\n          'Document version changed between two reads.'\n        );\n      }\n    } else {\n      this.readVersions = this.readVersions.insert(doc.key, docVersion);\n    }\n  }\n\n  lookup(keys: DocumentKey[]): Promise<MaybeDocument[]> {\n    if (this.committed) {\n      return Promise.reject<MaybeDocument[]>(\n        'Transaction has already completed.'\n      );\n    }\n    if (this.mutations.length > 0) {\n      return Promise.reject<MaybeDocument[]>(\n        'Transactions lookups are invalid after writes.'\n      );\n    }\n    return this.datastore.lookup(keys).then(docs => {\n      docs.forEach(doc => this.recordVersion(doc));\n      return docs;\n    });\n  }\n\n  private write(mutations: Mutation[]) {\n    if (this.committed) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Transaction has already completed.'\n      );\n    }\n    this.mutations = this.mutations.concat(mutations);\n  }\n\n  /**\n   * Returns the version of this document when it was read in this transaction,\n   * as a precondition, or no precondition if it was not read.\n   */\n  private precondition(key: DocumentKey): Precondition {\n    const version = this.readVersions.get(key);\n    if (version) {\n      return Precondition.updateTime(version);\n    } else {\n      return Precondition.NONE;\n    }\n  }\n\n  /**\n   * Returns the precondition for a document if the operation is an update.\n   */\n  private preconditionForUpdate(key: DocumentKey): Precondition {\n    const version = this.readVersions.get(key);\n    if (version && version.equals(SnapshotVersion.forDeletedDoc())) {\n      // The document doesn't exist, so fail the transaction.\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        \"Can't update a document that doesn't exist.\"\n      );\n    } else if (version) {\n      // Document exists, base precondition on document update time.\n      return Precondition.updateTime(version);\n    } else {\n      // Document was not read, so we just use the preconditions for a blind\n      // update.\n      return Precondition.exists(true);\n    }\n  }\n\n  set(key: DocumentKey, data: ParsedSetData) {\n    this.write(data.toMutations(key, this.precondition(key)));\n  }\n\n  update(key: DocumentKey, data: ParsedUpdateData) {\n    this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n  }\n\n  delete(key: DocumentKey) {\n    this.write([new DeleteMutation(key, this.precondition(key))]);\n    // Since the delete will be applied before all following writes, we need to\n    // ensure that the precondition for the next write will be exists: false.\n    this.readVersions = this.readVersions.insert(\n      key,\n      SnapshotVersion.forDeletedDoc()\n    );\n  }\n\n  commit(): Promise<void> {\n    let unwritten = this.readVersions;\n    // For each mutation, note that the doc was written.\n    this.mutations.forEach(mutation => {\n      unwritten = unwritten.remove(mutation.key);\n    });\n    if (!unwritten.isEmpty()) {\n      return Promise.reject(\n        Error('Every document read in a transaction must also be written.')\n      );\n    }\n    return this.datastore.commit(this.mutations).then(() => {\n      this.committed = true;\n    });\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from './snapshot_version';\nimport { documentVersionMap } from '../model/collections';\nimport { NoDocument } from '../model/document';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { Code, FirestoreError } from '../util/error';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nvar Transaction = /** @class */ (function () {\n    function Transaction(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = documentVersionMap();\n        this.mutations = [];\n        this.committed = false;\n    }\n    Transaction.prototype.recordVersion = function (doc) {\n        var docVersion = doc.version;\n        if (doc instanceof NoDocument) {\n            // For deleted docs, we must use baseVersion 0 when we overwrite them.\n            docVersion = SnapshotVersion.forDeletedDoc();\n        }\n        var existingVersion = this.readVersions.get(doc.key);\n        if (existingVersion !== null) {\n            if (!docVersion.equals(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions = this.readVersions.insert(doc.key, docVersion);\n        }\n    };\n    Transaction.prototype.lookup = function (keys) {\n        var _this = this;\n        if (this.committed) {\n            return Promise.reject('Transaction has already completed.');\n        }\n        if (this.mutations.length > 0) {\n            return Promise.reject('Transactions lookups are invalid after writes.');\n        }\n        return this.datastore.lookup(keys).then(function (docs) {\n            docs.forEach(function (doc) { return _this.recordVersion(doc); });\n            return docs;\n        });\n    };\n    Transaction.prototype.write = function (mutations) {\n        if (this.committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');\n        }\n        this.mutations = this.mutations.concat(mutations);\n    };\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    Transaction.prototype.precondition = function (key) {\n        var version = this.readVersions.get(key);\n        if (version) {\n            return Precondition.updateTime(version);\n        }\n        else {\n            return Precondition.NONE;\n        }\n    };\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    Transaction.prototype.preconditionForUpdate = function (key) {\n        var version = this.readVersions.get(key);\n        if (version && version.equals(SnapshotVersion.forDeletedDoc())) {\n            // The document doesn't exist, so fail the transaction.\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n        }\n        else if (version) {\n            // Document exists, base precondition on document update time.\n            return Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return Precondition.exists(true);\n        }\n    };\n    Transaction.prototype.set = function (key, data) {\n        this.write(data.toMutations(key, this.precondition(key)));\n    };\n    Transaction.prototype.update = function (key, data) {\n        this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n    };\n    Transaction.prototype.delete = function (key) {\n        this.write([new DeleteMutation(key, this.precondition(key))]);\n        // Since the delete will be applied before all following writes, we need to\n        // ensure that the precondition for the next write will be exists: false.\n        this.readVersions = this.readVersions.insert(key, SnapshotVersion.forDeletedDoc());\n    };\n    Transaction.prototype.commit = function () {\n        var _this = this;\n        var unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(function (mutation) {\n            unwritten = unwritten.remove(mutation.key);\n        });\n        if (!unwritten.isEmpty()) {\n            return Promise.reject(Error('Every document read in a transaction must also be written.'));\n        }\n        return this.datastore.commit(this.mutations).then(function () {\n            _this.committed = true;\n        });\n    };\n    return Transaction;\n}());\nexport { Transaction };\n\n\n"]}