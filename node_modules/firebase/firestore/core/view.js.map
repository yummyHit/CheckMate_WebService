{"version":3,"sources":["src/firestore/core/view.ts","firestore/core/view.js"],"names":["AddedLimboDocument","key","RemovedLimboDocument","View","query","syncedDocuments","syncState","current","limboDocuments","mutatedKeys","documentSet","docComparator","bind","prototype","computeDocChanges","docChanges","previousChanges","_this","changeSet","oldDocumentSet","newMutatedKeys","newDocumentSet","needsRefill","lastDocInLimit","hasLimit","size","limit","last","inorderTraversal","newMaybeDoc","oldDoc","get","newDoc","equals","matches","add","hasLocalMutations","delete","docsEqual","data","track","type","Metadata","doc","Modified","Added","Removed","applyChanges","targetChange","oldDocs","changes","getChanges","sort","c1","c2","compareChangeType","limboChanges","applyTargetChange","synced","newSyncState","Synced","Local","syncStateChanged","length","snapshot","docs","fromCache","hasPendingWrites","isEmpty","shouldBeInLimbo","has","targetMapping","mapping","documents","applyToKeySet","currentStatusUpdate","MarkCurrent","MarkNotCurrent","None","oldLimboDocuments","forEach","push","order","change"],"mappings":"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","file":"view.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport {\n  CurrentStatusUpdate,\n  ResetMapping,\n  TargetChange,\n  UpdateMapping\n} from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\n\nimport { Query } from './query';\nimport {\n  ChangeType,\n  DocumentChangeSet,\n  SyncState,\n  ViewSnapshot\n} from './view_snapshot';\n\nexport type LimboDocumentChange = AddedLimboDocument | RemovedLimboDocument;\nexport class AddedLimboDocument {\n  constructor(public key: DocumentKey) {}\n}\nexport class RemovedLimboDocument {\n  constructor(public key: DocumentKey) {}\n}\n\n/** The result of applying a set of doc changes to a view. */\nexport interface ViewDocumentChanges {\n  /** The new set of docs that should be in the view. */\n  documentSet: DocumentSet;\n  /** The diff of this these docs with the previous set of docs. */\n  changeSet: DocumentChangeSet;\n  /**\n   * Whether the set of documents passed in was not sufficient to calculate the\n   * new state of the view and there needs to be another pass based on the\n   * local cache.\n   */\n  needsRefill: boolean;\n\n  mutatedKeys: DocumentKeySet;\n}\n\nexport interface ViewChange {\n  snapshot?: ViewSnapshot;\n  limboChanges: LimboDocumentChange[];\n}\n\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nexport class View {\n  private syncState: SyncState | null = null;\n  /**\n   * A flag whether the view is current with the backend. A view is considered\n   * current after it has seen the current flag from the backend and did not\n   * lose consistency within the watch stream (e.g. because of an existence\n   * filter mismatch).\n   */\n  private current = false;\n  private documentSet: DocumentSet;\n  /** Documents in the view but not in the remote target */\n  private limboDocuments = documentKeySet();\n  /** Document Keys that have local changes */\n  private mutatedKeys = documentKeySet();\n\n  constructor(\n    private query: Query,\n    /** Documents included in the remote target */\n    private syncedDocuments: DocumentKeySet\n  ) {\n    this.documentSet = new DocumentSet(query.docComparator.bind(query));\n  }\n\n  /**\n   * Iterates over a set of doc changes, applies the query limit, and computes\n   * what the new results should be, what the changes were, and whether we may\n   * need to go back to the local cache for more results. Does not make any\n   * changes to the view.\n   * @param docChanges The doc changes to apply to this view.\n   * @param previousChanges If this is being called with a refill, then start\n   *        with this set of docs and changes instead of the current view.\n   * @return a new set of docs, changes, and refill flag.\n   */\n  computeDocChanges(\n    docChanges: MaybeDocumentMap,\n    previousChanges?: ViewDocumentChanges\n  ): ViewDocumentChanges {\n    const changeSet = previousChanges\n      ? previousChanges.changeSet\n      : new DocumentChangeSet();\n    const oldDocumentSet = previousChanges\n      ? previousChanges.documentSet\n      : this.documentSet;\n    let newMutatedKeys = previousChanges\n      ? previousChanges.mutatedKeys\n      : this.mutatedKeys;\n    let newDocumentSet = oldDocumentSet;\n    let needsRefill = false;\n\n    // Track the last doc in a (full) limit. This is necessary, because some\n    // update (a delete, or an update moving a doc past the old limit) might\n    // mean there is some other document in the local cache that either should\n    // come (1) between the old last limit doc and the new last document, in the\n    // case of updates, or (2) after the new last document, in the case of\n    // deletes. So we keep this doc at the old limit to compare the updates to.\n    //\n    // Note that this should never get used in a refill (when previousChanges is\n    // set), because there will only be adds -- no deletes or updates.\n    const lastDocInLimit =\n      this.query.hasLimit() && oldDocumentSet.size === this.query.limit\n        ? oldDocumentSet.last()\n        : null;\n\n    docChanges.inorderTraversal(\n      (key: DocumentKey, newMaybeDoc: MaybeDocument) => {\n        const oldDoc = oldDocumentSet.get(key);\n        let newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\n        if (newDoc) {\n          assert(\n            key.equals(newDoc.key),\n            'Mismatching keys found in document changes: ' +\n              key +\n              ' != ' +\n              newDoc.key\n          );\n          newDoc = this.query.matches(newDoc) ? newDoc : null;\n        }\n        if (newDoc) {\n          newDocumentSet = newDocumentSet.add(newDoc);\n          if (newDoc.hasLocalMutations) {\n            newMutatedKeys = newMutatedKeys.add(key);\n          } else {\n            newMutatedKeys = newMutatedKeys.delete(key);\n          }\n        } else {\n          newDocumentSet = newDocumentSet.delete(key);\n          newMutatedKeys = newMutatedKeys.delete(key);\n        }\n\n        // Calculate change\n        if (oldDoc && newDoc) {\n          const docsEqual = oldDoc.data.equals(newDoc.data);\n          if (\n            !docsEqual ||\n            oldDoc.hasLocalMutations !== newDoc.hasLocalMutations\n          ) {\n            // only report a change if document actually changed\n            if (docsEqual) {\n              changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n            } else {\n              changeSet.track({ type: ChangeType.Modified, doc: newDoc });\n            }\n\n            if (\n              lastDocInLimit &&\n              this.query.docComparator(newDoc, lastDocInLimit) > 0\n            ) {\n              // This doc moved from inside the limit to after the limit.\n              // That means there may be some doc in the local cache that's\n              // actually less than this one.\n              needsRefill = true;\n            }\n          }\n        } else if (!oldDoc && newDoc) {\n          changeSet.track({ type: ChangeType.Added, doc: newDoc });\n        } else if (oldDoc && !newDoc) {\n          changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n          if (lastDocInLimit) {\n            // A doc was removed from a full limit query. We'll need to\n            // requery from the local cache to see if we know about some other\n            // doc that should be in the results.\n            needsRefill = true;\n          }\n        }\n      }\n    );\n    if (this.query.hasLimit()) {\n      // TODO(klimt): Make DocumentSet size be constant time.\n      while (newDocumentSet.size > this.query.limit!) {\n        const oldDoc = newDocumentSet.last();\n        newDocumentSet = newDocumentSet.delete(oldDoc!.key);\n        changeSet.track({ type: ChangeType.Removed, doc: oldDoc! });\n      }\n    }\n    assert(\n      !needsRefill || !previousChanges,\n      'View was refilled using docs that themselves needed refilling.'\n    );\n    return {\n      documentSet: newDocumentSet,\n      changeSet,\n      needsRefill,\n      mutatedKeys: newMutatedKeys\n    };\n  }\n\n  /**\n   * Updates the view with the given ViewDocumentChanges and updates limbo docs\n   * and sync state from the given (optional) target change.\n   * @param docChanges The set of changes to make to the view's docs.\n   * @param targetChange A target change to apply for computing limbo docs and\n   *        sync state.\n   * @return A new ViewChange with the given docs, changes, and sync state.\n   */\n  applyChanges(\n    docChanges: ViewDocumentChanges,\n    targetChange?: TargetChange\n  ): ViewChange {\n    assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n    const oldDocs = this.documentSet;\n    this.documentSet = docChanges.documentSet;\n    this.mutatedKeys = docChanges.mutatedKeys;\n    // Sort changes based on type and query comparator\n    const changes = docChanges.changeSet.getChanges();\n    changes.sort((c1, c2) => {\n      return (\n        compareChangeType(c1.type, c2.type) ||\n        this.query.docComparator(c1.doc, c2.doc)\n      );\n    });\n\n    const limboChanges = this.applyTargetChange(targetChange);\n    const synced = this.limboDocuments.size === 0 && this.current;\n    const newSyncState = synced ? SyncState.Synced : SyncState.Local;\n    const syncStateChanged = newSyncState !== this.syncState;\n    this.syncState = newSyncState;\n\n    if (changes.length === 0 && !syncStateChanged) {\n      // no changes\n      return { limboChanges };\n    } else {\n      return {\n        snapshot: {\n          query: this.query,\n          docs: docChanges.documentSet,\n          oldDocs,\n          docChanges: changes,\n          fromCache: newSyncState === SyncState.Local,\n          syncStateChanged,\n          hasPendingWrites: !docChanges.mutatedKeys.isEmpty()\n        },\n        limboChanges\n      };\n    }\n  }\n\n  /**\n   * Returns whether the doc for the given key should be in limbo.\n   */\n  private shouldBeInLimbo(key: DocumentKey): boolean {\n    // If the remote end says it's part of this query, it's not in limbo.\n    if (this.syncedDocuments.has(key)) {\n      return false;\n    }\n    // The local store doesn't think it's a result, so it shouldn't be in limbo.\n    if (!this.documentSet.has(key)) {\n      return false;\n    }\n    // If there are local changes to the doc, they might explain why the server\n    // doesn't know that it's part of the query. So don't put it in limbo.\n    // TODO(klimt): Ideally, we would only consider changes that might actually\n    // affect this specific query.\n    if (this.documentSet.get(key)!.hasLocalMutations) {\n      return false;\n    }\n    // Everything else is in limbo.\n    return true;\n  }\n\n  /**\n   * Updates syncedDocuments, current, and limbo docs based on the given change.\n   * Returns the list of changes to which docs are in limbo.\n   */\n  private applyTargetChange(\n    targetChange?: TargetChange\n  ): LimboDocumentChange[] {\n    if (targetChange) {\n      const targetMapping = targetChange.mapping;\n      if (targetMapping instanceof ResetMapping) {\n        this.syncedDocuments = targetMapping.documents;\n      } else if (targetMapping instanceof UpdateMapping) {\n        this.syncedDocuments = targetMapping.applyToKeySet(\n          this.syncedDocuments\n        );\n      }\n\n      switch (targetChange.currentStatusUpdate) {\n        case CurrentStatusUpdate.MarkCurrent:\n          this.current = true;\n          break;\n        case CurrentStatusUpdate.MarkNotCurrent:\n          this.current = false;\n          break;\n        case CurrentStatusUpdate.None:\n          break;\n        default:\n          fail(\n            'Unknown current status update: ' + targetChange.currentStatusUpdate\n          );\n      }\n    }\n\n    // Recompute the set of limbo docs.\n    // TODO(klimt): Do this incrementally so that it's not quadratic when\n    // updating many documents.\n    const oldLimboDocuments = this.limboDocuments;\n    this.limboDocuments = documentKeySet();\n    if (this.current) {\n      this.documentSet.forEach(doc => {\n        if (this.shouldBeInLimbo(doc.key)) {\n          this.limboDocuments = this.limboDocuments.add(doc.key);\n        }\n      });\n    }\n\n    // Diff the new limbo docs with the old limbo docs.\n    const changes: LimboDocumentChange[] = [];\n    oldLimboDocuments.forEach(key => {\n      if (!this.limboDocuments.has(key)) {\n        changes.push(new RemovedLimboDocument(key));\n      }\n    });\n    this.limboDocuments.forEach(key => {\n      if (!oldLimboDocuments.has(key)) {\n        changes.push(new AddedLimboDocument(key));\n      }\n    });\n    return changes;\n  }\n}\n\nfunction compareChangeType(c1: ChangeType, c2: ChangeType): number {\n  const order = (change: ChangeType) => {\n    switch (change) {\n      case ChangeType.Added:\n        return 1;\n      case ChangeType.Modified:\n        return 2;\n      case ChangeType.Metadata:\n        // A metadata change is converted to a modified change at the public\n        // api layer.  Since we sort by document key and then change type,\n        // metadata and modified changes must be sorted equivalently.\n        return 2;\n      case ChangeType.Removed:\n        return 0;\n      default:\n        return fail('Unknown ChangeType: ' + change);\n    }\n  };\n\n  return order(c1) - order(c2);\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentSet } from '../model/document_set';\nimport { CurrentStatusUpdate, ResetMapping, UpdateMapping } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport { ChangeType, DocumentChangeSet, SyncState } from './view_snapshot';\nvar AddedLimboDocument = /** @class */ (function () {\n    function AddedLimboDocument(key) {\n        this.key = key;\n    }\n    return AddedLimboDocument;\n}());\nexport { AddedLimboDocument };\nvar RemovedLimboDocument = /** @class */ (function () {\n    function RemovedLimboDocument(key) {\n        this.key = key;\n    }\n    return RemovedLimboDocument;\n}());\nexport { RemovedLimboDocument };\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nvar View = /** @class */ (function () {\n    function View(query, \n        /** Documents included in the remote target */\n        syncedDocuments) {\n        this.query = query;\n        this.syncedDocuments = syncedDocuments;\n        this.syncState = null;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.documentSet = new DocumentSet(query.docComparator.bind(query));\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges The doc changes to apply to this view.\n     * @param previousChanges If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @return a new set of docs, changes, and refill flag.\n     */\n    View.prototype.computeDocChanges = function (docChanges, previousChanges) {\n        var _this = this;\n        var changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new DocumentChangeSet();\n        var oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        var newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        var newDocumentSet = oldDocumentSet;\n        var needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        docChanges.inorderTraversal(function (key, newMaybeDoc) {\n            var oldDoc = oldDocumentSet.get(key);\n            var newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\n            if (newDoc) {\n                assert(key.equals(newDoc.key), 'Mismatching keys found in document changes: ' +\n                    key +\n                    ' != ' +\n                    newDoc.key);\n                newDoc = _this.query.matches(newDoc) ? newDoc : null;\n            }\n            if (newDoc) {\n                newDocumentSet = newDocumentSet.add(newDoc);\n                if (newDoc.hasLocalMutations) {\n                    newMutatedKeys = newMutatedKeys.add(key);\n                }\n                else {\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n            else {\n                newDocumentSet = newDocumentSet.delete(key);\n                newMutatedKeys = newMutatedKeys.delete(key);\n            }\n            // Calculate change\n            if (oldDoc && newDoc) {\n                var docsEqual = oldDoc.data.equals(newDoc.data);\n                if (!docsEqual ||\n                    oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {\n                    // only report a change if document actually changed\n                    if (docsEqual) {\n                        changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n                    }\n                    else {\n                        changeSet.track({ type: ChangeType.Modified, doc: newDoc });\n                    }\n                    if (lastDocInLimit &&\n                        _this.query.docComparator(newDoc, lastDocInLimit) > 0) {\n                        // This doc moved from inside the limit to after the limit.\n                        // That means there may be some doc in the local cache that's\n                        // actually less than this one.\n                        needsRefill = true;\n                    }\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: ChangeType.Added, doc: newDoc });\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n                if (lastDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n        });\n        if (this.query.hasLimit()) {\n            // TODO(klimt): Make DocumentSet size be constant time.\n            while (newDocumentSet.size > this.query.limit) {\n                var oldDoc = newDocumentSet.last();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n            }\n        }\n        assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');\n        return {\n            documentSet: newDocumentSet,\n            changeSet: changeSet,\n            needsRefill: needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    };\n    /**\n     * Updates the view with the given ViewDocumentChanges and updates limbo docs\n     * and sync state from the given (optional) target change.\n     * @param docChanges The set of changes to make to the view's docs.\n     * @param targetChange A target change to apply for computing limbo docs and\n     *        sync state.\n     * @return A new ViewChange with the given docs, changes, and sync state.\n     */\n    View.prototype.applyChanges = function (docChanges, targetChange) {\n        var _this = this;\n        assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n        var oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        var changes = docChanges.changeSet.getChanges();\n        changes.sort(function (c1, c2) {\n            return (compareChangeType(c1.type, c2.type) ||\n                _this.query.docComparator(c1.doc, c2.doc));\n        });\n        var limboChanges = this.applyTargetChange(targetChange);\n        var synced = this.limboDocuments.size === 0 && this.current;\n        var newSyncState = synced ? SyncState.Synced : SyncState.Local;\n        var syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges: limboChanges };\n        }\n        else {\n            return {\n                snapshot: {\n                    query: this.query,\n                    docs: docChanges.documentSet,\n                    oldDocs: oldDocs,\n                    docChanges: changes,\n                    fromCache: newSyncState === SyncState.Local,\n                    syncStateChanged: syncStateChanged,\n                    hasPendingWrites: !docChanges.mutatedKeys.isEmpty()\n                },\n                limboChanges: limboChanges\n            };\n        }\n    };\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    View.prototype.shouldBeInLimbo = function (key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this.syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    };\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    View.prototype.applyTargetChange = function (targetChange) {\n        var _this = this;\n        if (targetChange) {\n            var targetMapping = targetChange.mapping;\n            if (targetMapping instanceof ResetMapping) {\n                this.syncedDocuments = targetMapping.documents;\n            }\n            else if (targetMapping instanceof UpdateMapping) {\n                this.syncedDocuments = targetMapping.applyToKeySet(this.syncedDocuments);\n            }\n            switch (targetChange.currentStatusUpdate) {\n                case CurrentStatusUpdate.MarkCurrent:\n                    this.current = true;\n                    break;\n                case CurrentStatusUpdate.MarkNotCurrent:\n                    this.current = false;\n                    break;\n                case CurrentStatusUpdate.None:\n                    break;\n                default:\n                    fail('Unknown current status update: ' + targetChange.currentStatusUpdate);\n            }\n        }\n        // Recompute the set of limbo docs.\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        var oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        if (this.current) {\n            this.documentSet.forEach(function (doc) {\n                if (_this.shouldBeInLimbo(doc.key)) {\n                    _this.limboDocuments = _this.limboDocuments.add(doc.key);\n                }\n            });\n        }\n        // Diff the new limbo docs with the old limbo docs.\n        var changes = [];\n        oldLimboDocuments.forEach(function (key) {\n            if (!_this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(function (key) {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    };\n    return View;\n}());\nexport { View };\nfunction compareChangeType(c1, c2) {\n    var order = function (change) {\n        switch (change) {\n            case ChangeType.Added:\n                return 1;\n            case ChangeType.Modified:\n                return 2;\n            case ChangeType.Metadata:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case ChangeType.Removed:\n                return 0;\n            default:\n                return fail('Unknown ChangeType: ' + change);\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n\n"]}