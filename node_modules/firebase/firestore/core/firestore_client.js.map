{"version":3,"sources":["src/firestore/core/firestore_client.ts","firestore/core/firestore_client.js"],"names":["LOG_TAG","FirestoreClient","platform","databaseInfo","credentials","asyncQueue","prototype","start","usePersistence","_this","initializationDone","persistenceResult","initialized","setUserChangeListener","user","initializePersistence","then","initializeRest","resolve","reject","schedule","handleUserChange","promise","startIndexedDbPersistence","catch","error","canFallback","console","warn","startMemoryPersistence","code","FAILED_PRECONDITION","UNIMPLEMENTED","garbageCollector","storagePrefix","buildStoragePrefix","serializer","databaseId","useProto3Json","persistence","loadConnection","connection","localStore","newSerializer","datastore","onlineStateChangedHandler","onlineState","eventMgr","onOnlineStateChanged","remoteStore","syncEngine","verifyOperationInProgress","uid","shutdown","removeUserChangeListener","listen","query","observer","options","listener","unlisten","write","mutations","deferred","transaction","updateFunction","runTransaction"],"mappings":"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","file":"firestore_client.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CredentialsProvider } from '../api/credentials';\nimport { User } from '../auth/user';\nimport {\n  EventManager,\n  ListenOptions,\n  Observer,\n  QueryListener\n} from './event_manager';\nimport { SyncEngine } from './sync_engine';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { GarbageCollector } from '../local/garbage_collector';\nimport { IndexedDbPersistence } from '../local/indexeddb_persistence';\nimport { LocalStore } from '../local/local_store';\nimport { MemoryPersistence } from '../local/memory_persistence';\nimport { NoOpGarbageCollector } from '../local/no_op_garbage_collector';\nimport { Persistence } from '../local/persistence';\nimport { Mutation } from '../model/mutation';\nimport { Platform } from '../platform/platform';\nimport { Datastore } from '../remote/datastore';\nimport { RemoteStore } from '../remote/remote_store';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { debug } from '../util/log';\nimport { Deferred } from '../util/promise';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { DatabaseId, DatabaseInfo } from './database_info';\nimport { Query } from './query';\nimport { Transaction } from './transaction';\nimport { OnlineState } from './types';\nimport { ViewSnapshot } from './view_snapshot';\n\nconst LOG_TAG = 'FirestoreClient';\n\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\nexport class FirestoreClient {\n  // NOTE: These should technically have '|undefined' in the types, since\n  // they're initialized asynchronously rather than in the constructor, but\n  // given that all work is done on the async queue and we assert that\n  // initialization completes before any other work is queued, we're cheating\n  // with the types rather than littering the code with '!' or unnecessary\n  // undefined checks.\n  private eventMgr: EventManager;\n  private garbageCollector: GarbageCollector;\n  private persistence: Persistence;\n  private localStore: LocalStore;\n  private remoteStore: RemoteStore;\n  private syncEngine: SyncEngine;\n\n  constructor(\n    private platform: Platform,\n    private databaseInfo: DatabaseInfo,\n    private credentials: CredentialsProvider,\n    /**\n       * Asynchronous queue responsible for all of our internal processing. When\n       * we get incoming work from the user (via public API) or the network\n       * (incoming GRPC messages), we should always schedule onto this queue.\n       * This ensures all of our work is properly serialized (e.g. we don't\n       * start processing a new operation while the previous one is waiting for\n       * an async I/O to complete).\n       */\n    private asyncQueue: AsyncQueue\n  ) {}\n\n  /**\n   * Starts up the FirestoreClient, returning only whether or not enabling\n   * persistence succeeded.\n   *\n   * The intent here is to \"do the right thing\" as far as users are concerned.\n   * Namely, in cases where offline persistence is requested and possible,\n   * enable it, but otherwise fall back to persistence disabled. For the most\n   * part we expect this to succeed one way or the other so we don't expect our\n   * users to actually wait on the firestore.enablePersistence Promise since\n   * they generally won't care.\n   *\n   * Of course some users actually do care about whether or not persistence\n   * was successfully enabled, so the Promise returned from this method\n   * indicates this outcome.\n   *\n   * This presents a problem though: even before enablePersistence resolves or\n   * rejects, users may have made calls to e.g. firestore.collection() which\n   * means that the FirestoreClient in there will be available and will be\n   * enqueuing actions on the async queue.\n   *\n   * Meanwhile any failure of an operation on the async queue causes it to\n   * panic and reject any further work, on the premise that unhandled errors\n   * are fatal.\n   *\n   * Consequently the fallback is handled internally here in start, and if the\n   * fallback succeeds we signal success to the async queue even though the\n   * start() itself signals failure.\n   *\n   * @param usePersistence Whether or not to attempt to enable persistence.\n   * @returns A deferred result indicating the user-visible result of enabling\n   *     offline persistence. This method will reject this if IndexedDB fails to\n   *     start for any reason. If usePersistence is false this is\n   *     unconditionally resolved.\n   */\n  public start(usePersistence: boolean): Promise<void> {\n    // We defer our initialization until we get the current user from\n    // setUserChangeListener(). We block the async queue until we got the\n    // initial user and the initialization is completed. This will prevent\n    // any scheduled work from happening before initialization is completed.\n    //\n    // If initializationDone resolved then the FirestoreClient is in a usable\n    // state.\n    const initializationDone = new Deferred<void>();\n\n    // If usePersistence is true, certain classes of errors while starting are\n    // recoverable but only by falling back to persistence disabled.\n    //\n    // If there's an error in the first case but not in recovery we cannot\n    // reject the promise blocking the async queue because this will cause the\n    // async queue to panic.\n    const persistenceResult = new Deferred<void>();\n\n    let initialized = false;\n    this.credentials.setUserChangeListener(user => {\n      if (!initialized) {\n        initialized = true;\n\n        this.initializePersistence(usePersistence, persistenceResult)\n          .then(() => this.initializeRest(user))\n          .then(initializationDone.resolve, initializationDone.reject);\n      } else {\n        this.asyncQueue.schedule(() => {\n          return this.handleUserChange(user);\n        });\n      }\n    });\n\n    // Block the async queue until initialization is done\n    this.asyncQueue.schedule(() => {\n      return initializationDone.promise;\n    });\n\n    // Return only the result of enabling persistence. Note that this does not\n    // need to await the completion of initializationDone because the result of\n    // this method should not reflect any other kind of failure to start.\n    return persistenceResult.promise;\n  }\n\n  /**\n   * Initializes persistent storage, attempting to use IndexedDB if\n   * usePersistence is true or memory-only if false.\n   *\n   * If IndexedDB fails because it's already open in another tab or because the\n   * platform can't possibly support our implementation then this method rejects\n   * the persistenceResult and falls back on memory-only persistence.\n   *\n   * @param usePersistence indicates whether or not to use offline persistence\n   * @param persistenceResult A deferred result indicating the user-visible\n   *     result of enabling offline persistence. This method will reject this if\n   *     IndexedDB fails to start for any reason. If usePersistence is false\n   *     this is unconditionally resolved.\n   * @returns a Promise indicating whether or not initialization should\n   *     continue, i.e. that one of the persistence implementations actually\n   *     succeeded.\n   */\n  private initializePersistence(\n    usePersistence: boolean,\n    persistenceResult: Deferred<void>\n  ): Promise<void> {\n    if (usePersistence) {\n      return this.startIndexedDbPersistence()\n        .then(persistenceResult.resolve)\n        .catch((error: FirestoreError) => {\n          // Regardless of whether or not the retry succeeds, from an user\n          // perspective, offline persistence has failed.\n          persistenceResult.reject(error);\n\n          // An unknown failure on the first stage shuts everything down.\n          if (!this.canFallback(error)) {\n            return Promise.reject(error);\n          }\n\n          console.warn(\n            'Error enabling offline storage. Falling back to' +\n              ' storage disabled: ' +\n              error\n          );\n          return this.startMemoryPersistence();\n        });\n    } else {\n      // When usePersistence == false, enabling offline persistence is defined\n      // to unconditionally succeed. This allows start() to have the same\n      // signature for both cases, despite the fact that the returned promise\n      // is only used in the enablePersistence call.\n      persistenceResult.resolve();\n      return this.startMemoryPersistence();\n    }\n  }\n\n  private canFallback(error: FirestoreError): boolean {\n    return (\n      error.code === Code.FAILED_PRECONDITION ||\n      error.code === Code.UNIMPLEMENTED\n    );\n  }\n\n  /**\n   * Starts IndexedDB-based persistence.\n   *\n   * @returns A promise indicating success or failure.\n   */\n  private startIndexedDbPersistence(): Promise<void> {\n    // TODO(http://b/33384523): For now we just disable garbage collection\n    // when persistence is enabled.\n    this.garbageCollector = new NoOpGarbageCollector();\n    const storagePrefix = IndexedDbPersistence.buildStoragePrefix(\n      this.databaseInfo\n    );\n    // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.\n    const serializer = new JsonProtoSerializer(this.databaseInfo.databaseId, {\n      useProto3Json: true\n    });\n    this.persistence = new IndexedDbPersistence(storagePrefix, serializer);\n    return this.persistence.start();\n  }\n\n  /**\n   * Starts Memory-backed persistence. In practice this cannot fail.\n   *\n   * @returns A promise that will successfully resolve.\n   */\n  private startMemoryPersistence(): Promise<void> {\n    this.garbageCollector = new EagerGarbageCollector();\n    this.persistence = new MemoryPersistence();\n    return this.persistence.start();\n  }\n\n  /**\n   * Initializes the rest of the FirestoreClient, assuming the initial user\n   * has been obtained from the credential provider and some persistence\n   * implementation is available in this.persistence.\n   */\n  private initializeRest(user: User): Promise<void> {\n    return this.platform\n      .loadConnection(this.databaseInfo)\n      .then(connection => {\n        this.localStore = new LocalStore(\n          this.persistence,\n          user,\n          this.garbageCollector\n        );\n        const serializer = this.platform.newSerializer(\n          this.databaseInfo.databaseId\n        );\n        const datastore = new Datastore(\n          this.databaseInfo,\n          this.asyncQueue,\n          connection,\n          this.credentials,\n          serializer\n        );\n\n        const onlineStateChangedHandler = (onlineState: OnlineState) => {\n          this.eventMgr.onOnlineStateChanged(onlineState);\n        };\n\n        this.remoteStore = new RemoteStore(\n          this.databaseInfo,\n          this.asyncQueue,\n          this.localStore,\n          datastore,\n          onlineStateChangedHandler\n        );\n\n        this.syncEngine = new SyncEngine(\n          this.localStore,\n          this.remoteStore,\n          user\n        );\n\n        // Setup wiring between sync engine and remote store\n        this.remoteStore.syncEngine = this.syncEngine;\n\n        this.eventMgr = new EventManager(this.syncEngine);\n\n        // NOTE: RemoteStore depends on LocalStore (for persisting stream\n        // tokens, refilling mutation queue, etc.) so must be started after\n        // LocalStore.\n        return this.localStore.start();\n      })\n      .then(() => {\n        return this.remoteStore.start();\n      });\n  }\n\n  private handleUserChange(user: User): Promise<void> {\n    this.asyncQueue.verifyOperationInProgress();\n\n    debug(LOG_TAG, 'User Changed: ' + user.uid);\n    return this.syncEngine.handleUserChange(user);\n  }\n\n  shutdown(): Promise<void> {\n    return this.asyncQueue\n      .schedule(() => {\n        this.credentials.removeUserChangeListener();\n        return this.remoteStore.shutdown();\n      })\n      .then(() => {\n        // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n        return this.persistence.shutdown();\n      });\n  }\n\n  listen(\n    query: Query,\n    observer: Observer<ViewSnapshot>,\n    options: ListenOptions\n  ): QueryListener {\n    const listener = new QueryListener(query, observer, options);\n    this.asyncQueue.schedule(() => {\n      return this.eventMgr.listen(listener);\n    });\n    return listener;\n  }\n\n  unlisten(listener: QueryListener): void {\n    this.asyncQueue.schedule(() => {\n      return this.eventMgr.unlisten(listener);\n    });\n  }\n\n  write(mutations: Mutation[]): Promise<void> {\n    const deferred = new Deferred<void>();\n    this.asyncQueue.schedule(() => this.syncEngine.write(mutations, deferred));\n    return deferred.promise;\n  }\n\n  databaseId(): DatabaseId {\n    return this.databaseInfo.databaseId;\n  }\n\n  transaction<T>(\n    updateFunction: (transaction: Transaction) => Promise<T>\n  ): Promise<T> {\n    // We have to wait for the async queue to be sure syncEngine is initialized.\n    return this.asyncQueue\n      .schedule(() => {\n        return Promise.resolve();\n      })\n      .then(() => {\n        return this.syncEngine.runTransaction(updateFunction);\n      });\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventManager, QueryListener } from './event_manager';\nimport { SyncEngine } from './sync_engine';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { IndexedDbPersistence } from '../local/indexeddb_persistence';\nimport { LocalStore } from '../local/local_store';\nimport { MemoryPersistence } from '../local/memory_persistence';\nimport { NoOpGarbageCollector } from '../local/no_op_garbage_collector';\nimport { Datastore } from '../remote/datastore';\nimport { RemoteStore } from '../remote/remote_store';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { Code } from '../util/error';\nimport { debug } from '../util/log';\nimport { Deferred } from '../util/promise';\nimport { PromiseImpl as Promise } from '../../utils/promise';\nvar LOG_TAG = 'FirestoreClient';\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\nvar FirestoreClient = /** @class */ (function () {\n    function FirestoreClient(platform, databaseInfo, credentials, \n        /**\n           * Asynchronous queue responsible for all of our internal processing. When\n           * we get incoming work from the user (via public API) or the network\n           * (incoming GRPC messages), we should always schedule onto this queue.\n           * This ensures all of our work is properly serialized (e.g. we don't\n           * start processing a new operation while the previous one is waiting for\n           * an async I/O to complete).\n           */\n        asyncQueue) {\n        this.platform = platform;\n        this.databaseInfo = databaseInfo;\n        this.credentials = credentials;\n        this.asyncQueue = asyncQueue;\n    }\n    /**\n     * Starts up the FirestoreClient, returning only whether or not enabling\n     * persistence succeeded.\n     *\n     * The intent here is to \"do the right thing\" as far as users are concerned.\n     * Namely, in cases where offline persistence is requested and possible,\n     * enable it, but otherwise fall back to persistence disabled. For the most\n     * part we expect this to succeed one way or the other so we don't expect our\n     * users to actually wait on the firestore.enablePersistence Promise since\n     * they generally won't care.\n     *\n     * Of course some users actually do care about whether or not persistence\n     * was successfully enabled, so the Promise returned from this method\n     * indicates this outcome.\n     *\n     * This presents a problem though: even before enablePersistence resolves or\n     * rejects, users may have made calls to e.g. firestore.collection() which\n     * means that the FirestoreClient in there will be available and will be\n     * enqueuing actions on the async queue.\n     *\n     * Meanwhile any failure of an operation on the async queue causes it to\n     * panic and reject any further work, on the premise that unhandled errors\n     * are fatal.\n     *\n     * Consequently the fallback is handled internally here in start, and if the\n     * fallback succeeds we signal success to the async queue even though the\n     * start() itself signals failure.\n     *\n     * @param usePersistence Whether or not to attempt to enable persistence.\n     * @returns A deferred result indicating the user-visible result of enabling\n     *     offline persistence. This method will reject this if IndexedDB fails to\n     *     start for any reason. If usePersistence is false this is\n     *     unconditionally resolved.\n     */\n    FirestoreClient.prototype.start = function (usePersistence) {\n        var _this = this;\n        // We defer our initialization until we get the current user from\n        // setUserChangeListener(). We block the async queue until we got the\n        // initial user and the initialization is completed. This will prevent\n        // any scheduled work from happening before initialization is completed.\n        //\n        // If initializationDone resolved then the FirestoreClient is in a usable\n        // state.\n        var initializationDone = new Deferred();\n        // If usePersistence is true, certain classes of errors while starting are\n        // recoverable but only by falling back to persistence disabled.\n        //\n        // If there's an error in the first case but not in recovery we cannot\n        // reject the promise blocking the async queue because this will cause the\n        // async queue to panic.\n        var persistenceResult = new Deferred();\n        var initialized = false;\n        this.credentials.setUserChangeListener(function (user) {\n            if (!initialized) {\n                initialized = true;\n                _this.initializePersistence(usePersistence, persistenceResult)\n                    .then(function () { return _this.initializeRest(user); })\n                    .then(initializationDone.resolve, initializationDone.reject);\n            }\n            else {\n                _this.asyncQueue.schedule(function () {\n                    return _this.handleUserChange(user);\n                });\n            }\n        });\n        // Block the async queue until initialization is done\n        this.asyncQueue.schedule(function () {\n            return initializationDone.promise;\n        });\n        // Return only the result of enabling persistence. Note that this does not\n        // need to await the completion of initializationDone because the result of\n        // this method should not reflect any other kind of failure to start.\n        return persistenceResult.promise;\n    };\n    /**\n     * Initializes persistent storage, attempting to use IndexedDB if\n     * usePersistence is true or memory-only if false.\n     *\n     * If IndexedDB fails because it's already open in another tab or because the\n     * platform can't possibly support our implementation then this method rejects\n     * the persistenceResult and falls back on memory-only persistence.\n     *\n     * @param usePersistence indicates whether or not to use offline persistence\n     * @param persistenceResult A deferred result indicating the user-visible\n     *     result of enabling offline persistence. This method will reject this if\n     *     IndexedDB fails to start for any reason. If usePersistence is false\n     *     this is unconditionally resolved.\n     * @returns a Promise indicating whether or not initialization should\n     *     continue, i.e. that one of the persistence implementations actually\n     *     succeeded.\n     */\n    FirestoreClient.prototype.initializePersistence = function (usePersistence, persistenceResult) {\n        var _this = this;\n        if (usePersistence) {\n            return this.startIndexedDbPersistence()\n                .then(persistenceResult.resolve)\n                .catch(function (error) {\n                // Regardless of whether or not the retry succeeds, from an user\n                // perspective, offline persistence has failed.\n                persistenceResult.reject(error);\n                // An unknown failure on the first stage shuts everything down.\n                if (!_this.canFallback(error)) {\n                    return Promise.reject(error);\n                }\n                console.warn('Error enabling offline storage. Falling back to' +\n                    ' storage disabled: ' +\n                    error);\n                return _this.startMemoryPersistence();\n            });\n        }\n        else {\n            // When usePersistence == false, enabling offline persistence is defined\n            // to unconditionally succeed. This allows start() to have the same\n            // signature for both cases, despite the fact that the returned promise\n            // is only used in the enablePersistence call.\n            persistenceResult.resolve();\n            return this.startMemoryPersistence();\n        }\n    };\n    FirestoreClient.prototype.canFallback = function (error) {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    };\n    /**\n     * Starts IndexedDB-based persistence.\n     *\n     * @returns A promise indicating success or failure.\n     */\n    FirestoreClient.prototype.startIndexedDbPersistence = function () {\n        // TODO(http://b/33384523): For now we just disable garbage collection\n        // when persistence is enabled.\n        this.garbageCollector = new NoOpGarbageCollector();\n        var storagePrefix = IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);\n        // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.\n        var serializer = new JsonProtoSerializer(this.databaseInfo.databaseId, {\n            useProto3Json: true\n        });\n        this.persistence = new IndexedDbPersistence(storagePrefix, serializer);\n        return this.persistence.start();\n    };\n    /**\n     * Starts Memory-backed persistence. In practice this cannot fail.\n     *\n     * @returns A promise that will successfully resolve.\n     */\n    FirestoreClient.prototype.startMemoryPersistence = function () {\n        this.garbageCollector = new EagerGarbageCollector();\n        this.persistence = new MemoryPersistence();\n        return this.persistence.start();\n    };\n    /**\n     * Initializes the rest of the FirestoreClient, assuming the initial user\n     * has been obtained from the credential provider and some persistence\n     * implementation is available in this.persistence.\n     */\n    FirestoreClient.prototype.initializeRest = function (user) {\n        var _this = this;\n        return this.platform\n            .loadConnection(this.databaseInfo)\n            .then(function (connection) {\n            _this.localStore = new LocalStore(_this.persistence, user, _this.garbageCollector);\n            var serializer = _this.platform.newSerializer(_this.databaseInfo.databaseId);\n            var datastore = new Datastore(_this.databaseInfo, _this.asyncQueue, connection, _this.credentials, serializer);\n            var onlineStateChangedHandler = function (onlineState) {\n                _this.eventMgr.onOnlineStateChanged(onlineState);\n            };\n            _this.remoteStore = new RemoteStore(_this.databaseInfo, _this.asyncQueue, _this.localStore, datastore, onlineStateChangedHandler);\n            _this.syncEngine = new SyncEngine(_this.localStore, _this.remoteStore, user);\n            // Setup wiring between sync engine and remote store\n            _this.remoteStore.syncEngine = _this.syncEngine;\n            _this.eventMgr = new EventManager(_this.syncEngine);\n            // NOTE: RemoteStore depends on LocalStore (for persisting stream\n            // tokens, refilling mutation queue, etc.) so must be started after\n            // LocalStore.\n            return _this.localStore.start();\n        })\n            .then(function () {\n            return _this.remoteStore.start();\n        });\n    };\n    FirestoreClient.prototype.handleUserChange = function (user) {\n        this.asyncQueue.verifyOperationInProgress();\n        debug(LOG_TAG, 'User Changed: ' + user.uid);\n        return this.syncEngine.handleUserChange(user);\n    };\n    FirestoreClient.prototype.shutdown = function () {\n        var _this = this;\n        return this.asyncQueue\n            .schedule(function () {\n            _this.credentials.removeUserChangeListener();\n            return _this.remoteStore.shutdown();\n        })\n            .then(function () {\n            // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n            return _this.persistence.shutdown();\n        });\n    };\n    FirestoreClient.prototype.listen = function (query, observer, options) {\n        var _this = this;\n        var listener = new QueryListener(query, observer, options);\n        this.asyncQueue.schedule(function () {\n            return _this.eventMgr.listen(listener);\n        });\n        return listener;\n    };\n    FirestoreClient.prototype.unlisten = function (listener) {\n        var _this = this;\n        this.asyncQueue.schedule(function () {\n            return _this.eventMgr.unlisten(listener);\n        });\n    };\n    FirestoreClient.prototype.write = function (mutations) {\n        var _this = this;\n        var deferred = new Deferred();\n        this.asyncQueue.schedule(function () { return _this.syncEngine.write(mutations, deferred); });\n        return deferred.promise;\n    };\n    FirestoreClient.prototype.databaseId = function () {\n        return this.databaseInfo.databaseId;\n    };\n    FirestoreClient.prototype.transaction = function (updateFunction) {\n        var _this = this;\n        // We have to wait for the async queue to be sure syncEngine is initialized.\n        return this.asyncQueue\n            .schedule(function () {\n            return Promise.resolve();\n        })\n            .then(function () {\n            return _this.syncEngine.runTransaction(updateFunction);\n        });\n    };\n    return FirestoreClient;\n}());\nexport { FirestoreClient };\n\n\n"]}