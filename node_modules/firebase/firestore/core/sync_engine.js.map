{"version":3,"sources":["src/firestore/core/sync_engine.ts","firestore/core/sync_engine.js"],"names":["log","objUtils","LOG_TAG","QueryView","query","targetId","resumeToken","view","SyncEngine","localStore","remoteStore","currentUser","viewHandler","errorHandler","queryViewsByQuery","q","canonicalId","queryViewsByTarget","limboTargetsByKey","comparator","limboKeysByTarget","limboDocumentRefs","limboCollector","mutationUserCallbacks","targetIdGenerator","forSyncEngine","prototype","subscribe","addGarbageSource","listen","_this","assertSubscribed","has","allocateQuery","then","queryData","executeQuery","docs","remoteDocumentKeys","remoteKeys","viewDocChanges","computeDocChanges","viewChange","applyChanges","limboChanges","length","snapshot","data","set","unlisten","queryView","get","releaseQuery","removeAndCleanupQuery","collectGarbage","write","batch","userCallback","localWrite","result","addMutationCallback","batchId","emitNewSnapsAndNotifyLocalStore","changes","fillWritePipeline","wrapUpdateFunctionError","error","runTransaction","updateFunction","retries","transaction","createTransaction","wrappedUpdateFunction","userPromise","catch","reject","Error","e","commit","applyRemoteEvent","remoteEvent","forEachNumber","targetChanges","targetChange","limboKey","currentStatusUpdate","MarkCurrent","documentUpdates","addDocumentUpdate","snapshotVersion","rejectListen","err","remove","docMap","insert","forDeletedDoc","event_1","MIN","queryView_1","applySuccessfulWrite","mutationBatchResult","processUserCallback","acknowledgeBatch","rejectFailedWrite","rejectBatch","callback","newCallbacks","toKey","minKey","resolve","delete","removeReferencesForId","gcLimboDocuments","updateTrackedLimbos","_i","limboChanges_1","limboChange","addReference","key","trackLimboChange","debug","removeReference","JSON","stringify","limboTargetId","next","atPath","path","Listen","keys","forEach","toPromise","currentLimboDocs","newSnaps","docChangesInAllViews","queriesProcessed","_","push","needsRefill","docChanges","fromSnapshot","all","notifyLocalViewChanges","fnName","handleUserChange","user"],"mappings":"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","file":"sync_engine.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { LocalStore } from '../local/local_store';\nimport { LocalViewChanges } from '../local/local_view_changes';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { ReferenceSet } from '../local/reference_set';\nimport { MaybeDocumentMap } from '../model/collections';\nimport { MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { MutationBatchResult } from '../model/mutation_batch';\nimport { CurrentStatusUpdate, RemoteEvent } from '../remote/remote_event';\nimport { RemoteStore } from '../remote/remote_store';\nimport { RemoteSyncer } from '../remote/remote_syncer';\nimport { assert, fail } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AnyJs, primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\nimport { Deferred } from '../util/promise';\nimport { SortedMap } from '../util/sorted_map';\nimport { isNullOrUndefined } from '../util/types';\nimport { PromiseImpl as Promise } from '../../utils/promise';\n\nimport { Query } from './query';\nimport { SnapshotVersion } from './snapshot_version';\nimport { TargetIdGenerator } from './target_id_generator';\nimport { Transaction } from './transaction';\nimport { BatchId, ProtoByteString, TargetId } from './types';\nimport {\n  AddedLimboDocument,\n  LimboDocumentChange,\n  RemovedLimboDocument,\n  View,\n  ViewDocumentChanges\n} from './view';\nimport { ViewSnapshot } from './view_snapshot';\n\nconst LOG_TAG = 'SyncEngine';\n\nexport type ViewHandler = (viewSnaps: ViewSnapshot[]) => void;\nexport type ErrorHandler = (query: Query, error: Error) => void;\n\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nclass QueryView {\n  constructor(\n    /**\n     * The query itself.\n     */\n    public query: Query,\n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    public targetId: TargetId,\n    /**\n     * An identifier from the datastore backend that indicates the last state\n     * of the results that was received. This can be used to indicate where\n     * to continue receiving new doc changes for the query.\n     */\n    public resumeToken: ProtoByteString,\n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    public view: View\n  ) {}\n}\n\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngine’s methods should only ever be called by methods running in the\n * global async queue.\n */\nexport class SyncEngine implements RemoteSyncer {\n  private viewHandler: ViewHandler | null = null;\n  private errorHandler: ErrorHandler | null = null;\n\n  private queryViewsByQuery = new ObjectMap<Query, QueryView>(q =>\n    q.canonicalId()\n  );\n  private queryViewsByTarget: { [targetId: number]: QueryView } = {};\n  private limboTargetsByKey = new SortedMap<DocumentKey, TargetId>(\n    DocumentKey.comparator\n  );\n  private limboKeysByTarget: { [targetId: number]: DocumentKey } = {};\n  private limboDocumentRefs = new ReferenceSet();\n  private limboCollector = new EagerGarbageCollector();\n  /** Stores user completion handlers, indexed by User and BatchId. */\n  private mutationUserCallbacks = {} as {\n    [uidKey: string]: SortedMap<BatchId, Deferred<void>>;\n  };\n  private targetIdGenerator = TargetIdGenerator.forSyncEngine();\n\n  constructor(\n    private localStore: LocalStore,\n    private remoteStore: RemoteStore,\n    private currentUser: User\n  ) {}\n\n  /** Subscribes view and error handler. Can be called only once. */\n  subscribe(viewHandler: ViewHandler, errorHandler: ErrorHandler): void {\n    assert(\n      viewHandler !== null && errorHandler !== null,\n      'View and error handlers cannot be null'\n    );\n    assert(\n      this.viewHandler === null && this.errorHandler === null,\n      'SyncEngine already has a subscriber.'\n    );\n    this.viewHandler = viewHandler;\n    this.errorHandler = errorHandler;\n    this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n  }\n\n  /**\n   * Initiates the new listen, resolves promise when listen enqueued to the\n   * server. All the subsequent view snapshots or errors are sent to the\n   * subscribed handlers. Returns the targetId of the query.\n   */\n  listen(query: Query): Promise<TargetId> {\n    this.assertSubscribed('listen()');\n    assert(\n      !this.queryViewsByQuery.has(query),\n      'We already listen to the query: ' + query\n    );\n\n    return this.localStore.allocateQuery(query).then(queryData => {\n      return this.localStore\n        .executeQuery(query)\n        .then(docs => {\n          return this.localStore\n            .remoteDocumentKeys(queryData.targetId)\n            .then(remoteKeys => {\n              const view = new View(query, remoteKeys);\n              const viewDocChanges = view.computeDocChanges(docs);\n              const viewChange = view.applyChanges(viewDocChanges);\n              assert(\n                viewChange.limboChanges.length === 0,\n                'View returned limbo docs before target ack from the server.'\n              );\n              assert(\n                !!viewChange.snapshot,\n                'applyChanges for new view should always return a snapshot'\n              );\n\n              const data = new QueryView(\n                query,\n                queryData.targetId,\n                queryData.resumeToken,\n                view\n              );\n              this.queryViewsByQuery.set(query, data);\n              this.queryViewsByTarget[queryData.targetId] = data;\n              this.viewHandler!([viewChange.snapshot!]);\n              this.remoteStore.listen(queryData);\n            });\n        })\n        .then(() => {\n          return queryData.targetId;\n        });\n    });\n  }\n\n  /** Stops listening to the query. */\n  unlisten(query: Query): Promise<void> {\n    this.assertSubscribed('unlisten()');\n\n    const queryView = this.queryViewsByQuery.get(query)!;\n    assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n\n    return this.localStore.releaseQuery(query).then(() => {\n      this.remoteStore.unlisten(queryView.targetId);\n      return this.removeAndCleanupQuery(queryView).then(() => {\n        return this.localStore.collectGarbage();\n      });\n    });\n  }\n\n  /**\n   * Initiates the write of local mutation batch which involves adding the\n   * writes to the mutation queue, notifying the remote store about new\n   * mutations and raising events for any changes this write caused.\n   *\n   * The promise returned by this call is resolved when the above steps\n   * have completed, *not* when the write was acked by the backend. The\n   * userCallback is resolved once the write was acked/rejected by the\n   * backend (or failed locally for any other reason).\n   */\n  write(batch: Mutation[], userCallback: Deferred<void>): Promise<void> {\n    this.assertSubscribed('write()');\n    return this.localStore\n      .localWrite(batch)\n      .then(result => {\n        this.addMutationCallback(result.batchId, userCallback);\n        return this.emitNewSnapsAndNotifyLocalStore(result.changes);\n      })\n      .then(() => {\n        return this.remoteStore.fillWritePipeline();\n      });\n  }\n\n  // TODO(klimt): Wrap the given error in a standard Firestore error object.\n  private wrapUpdateFunctionError(error: AnyJs): AnyJs {\n    return error;\n  }\n\n  /**\n   * Takes an updateFunction in which a set of reads and writes can be performed\n   * atomically. In the updateFunction, the client can read and write values\n   * using the supplied transaction object. After the updateFunction, all\n   * changes will be committed. If some other client has changed any of the data\n   * referenced, then the updateFunction will be called again. If the\n   * updateFunction still fails after the given number of retries, then the\n   * transaction will be rejection.\n   *\n   * The transaction object passed to the updateFunction contains methods for\n   * accessing documents and collections. Unlike other datastore access, data\n   * accessed with the transaction will not reflect local changes that have not\n   * been committed. For this reason, it is required that all reads are\n   * performed before any writes. Transactions must be performed while online.\n   *\n   * The promise returned is resolved when the transaction is fully committed.\n   */\n  runTransaction<T>(\n    updateFunction: (transaction: Transaction) => Promise<T>,\n    retries = 5\n  ): Promise<T> {\n    assert(retries >= 0, 'Got negative number of retries for transaction.');\n    const transaction = this.remoteStore.createTransaction();\n    const wrappedUpdateFunction = () => {\n      try {\n        const userPromise = updateFunction(transaction);\n        if (\n          isNullOrUndefined(userPromise) ||\n          !userPromise.catch ||\n          !userPromise.then\n        ) {\n          return Promise.reject<T>(\n            Error('Transaction callback must return a Promise')\n          );\n        }\n        return userPromise.catch(e => {\n          return Promise.reject<T>(this.wrapUpdateFunctionError(e));\n        });\n      } catch (e) {\n        return Promise.reject<T>(this.wrapUpdateFunctionError(e));\n      }\n    };\n    return wrappedUpdateFunction().then(result => {\n      return transaction\n        .commit()\n        .then(() => {\n          return result;\n        })\n        .catch(error => {\n          if (retries === 0) {\n            return Promise.reject<T>(error);\n          }\n          // TODO(klimt): Put in a retry delay?\n          return this.runTransaction(updateFunction, retries - 1);\n        });\n    });\n  }\n\n  applyRemoteEvent(remoteEvent: RemoteEvent): Promise<void> {\n    this.assertSubscribed('applyRemoteEvent()');\n\n    // Make sure limbo documents are deleted if there were no results\n    objUtils.forEachNumber(\n      remoteEvent.targetChanges,\n      (targetId, targetChange) => {\n        const limboKey = this.limboKeysByTarget[targetId];\n        if (\n          limboKey &&\n          targetChange.currentStatusUpdate ===\n            CurrentStatusUpdate.MarkCurrent &&\n          !remoteEvent.documentUpdates.get(limboKey)\n        ) {\n          // When listening to a query the server responds with a snapshot\n          // containing documents matching the query and a current marker\n          // telling us we're now in sync. It's possible for these to arrive\n          // as separate remote events or as a single remote event.\n          // For a document query, there will be no documents sent in the\n          // response if the document doesn't exist.\n          //\n          // If the snapshot arrives separately from the current marker,\n          // we handle it normally and updateTrackedLimbos will resolve the\n          // limbo status of the document, removing it from limboDocumentRefs.\n          // This works because clients only initiate limbo resolution when\n          // a target is current and because all current targets are\n          // always at a consistent snapshot.\n          //\n          // However, if the document doesn't exist and the current marker\n          // arrives, the document is not present in the snapshot and our\n          // normal view handling would consider the document to remain in\n          // limbo indefinitely because there are no updates to the document.\n          // To avoid this, we specially handle this just this case here:\n          // synthesizing a delete.\n          //\n          // TODO(dimond): Ideally we would have an explicit lookup query\n          // instead resulting in an explicit delete message and we could\n          // remove this special logic.\n          remoteEvent.addDocumentUpdate(\n            new NoDocument(limboKey, remoteEvent.snapshotVersion)\n          );\n        }\n      }\n    );\n\n    return this.localStore.applyRemoteEvent(remoteEvent).then(changes => {\n      return this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n    });\n  }\n\n  rejectListen(targetId: TargetId, err: FirestoreError): Promise<void> {\n    this.assertSubscribed('rejectListens()');\n    const limboKey = this.limboKeysByTarget[targetId];\n    if (limboKey) {\n      // Since this query failed, we won't want to manually unlisten to it.\n      // So go ahead and remove it from bookkeeping.\n      this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n      delete this.limboKeysByTarget[targetId];\n\n      // TODO(klimt): We really only should do the following on permission\n      // denied errors, but we don't have the cause code here.\n\n      // It's a limbo doc. Create a synthetic event saying it was deleted.\n      // This is kind of a hack. Ideally, we would have a method in the local\n      // store to purge a document. However, it would be tricky to keep all of\n      // the local store's invariants with another method.\n      let docMap = new SortedMap<DocumentKey, MaybeDocument>(\n        DocumentKey.comparator\n      );\n      docMap = docMap.insert(\n        limboKey,\n        new NoDocument(limboKey, SnapshotVersion.forDeletedDoc())\n      );\n      const event = new RemoteEvent(SnapshotVersion.MIN, {}, docMap);\n      return this.applyRemoteEvent(event);\n    } else {\n      const queryView = this.queryViewsByTarget[targetId];\n      assert(!!queryView, 'Unknown targetId: ' + targetId);\n      return this.localStore.releaseQuery(queryView.query).then(() => {\n        return this.removeAndCleanupQuery(queryView).then(() => {\n          this.errorHandler!(queryView.query, err);\n        });\n      });\n    }\n  }\n\n  applySuccessfulWrite(\n    mutationBatchResult: MutationBatchResult\n  ): Promise<void> {\n    this.assertSubscribed('applySuccessfulWrite()');\n\n    // The local store may or may not be able to apply the write result and\n    // raise events immediately (depending on whether the watcher is caught\n    // up), so we raise user callbacks first so that they consistently happen\n    // before listen events.\n    this.processUserCallback(\n      mutationBatchResult.batch.batchId,\n      /*error=*/ null\n    );\n\n    return this.localStore\n      .acknowledgeBatch(mutationBatchResult)\n      .then(changes => {\n        return this.emitNewSnapsAndNotifyLocalStore(changes);\n      });\n  }\n\n  rejectFailedWrite(batchId: BatchId, error: FirestoreError): Promise<void> {\n    this.assertSubscribed('rejectFailedWrite()');\n\n    // The local store may or may not be able to apply the write result and\n    // raise events immediately (depending on whether the watcher is caught up),\n    // so we raise user callbacks first so that they consistently happen before\n    // listen events.\n    this.processUserCallback(batchId, error);\n\n    return this.localStore.rejectBatch(batchId).then(changes => {\n      return this.emitNewSnapsAndNotifyLocalStore(changes);\n    });\n  }\n\n  private addMutationCallback(\n    batchId: BatchId,\n    callback: Deferred<void>\n  ): void {\n    let newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n    if (!newCallbacks) {\n      newCallbacks = new SortedMap<BatchId, Deferred<void>>(\n        primitiveComparator\n      );\n    }\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n  }\n\n  /**\n   * Resolves or rejects the user callback for the given batch and then discards\n   * it.\n   */\n  private processUserCallback(batchId: BatchId, error: Error | null): void {\n    let newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n    if (newCallbacks) {\n      const callback = newCallbacks.get(batchId);\n      if (callback) {\n        assert(\n          batchId === newCallbacks.minKey(),\n          'Mutation callbacks processed out-of-order?'\n        );\n        if (error) {\n          callback.reject(error);\n        } else {\n          callback.resolve();\n        }\n        newCallbacks = newCallbacks.remove(batchId);\n      }\n      this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    }\n  }\n\n  private removeAndCleanupQuery(queryView: QueryView): Promise<void> {\n    this.queryViewsByQuery.delete(queryView.query);\n    delete this.queryViewsByTarget[queryView.targetId];\n\n    this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n    return this.gcLimboDocuments();\n  }\n\n  private updateTrackedLimbos(\n    targetId: TargetId,\n    limboChanges: LimboDocumentChange[]\n  ): Promise<void> {\n    for (const limboChange of limboChanges) {\n      if (limboChange instanceof AddedLimboDocument) {\n        this.limboDocumentRefs.addReference(limboChange.key, targetId);\n        this.trackLimboChange(limboChange);\n      } else if (limboChange instanceof RemovedLimboDocument) {\n        log.debug(LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n        this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n      } else {\n        fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n      }\n    }\n    return this.gcLimboDocuments();\n  }\n\n  private trackLimboChange(limboChange: AddedLimboDocument): void {\n    const key = limboChange.key;\n    if (!this.limboTargetsByKey.get(key)) {\n      log.debug(LOG_TAG, 'New document in limbo: ' + key);\n      const limboTargetId = this.targetIdGenerator.next();\n      const query = Query.atPath(key.path);\n      this.limboKeysByTarget[limboTargetId] = key;\n      this.remoteStore.listen(\n        new QueryData(query, limboTargetId, QueryPurpose.Listen)\n      );\n      this.limboTargetsByKey = this.limboTargetsByKey.insert(\n        key,\n        limboTargetId\n      );\n    }\n  }\n\n  private gcLimboDocuments(): Promise<void> {\n    // HACK: We can use a null transaction here, because we know that the\n    // reference set is entirely within memory and doesn't need a store engine.\n    return this.limboCollector\n      .collectGarbage(null)\n      .next(keys => {\n        keys.forEach(key => {\n          const limboTargetId = this.limboTargetsByKey.get(key);\n          if (limboTargetId === null) {\n            // This target already got removed, because the query failed.\n            return;\n          }\n          this.remoteStore.unlisten(limboTargetId);\n          this.limboTargetsByKey = this.limboTargetsByKey.remove(key);\n          delete this.limboKeysByTarget[limboTargetId];\n        });\n      })\n      .toPromise();\n  }\n\n  // Visible for testing\n  currentLimboDocs(): SortedMap<DocumentKey, TargetId> {\n    return this.limboTargetsByKey;\n  }\n\n  private emitNewSnapsAndNotifyLocalStore(\n    changes: MaybeDocumentMap,\n    remoteEvent?: RemoteEvent\n  ): Promise<void> {\n    const newSnaps: ViewSnapshot[] = [];\n    const docChangesInAllViews: LocalViewChanges[] = [];\n    const queriesProcessed: Array<Promise<void>> = [];\n\n    this.queryViewsByQuery.forEach((_, queryView) => {\n      queriesProcessed.push(\n        Promise.resolve()\n          .then(() => {\n            const viewDocChanges = queryView.view.computeDocChanges(changes);\n            if (!viewDocChanges.needsRefill) {\n              return viewDocChanges;\n            }\n            // The query has a limit and some docs were removed, so we need\n            // to re-run the query against the local store to make sure we\n            // didn't lose any good docs that had been past the limit.\n            return this.localStore.executeQuery(queryView.query).then(docs => {\n              return queryView.view.computeDocChanges(docs, viewDocChanges);\n            });\n          })\n          .then((viewDocChanges: ViewDocumentChanges) => {\n            const targetChange =\n              remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n            const viewChange = queryView.view.applyChanges(\n              viewDocChanges,\n              targetChange\n            );\n            return this.updateTrackedLimbos(\n              queryView.targetId,\n              viewChange.limboChanges\n            ).then(() => {\n              if (viewChange.snapshot) {\n                newSnaps.push(viewChange.snapshot);\n                const docChanges = LocalViewChanges.fromSnapshot(\n                  viewChange.snapshot\n                );\n                docChangesInAllViews.push(docChanges);\n              }\n            });\n          })\n      );\n    });\n\n    return Promise.all(queriesProcessed)\n      .then(() => {\n        this.viewHandler!(newSnaps);\n        return this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n      })\n      .then(() => {\n        return this.localStore.collectGarbage();\n      });\n  }\n\n  private assertSubscribed(fnName: string): void {\n    assert(\n      this.viewHandler !== null && this.errorHandler !== null,\n      'Trying to call ' + fnName + ' before calling subscribe().'\n    );\n  }\n\n  handleUserChange(user: User): Promise<void> {\n    this.currentUser = user;\n    return this.localStore\n      .handleUserChange(user)\n      .then(changes => {\n        return this.emitNewSnapsAndNotifyLocalStore(changes);\n      })\n      .then(() => {\n        return this.remoteStore.handleUserChange(user);\n      });\n  }\n}\n","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { LocalViewChanges } from '../local/local_view_changes';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { ReferenceSet } from '../local/reference_set';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { CurrentStatusUpdate, RemoteEvent } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport { primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\nimport { SortedMap } from '../util/sorted_map';\nimport { isNullOrUndefined } from '../util/types';\nimport { PromiseImpl as Promise } from '../../utils/promise';\nimport { Query } from './query';\nimport { SnapshotVersion } from './snapshot_version';\nimport { TargetIdGenerator } from './target_id_generator';\nimport { AddedLimboDocument, RemovedLimboDocument, View } from './view';\nvar LOG_TAG = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nvar QueryView = /** @class */ (function () {\n    function QueryView(\n        /**\n         * The query itself.\n         */\n        query, \n        /**\n         * The target number created by the client that is used in the watch\n         * stream to identify this query.\n         */\n        targetId, \n        /**\n         * An identifier from the datastore backend that indicates the last state\n         * of the results that was received. This can be used to indicate where\n         * to continue receiving new doc changes for the query.\n         */\n        resumeToken, \n        /**\n         * The view is responsible for computing the final merged truth of what\n         * docs are in the query. It gets notified of local and remote changes,\n         * and applies the query filters and limits to determine the most correct\n         * possible results.\n         */\n        view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.resumeToken = resumeToken;\n        this.view = view;\n    }\n    return QueryView;\n}());\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngine’s methods should only ever be called by methods running in the\n * global async queue.\n */\nvar SyncEngine = /** @class */ (function () {\n    function SyncEngine(localStore, remoteStore, currentUser) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.currentUser = currentUser;\n        this.viewHandler = null;\n        this.errorHandler = null;\n        this.queryViewsByQuery = new ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.queryViewsByTarget = {};\n        this.limboTargetsByKey = new SortedMap(DocumentKey.comparator);\n        this.limboKeysByTarget = {};\n        this.limboDocumentRefs = new ReferenceSet();\n        this.limboCollector = new EagerGarbageCollector();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        this.targetIdGenerator = TargetIdGenerator.forSyncEngine();\n    }\n    /** Subscribes view and error handler. Can be called only once. */\n    SyncEngine.prototype.subscribe = function (viewHandler, errorHandler) {\n        assert(viewHandler !== null && errorHandler !== null, 'View and error handlers cannot be null');\n        assert(this.viewHandler === null && this.errorHandler === null, 'SyncEngine already has a subscriber.');\n        this.viewHandler = viewHandler;\n        this.errorHandler = errorHandler;\n        this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n    };\n    /**\n     * Initiates the new listen, resolves promise when listen enqueued to the\n     * server. All the subsequent view snapshots or errors are sent to the\n     * subscribed handlers. Returns the targetId of the query.\n     */\n    SyncEngine.prototype.listen = function (query) {\n        var _this = this;\n        this.assertSubscribed('listen()');\n        assert(!this.queryViewsByQuery.has(query), 'We already listen to the query: ' + query);\n        return this.localStore.allocateQuery(query).then(function (queryData) {\n            return _this.localStore\n                .executeQuery(query)\n                .then(function (docs) {\n                return _this.localStore\n                    .remoteDocumentKeys(queryData.targetId)\n                    .then(function (remoteKeys) {\n                    var view = new View(query, remoteKeys);\n                    var viewDocChanges = view.computeDocChanges(docs);\n                    var viewChange = view.applyChanges(viewDocChanges);\n                    assert(viewChange.limboChanges.length === 0, 'View returned limbo docs before target ack from the server.');\n                    assert(!!viewChange.snapshot, 'applyChanges for new view should always return a snapshot');\n                    var data = new QueryView(query, queryData.targetId, queryData.resumeToken, view);\n                    _this.queryViewsByQuery.set(query, data);\n                    _this.queryViewsByTarget[queryData.targetId] = data;\n                    _this.viewHandler([viewChange.snapshot]);\n                    _this.remoteStore.listen(queryData);\n                });\n            })\n                .then(function () {\n                return queryData.targetId;\n            });\n        });\n    };\n    /** Stops listening to the query. */\n    SyncEngine.prototype.unlisten = function (query) {\n        var _this = this;\n        this.assertSubscribed('unlisten()');\n        var queryView = this.queryViewsByQuery.get(query);\n        assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n        return this.localStore.releaseQuery(query).then(function () {\n            _this.remoteStore.unlisten(queryView.targetId);\n            return _this.removeAndCleanupQuery(queryView).then(function () {\n                return _this.localStore.collectGarbage();\n            });\n        });\n    };\n    /**\n     * Initiates the write of local mutation batch which involves adding the\n     * writes to the mutation queue, notifying the remote store about new\n     * mutations and raising events for any changes this write caused.\n     *\n     * The promise returned by this call is resolved when the above steps\n     * have completed, *not* when the write was acked by the backend. The\n     * userCallback is resolved once the write was acked/rejected by the\n     * backend (or failed locally for any other reason).\n     */\n    SyncEngine.prototype.write = function (batch, userCallback) {\n        var _this = this;\n        this.assertSubscribed('write()');\n        return this.localStore\n            .localWrite(batch)\n            .then(function (result) {\n            _this.addMutationCallback(result.batchId, userCallback);\n            return _this.emitNewSnapsAndNotifyLocalStore(result.changes);\n        })\n            .then(function () {\n            return _this.remoteStore.fillWritePipeline();\n        });\n    };\n    // TODO(klimt): Wrap the given error in a standard Firestore error object.\n    SyncEngine.prototype.wrapUpdateFunctionError = function (error) {\n        return error;\n    };\n    /**\n     * Takes an updateFunction in which a set of reads and writes can be performed\n     * atomically. In the updateFunction, the client can read and write values\n     * using the supplied transaction object. After the updateFunction, all\n     * changes will be committed. If some other client has changed any of the data\n     * referenced, then the updateFunction will be called again. If the\n     * updateFunction still fails after the given number of retries, then the\n     * transaction will be rejection.\n     *\n     * The transaction object passed to the updateFunction contains methods for\n     * accessing documents and collections. Unlike other datastore access, data\n     * accessed with the transaction will not reflect local changes that have not\n     * been committed. For this reason, it is required that all reads are\n     * performed before any writes. Transactions must be performed while online.\n     *\n     * The promise returned is resolved when the transaction is fully committed.\n     */\n    SyncEngine.prototype.runTransaction = function (updateFunction, retries) {\n        var _this = this;\n        if (retries === void 0) { retries = 5; }\n        assert(retries >= 0, 'Got negative number of retries for transaction.');\n        var transaction = this.remoteStore.createTransaction();\n        var wrappedUpdateFunction = function () {\n            try {\n                var userPromise = updateFunction(transaction);\n                if (isNullOrUndefined(userPromise) ||\n                    !userPromise.catch ||\n                    !userPromise.then) {\n                    return Promise.reject(Error('Transaction callback must return a Promise'));\n                }\n                return userPromise.catch(function (e) {\n                    return Promise.reject(_this.wrapUpdateFunctionError(e));\n                });\n            }\n            catch (e) {\n                return Promise.reject(_this.wrapUpdateFunctionError(e));\n            }\n        };\n        return wrappedUpdateFunction().then(function (result) {\n            return transaction\n                .commit()\n                .then(function () {\n                return result;\n            })\n                .catch(function (error) {\n                if (retries === 0) {\n                    return Promise.reject(error);\n                }\n                // TODO(klimt): Put in a retry delay?\n                return _this.runTransaction(updateFunction, retries - 1);\n            });\n        });\n    };\n    SyncEngine.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        this.assertSubscribed('applyRemoteEvent()');\n        // Make sure limbo documents are deleted if there were no results\n        objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, targetChange) {\n            var limboKey = _this.limboKeysByTarget[targetId];\n            if (limboKey &&\n                targetChange.currentStatusUpdate ===\n                    CurrentStatusUpdate.MarkCurrent &&\n                !remoteEvent.documentUpdates.get(limboKey)) {\n                // When listening to a query the server responds with a snapshot\n                // containing documents matching the query and a current marker\n                // telling us we're now in sync. It's possible for these to arrive\n                // as separate remote events or as a single remote event.\n                // For a document query, there will be no documents sent in the\n                // response if the document doesn't exist.\n                //\n                // If the snapshot arrives separately from the current marker,\n                // we handle it normally and updateTrackedLimbos will resolve the\n                // limbo status of the document, removing it from limboDocumentRefs.\n                // This works because clients only initiate limbo resolution when\n                // a target is current and because all current targets are\n                // always at a consistent snapshot.\n                //\n                // However, if the document doesn't exist and the current marker\n                // arrives, the document is not present in the snapshot and our\n                // normal view handling would consider the document to remain in\n                // limbo indefinitely because there are no updates to the document.\n                // To avoid this, we specially handle this just this case here:\n                // synthesizing a delete.\n                //\n                // TODO(dimond): Ideally we would have an explicit lookup query\n                // instead resulting in an explicit delete message and we could\n                // remove this special logic.\n                remoteEvent.addDocumentUpdate(new NoDocument(limboKey, remoteEvent.snapshotVersion));\n            }\n        });\n        return this.localStore.applyRemoteEvent(remoteEvent).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n        });\n    };\n    SyncEngine.prototype.rejectListen = function (targetId, err) {\n        var _this = this;\n        this.assertSubscribed('rejectListens()');\n        var limboKey = this.limboKeysByTarget[targetId];\n        if (limboKey) {\n            // Since this query failed, we won't want to manually unlisten to it.\n            // So go ahead and remove it from bookkeeping.\n            this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n            delete this.limboKeysByTarget[targetId];\n            // TODO(klimt): We really only should do the following on permission\n            // denied errors, but we don't have the cause code here.\n            // It's a limbo doc. Create a synthetic event saying it was deleted.\n            // This is kind of a hack. Ideally, we would have a method in the local\n            // store to purge a document. However, it would be tricky to keep all of\n            // the local store's invariants with another method.\n            var docMap = new SortedMap(DocumentKey.comparator);\n            docMap = docMap.insert(limboKey, new NoDocument(limboKey, SnapshotVersion.forDeletedDoc()));\n            var event_1 = new RemoteEvent(SnapshotVersion.MIN, {}, docMap);\n            return this.applyRemoteEvent(event_1);\n        }\n        else {\n            var queryView_1 = this.queryViewsByTarget[targetId];\n            assert(!!queryView_1, 'Unknown targetId: ' + targetId);\n            return this.localStore.releaseQuery(queryView_1.query).then(function () {\n                return _this.removeAndCleanupQuery(queryView_1).then(function () {\n                    _this.errorHandler(queryView_1.query, err);\n                });\n            });\n        }\n    };\n    SyncEngine.prototype.applySuccessfulWrite = function (mutationBatchResult) {\n        var _this = this;\n        this.assertSubscribed('applySuccessfulWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        this.processUserCallback(mutationBatchResult.batch.batchId, \n        /*error=*/ null);\n        return this.localStore\n            .acknowledgeBatch(mutationBatchResult)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.rejectFailedWrite = function (batchId, error) {\n        var _this = this;\n        this.assertSubscribed('rejectFailedWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        this.processUserCallback(batchId, error);\n        return this.localStore.rejectBatch(batchId).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.addMutationCallback = function (batchId, callback) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        if (!newCallbacks) {\n            newCallbacks = new SortedMap(primitiveComparator);\n        }\n        newCallbacks = newCallbacks.insert(batchId, callback);\n        this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    };\n    /**\n     * Resolves or rejects the user callback for the given batch and then discards\n     * it.\n     */\n    SyncEngine.prototype.processUserCallback = function (batchId, error) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        // NOTE: Mutations restored from persistence won't have callbacks, so it's\n        // okay for there to be no callback for this ID.\n        if (newCallbacks) {\n            var callback = newCallbacks.get(batchId);\n            if (callback) {\n                assert(batchId === newCallbacks.minKey(), 'Mutation callbacks processed out-of-order?');\n                if (error) {\n                    callback.reject(error);\n                }\n                else {\n                    callback.resolve();\n                }\n                newCallbacks = newCallbacks.remove(batchId);\n            }\n            this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n        }\n    };\n    SyncEngine.prototype.removeAndCleanupQuery = function (queryView) {\n        this.queryViewsByQuery.delete(queryView.query);\n        delete this.queryViewsByTarget[queryView.targetId];\n        this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.updateTrackedLimbos = function (targetId, limboChanges) {\n        for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {\n            var limboChange = limboChanges_1[_i];\n            if (limboChange instanceof AddedLimboDocument) {\n                this.limboDocumentRefs.addReference(limboChange.key, targetId);\n                this.trackLimboChange(limboChange);\n            }\n            else if (limboChange instanceof RemovedLimboDocument) {\n                log.debug(LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n                this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            }\n            else {\n                fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n            }\n        }\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.trackLimboChange = function (limboChange) {\n        var key = limboChange.key;\n        if (!this.limboTargetsByKey.get(key)) {\n            log.debug(LOG_TAG, 'New document in limbo: ' + key);\n            var limboTargetId = this.targetIdGenerator.next();\n            var query = Query.atPath(key.path);\n            this.limboKeysByTarget[limboTargetId] = key;\n            this.remoteStore.listen(new QueryData(query, limboTargetId, QueryPurpose.Listen));\n            this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);\n        }\n    };\n    SyncEngine.prototype.gcLimboDocuments = function () {\n        var _this = this;\n        // HACK: We can use a null transaction here, because we know that the\n        // reference set is entirely within memory and doesn't need a store engine.\n        return this.limboCollector\n            .collectGarbage(null)\n            .next(function (keys) {\n            keys.forEach(function (key) {\n                var limboTargetId = _this.limboTargetsByKey.get(key);\n                if (limboTargetId === null) {\n                    // This target already got removed, because the query failed.\n                    return;\n                }\n                _this.remoteStore.unlisten(limboTargetId);\n                _this.limboTargetsByKey = _this.limboTargetsByKey.remove(key);\n                delete _this.limboKeysByTarget[limboTargetId];\n            });\n        })\n            .toPromise();\n    };\n    // Visible for testing\n    SyncEngine.prototype.currentLimboDocs = function () {\n        return this.limboTargetsByKey;\n    };\n    SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function (changes, remoteEvent) {\n        var _this = this;\n        var newSnaps = [];\n        var docChangesInAllViews = [];\n        var queriesProcessed = [];\n        this.queryViewsByQuery.forEach(function (_, queryView) {\n            queriesProcessed.push(Promise.resolve()\n                .then(function () {\n                var viewDocChanges = queryView.view.computeDocChanges(changes);\n                if (!viewDocChanges.needsRefill) {\n                    return viewDocChanges;\n                }\n                // The query has a limit and some docs were removed, so we need\n                // to re-run the query against the local store to make sure we\n                // didn't lose any good docs that had been past the limit.\n                return _this.localStore.executeQuery(queryView.query).then(function (docs) {\n                    return queryView.view.computeDocChanges(docs, viewDocChanges);\n                });\n            })\n                .then(function (viewDocChanges) {\n                var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n                var viewChange = queryView.view.applyChanges(viewDocChanges, targetChange);\n                return _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges).then(function () {\n                    if (viewChange.snapshot) {\n                        newSnaps.push(viewChange.snapshot);\n                        var docChanges = LocalViewChanges.fromSnapshot(viewChange.snapshot);\n                        docChangesInAllViews.push(docChanges);\n                    }\n                });\n            }));\n        });\n        return Promise.all(queriesProcessed)\n            .then(function () {\n            _this.viewHandler(newSnaps);\n            return _this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n        })\n            .then(function () {\n            return _this.localStore.collectGarbage();\n        });\n    };\n    SyncEngine.prototype.assertSubscribed = function (fnName) {\n        assert(this.viewHandler !== null && this.errorHandler !== null, 'Trying to call ' + fnName + ' before calling subscribe().');\n    };\n    SyncEngine.prototype.handleUserChange = function (user) {\n        var _this = this;\n        this.currentUser = user;\n        return this.localStore\n            .handleUserChange(user)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        })\n            .then(function () {\n            return _this.remoteStore.handleUserChange(user);\n        });\n    };\n    return SyncEngine;\n}());\nexport { SyncEngine };\n\n\n"]}