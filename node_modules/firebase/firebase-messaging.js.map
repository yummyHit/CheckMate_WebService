{"version":3,"sources":["webpack:///firebase-messaging.js","webpack:///./src/messaging/helpers/array-buffer-to-base64.ts","webpack:///./src/messaging.ts","webpack:///./src/messaging/models/errors.ts","webpack:///./src/messaging/models/fcm-details.ts","webpack:///./src/messaging/models/token-manager.ts","webpack:///./src/messaging/controllers/controller-interface.ts","webpack:///./src/messaging/models/worker-page-message.ts","webpack:///./src/messaging/models/default-sw.ts","webpack:///./src/messaging/controllers/window-controller.ts","webpack:///./src/messaging/controllers/sw-controller.ts"],"names":["webpackJsonpFirebase","61","module","__webpack_exports__","__webpack_require__","toBase64","arrayBuffer","uint8Version","Uint8Array","window","btoa","String","fromCharCode","apply","registerMessaging","instance","factoryMethod","app","self","sw_controller","window_controller","namespaceExports","Messaging","INTERNAL","registerService","Object","defineProperty","value","_a","errors","CODES","AVAILABLE_IN_WINDOW","AVAILABLE_IN_SW","SHOULD_BE_INHERITED","BAD_SENDER_ID","INCORRECT_GCM_SENDER_ID","PERMISSION_DEFAULT","PERMISSION_BLOCKED","UNSUPPORTED_BROWSER","NOTIFICATIONS_BLOCKED","FAILED_DEFAULT_REGISTRATION","SW_REGISTRATION_EXPECTED","GET_SUBSCRIPTION_FAILED","INVALID_SAVED_TOKEN","SW_REG_REDUNDANT","TOKEN_SUBSCRIBE_FAILED","TOKEN_SUBSCRIBE_NO_TOKEN","TOKEN_SUBSCRIBE_NO_PUSH_SET","USE_SW_BEFORE_GET_TOKEN","INVALID_DELETE_TOKEN","DELETE_TOKEN_NOT_FOUND","DELETE_SCOPE_NOT_FOUND","BG_HANDLER_FUNCTION_EXPECTED","NO_WINDOW_CLIENT_TO_MSG","UNABLE_TO_RESUBSCRIBE","NO_FCM_TOKEN_FOR_RESUBSCRIBE","FAILED_TO_DELETE_TOKEN","NO_SW_IN_REG","BAD_SCOPE","BAD_VAPID_KEY","BAD_SUBSCRIPTION","BAD_TOKEN","BAD_PUSH_SET","FAILED_DELETE_VAPID_KEY","ERROR_MAP","models_errors","codes","map","array_buffer_to_base64","replace","FCM_APPLICATION_SERVER_KEY","SUBSCRIPTION_DETAILS","userVisibleOnly","applicationServerKey","fcm_details","ENDPOINT","APPLICATION_SERVER_KEY","SUBSCRIPTION_OPTIONS","FCM_TOKEN_OBJ_STORE","token_manager_TokenManager","TokenManager","this","errorFactory_","openDbPromise_","prototype","openDatabase_","Promise","resolve","reject","request","indexedDB","open","onerror","event","target","error","onsuccess","result","onupgradeneeded","db","objectStore","createObjectStore","keyPath","createIndex","unique","closeDatabase","_this","then","close","getTokenDetailsFromToken","fcmToken","transaction","index","get","getTokenDetailsFromSWScope_","swScope","scopeRequest","getAllTokenDetailsForSenderId_","senderId","senderIdTokens","cursorRequest","openCursor","cursor","push","continue","subscribeToFCM","subscription","pushSet","p256dh","auth","fcmSubscribeBody","endpoint","headers","Headers","append","subscribeOptions","method","body","fetch","response","json","fcmTokenResponse","message","create","token","isSameSubscription_","masterTokenDetails","saveTokenDetails_","swRegistration","fcmPushSet","details","scope","fcmSenderId","put","getSavedToken","ServiceWorkerRegistration","length","allTokenDetails","findIndex","tokenDetails","pushManager","getSubscription","catch","err","createToken","fcmTokenDetails","subscribe","sub","deleteToken","delete","token_manager","SENDER_ID_OPTION_NAME","controller_interface_ControllerInterface","ControllerInterface","options","messagingSenderId_","tokenManager_","getToken","currentPermission","getNotificationPermission_","notification_permission","getSWRegistration_","registration","unsubscribe","requestPermission","useServiceWorker","onMessage","nextOrObserver","optError","optCompleted","onTokenRefresh","setBackgroundMessageHandler","callback","Notification","permission","getTokenManager","controller_interface","PARAMS","TYPE_OF_MSG","DATA","msgType","PUSH_MSG_RECEIVED","NOTIFICATION_CLICKED","createNewMsg","msgData","worker_page_message","TYPES_OF_MSG","default_sw","path","__extends","extendStatics","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","window_controller_WindowController","_super","WindowController","call","registrationToUse_","manifestCheckPromise_","messageObserver_","onMessage_","observer","tokenRefreshObserver_","onTokenRefresh_","setupSWMessageListener_","isSupported_","manifestCheck_","manifestTag","document","querySelector","href","manifestContent","managePermissionResult","permissionPromise","waitForRegistrationToActivate_","serviceWorker","installing","waiting","active","state","stateChangeListener","removeEventListener","addEventListener","navigator","register","browserErrorMessage","update","data","workerPageMessage","pushMessage","next","PushSubscription","_typeof","Symbol","iterator","obj","sw_controller___extends","sw_controller_SWController","SWController","e","onPush_","onSubChange_","onNotificationClick_","bgMessageHandler_","msgPayload","handleMsgPromise","hasVisibleClients_","hasVisibleClients","notification","sendMessageToWindowClients_","notificationDetails","getNotificationData_","notificationTitle","title","showNotification","waitUntil","promiseChain","tokenManager","newSubscription","stopImmediatePropagation","clickAction","getWindowClient_","windowClient","clients","openWindow","internalMsg","attemptToMessageClient_","notificationInformation","assign","url","parsedURL","URL","matchAll","type","includeUncontrolled","clientList","suitableClient","i","focus","client","postMessage","some","visibilityState","all","src_app","Error"],"mappings":"AAAA,IACUA,sBAAsB,IAE1BC,GACA,SAAUC,EAAQC,EAAqBC,GAE7C,YCSA,SAAAC,GAA6BC,GAC3B,GAAkBC,GAAG,GAAcC,YAAcF,EAC3C,OAAOG,QAAKC,KAAOC,OAAaC,aAAMC,MAAK,KACnDN,ICGM,QAAAO,GAAoCC,GACxC,GACmBC,GAAG,SAAGC,GACpB,MAAKC,OAA8B,4BAASA,MACtC,GAAgBC,GACzBF,GAGO,GAAoBG,GAC7BH,IAEsBI,GAEXC,UACTF,EAEML,GAASQ,SAAgBC,gBAfC,YAiBnBR,EAGjBK,GFnCAI,OAAOC,eAAevB,EAAqB,cAAgBwB,OAAO,GAGlE,IA4DIC,GA5DAC,EAASzB,EAAoB,IGOtB0B,GACUC,oBAA4B,2BAChCC,gBAAwB,uBACpBC,oBAAuB,sBAC7BC,cAAiB,gBACPC,wBAA2B,0BAChCC,mBAAsB,qBACtBC,mBAAsB,qBACrBC,oBAAuB,sBACrBC,sBAAyB,wBACnBC,4BAAqC,oCACxCC,yBAA4B,2BAC7BC,wBAA2B,0BAC/BC,oBAAuB,sBAC1BC,iBAAoB,mBACdC,uBAA0B,yBACxBC,yBAA4B,2BACzBC,4BAA+B,8BACnCC,wBAA2B,0BAC9BC,qBAAwB,uBACtBC,uBAA0B,yBAC1BC,uBAA0B,yBACpBC,6BAAgC,+BACrCC,wBAA2B,0BAC7BC,sBAAyB,wBAClBC,6BAAgC,+BACtCC,uBAA0B,yBACpCC,aAAgB,eACnBC,UAAa,YACTC,cAAiB,gBACdC,iBAAoB,mBAC3BC,UAAa,YACVC,aAAgB,eACLC,wBACvB,2BAEaC,GAAApC,KACbA,EAAME,EAAoBC,qBAAkD,gDAC5EH,EAAME,EAAgBE,iBAC2B,wDACjDJ,EAAME,uBACiC,uDACvCF,EAAME,iBAC4C,+GAElDF,EAAME,sBAC4C,mEAClDF,EAAME,sBAC4C,iEAClDF,EAAME,uBACqC,2EAE3CF,EAAME,yBAA2D,mCACjEF,EAAME,EAA4BU,6BACA,+EAElCZ,EAAME,4BACoC,wDAC1CF,EAAME,2BACoC,yEAE1CF,EAAME,uBAAqE,+CAC3EF,EAAME,oBAC8C,6DACpDF,EAAME,0BACsC,kEAC5CF,EAAME,4BACqC,2DAC3CF,EAAME,+BAC+B,8DACrCF,EAAME,2BACsC,oGAE5CF,EAAME,wBAC+B,kFAErCF,EAAME,0BACuC,oFAE7CF,EAAME,0BACsC,mGAE5CF,EAAME,gCACW,iEACjBF,EAAME,2BAC+B,+DACrCF,EAAME,yBACsC,wIAG5CF,EAAME,gCAC0B,uHAGhCF,EAAME,0BAAuE,8CAC7EF,EAAME,gBAC8C,uHAEpDF,EAAME,2BACoC,2GAE1CF,EAAME,aACgD,yEAEtDF,EAAME,iBAC4C,qEAClDF,EAAME,oBAC+B,qDACrCF,EAAME,aAC8C,wEAEpDF,EAAME,gBACiD,kFAEvDF,EAAME,2BAAgE,sCACtEF,GAEFqC,GACOC,MAAOpC,EACTqC,IACHH,GFrHFI,EAAA,SAA0B9D,GAElB,MADuBD,GAAcC,GAChB+D,QAAK,KAAK,IAAQA,QAAM,MAAM,KAAQA,QAAM,MACzE,MGNgCC,GAC1B,EACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,EACA,IACA,GACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,EACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IAEJ,KAEwBC,GACTC,iBAAM,EACDC,qBAAE,GAAcjE,YACpC8D,IAEFI,GACUC,SAA8B,6BAChBC,uBAA4BN,EAC9BO,qBACpBN,GCtEuBO,EAA4B,yBAGrDC,EAAA,WAIE,QAAAC,KACMC,KAAcC,EAAG,GAAgBrD,GAAA,EAAY,YAAa,YAAQoC,EAAME,KACxEc,KAAeE,EACrB,KAmaF,MA5ZEH,GAAAI,UAAaC,EAAb,WACK,MAAKJ,MAAgBE,EACXF,KACbE,GAEIF,KAAeE,EAAA,GAAcG,SAAC,SAAQC,EAAQC,GAChD,GAAaC,GAAYC,UAAKC,KAxBgB,uBAEb,E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","file":"firebase-messaging.js","sourcesContent":["try {\n          webpackJsonpFirebase([3],{\n\n/***/ 61:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./src/app/errors.ts\nvar errors = __webpack_require__(24);\n\n// CONCATENATED MODULE: ./src/messaging/models/errors.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar CODES = {\n    AVAILABLE_IN_WINDOW: 'only-available-in-window',\n    AVAILABLE_IN_SW: 'only-available-in-sw',\n    SHOULD_BE_INHERITED: 'should-be-overriden',\n    BAD_SENDER_ID: 'bad-sender-id',\n    INCORRECT_GCM_SENDER_ID: 'incorrect-gcm-sender-id',\n    PERMISSION_DEFAULT: 'permission-default',\n    PERMISSION_BLOCKED: 'permission-blocked',\n    UNSUPPORTED_BROWSER: 'unsupported-browser',\n    NOTIFICATIONS_BLOCKED: 'notifications-blocked',\n    FAILED_DEFAULT_REGISTRATION: 'failed-serviceworker-registration',\n    SW_REGISTRATION_EXPECTED: 'sw-registration-expected',\n    GET_SUBSCRIPTION_FAILED: 'get-subscription-failed',\n    INVALID_SAVED_TOKEN: 'invalid-saved-token',\n    SW_REG_REDUNDANT: 'sw-reg-redundant',\n    TOKEN_SUBSCRIBE_FAILED: 'token-subscribe-failed',\n    TOKEN_SUBSCRIBE_NO_TOKEN: 'token-subscribe-no-token',\n    TOKEN_SUBSCRIBE_NO_PUSH_SET: 'token-subscribe-no-push-set',\n    USE_SW_BEFORE_GET_TOKEN: 'use-sw-before-get-token',\n    INVALID_DELETE_TOKEN: 'invalid-delete-token',\n    DELETE_TOKEN_NOT_FOUND: 'delete-token-not-found',\n    DELETE_SCOPE_NOT_FOUND: 'delete-scope-not-found',\n    BG_HANDLER_FUNCTION_EXPECTED: 'bg-handler-function-expected',\n    NO_WINDOW_CLIENT_TO_MSG: 'no-window-client-to-msg',\n    UNABLE_TO_RESUBSCRIBE: 'unable-to-resubscribe',\n    NO_FCM_TOKEN_FOR_RESUBSCRIBE: 'no-fcm-token-for-resubscribe',\n    FAILED_TO_DELETE_TOKEN: 'failed-to-delete-token',\n    NO_SW_IN_REG: 'no-sw-in-reg',\n    BAD_SCOPE: 'bad-scope',\n    BAD_VAPID_KEY: 'bad-vapid-key',\n    BAD_SUBSCRIPTION: 'bad-subscription',\n    BAD_TOKEN: 'bad-token',\n    BAD_PUSH_SET: 'bad-push-set',\n    FAILED_DELETE_VAPID_KEY: 'failed-delete-vapid-key'\n};\nvar ERROR_MAP = (_a = {}, _a[CODES.AVAILABLE_IN_WINDOW] = 'This method is available in a Window context.', _a[CODES.AVAILABLE_IN_SW] = 'This method is available in a service worker ' + 'context.', _a[CODES.SHOULD_BE_INHERITED] = 'This method should be overriden by ' + 'extended classes.', _a[CODES.BAD_SENDER_ID] = \"Please ensure that 'messagingSenderId' is set \" + 'correctly in the options passed into firebase.initializeApp().', _a[CODES.PERMISSION_DEFAULT] = 'The required permissions were not granted and ' + 'dismissed instead.', _a[CODES.PERMISSION_BLOCKED] = 'The required permissions were not granted and ' + 'blocked instead.', _a[CODES.UNSUPPORTED_BROWSER] = \"This browser doesn't support the API's \" + 'required to use the firebase SDK.', _a[CODES.NOTIFICATIONS_BLOCKED] = 'Notifications have been blocked.', _a[CODES.FAILED_DEFAULT_REGISTRATION] = 'We are unable to register the ' + 'default service worker. {$browserErrorMessage}', _a[CODES.SW_REGISTRATION_EXPECTED] = 'A service worker registration was the ' + 'expected input.', _a[CODES.GET_SUBSCRIPTION_FAILED] = 'There was an error when trying to get ' + 'any existing Push Subscriptions.', _a[CODES.INVALID_SAVED_TOKEN] = 'Unable to access details of the saved token.', _a[CODES.SW_REG_REDUNDANT] = 'The service worker being used for push was made ' + 'redundant.', _a[CODES.TOKEN_SUBSCRIBE_FAILED] = 'A problem occured while subscribing the ' + 'user to FCM: {$message}', _a[CODES.TOKEN_SUBSCRIBE_NO_TOKEN] = 'FCM returned no token when subscribing ' + 'the user to push.', _a[CODES.TOKEN_SUBSCRIBE_NO_PUSH_SET] = 'FCM returned an invalid response ' + 'when getting an FCM token.', _a[CODES.USE_SW_BEFORE_GET_TOKEN] = 'You must call useServiceWorker() before ' + 'calling getToken() to ensure your service worker is used.', _a[CODES.INVALID_DELETE_TOKEN] = 'You must pass a valid token into ' + 'deleteToken(), i.e. the token from getToken().', _a[CODES.DELETE_TOKEN_NOT_FOUND] = 'The deletion attempt for token could not ' + 'be performed as the token was not found.', _a[CODES.DELETE_SCOPE_NOT_FOUND] = 'The deletion attempt for service worker ' + 'scope could not be performed as the scope was not found.', _a[CODES.BG_HANDLER_FUNCTION_EXPECTED] = 'The input to ' + 'setBackgroundMessageHandler() must be a function.', _a[CODES.NO_WINDOW_CLIENT_TO_MSG] = 'An attempt was made to message a ' + 'non-existant window client.', _a[CODES.UNABLE_TO_RESUBSCRIBE] = 'There was an error while re-subscribing ' + 'the FCM token for push messaging. Will have to resubscribe the ' + 'user on next visit. {$message}', _a[CODES.NO_FCM_TOKEN_FOR_RESUBSCRIBE] = 'Could not find an FCM token ' + 'and as a result, unable to resubscribe. Will have to resubscribe the ' + 'user on next visit.', _a[CODES.FAILED_TO_DELETE_TOKEN] = 'Unable to delete the currently saved token.', _a[CODES.NO_SW_IN_REG] = 'Even though the service worker registration was ' + 'successful, there was a problem accessing the service worker itself.', _a[CODES.INCORRECT_GCM_SENDER_ID] = \"Please change your web app manifest's \" + \"'gcm_sender_id' value to '103953800507' to use Firebase messaging.\", _a[CODES.BAD_SCOPE] = 'The service worker scope must be a string with at ' + 'least one character.', _a[CODES.BAD_VAPID_KEY] = 'The public VAPID key must be a string with at ' + 'least one character.', _a[CODES.BAD_SUBSCRIPTION] = 'The subscription must be a valid ' + 'PushSubscription.', _a[CODES.BAD_TOKEN] = 'The FCM Token used for storage / lookup was not ' + 'a valid token string.', _a[CODES.BAD_PUSH_SET] = 'The FCM push set used for storage / lookup was not ' + 'not a valid push set string.', _a[CODES.FAILED_DELETE_VAPID_KEY] = 'The VAPID key could not be deleted.', _a);\n/* harmony default export */ var models_errors = ({\n    codes: CODES,\n    map: ERROR_MAP\n});\nvar _a;\n// CONCATENATED MODULE: ./src/messaging/helpers/array-buffer-to-base64.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction toBase64(arrayBuffer) {\n    var uint8Version = new Uint8Array(arrayBuffer);\n    return window.btoa(String.fromCharCode.apply(null, uint8Version));\n}\n/* harmony default export */ var array_buffer_to_base64 = (function (arrayBuffer) {\n    var base64String = toBase64(arrayBuffer);\n    return base64String.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n});;\n// CONCATENATED MODULE: ./src/messaging/models/fcm-details.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar FCM_APPLICATION_SERVER_KEY = [0x04, 0x33, 0x94, 0xf7, 0xdf, 0xa1, 0xeb, 0xb1, 0xdc, 0x03, 0xa2, 0x5e, 0x15, 0x71, 0xdb, 0x48, 0xd3, 0x2e, 0xed, 0xed, 0xb2, 0x34, 0xdb, 0xb7, 0x47, 0x3a, 0x0c, 0x8f, 0xc4, 0xcc, 0xe1, 0x6f, 0x3c, 0x8c, 0x84, 0xdf, 0xab, 0xb6, 0x66, 0x3e, 0xf2, 0x0c, 0xd4, 0x8b, 0xfe, 0xe3, 0xf9, 0x76, 0x2f, 0x14, 0x1c, 0x63, 0x08, 0x6a, 0x6f, 0x2d, 0xb1, 0x1a, 0x95, 0xb0, 0xce, 0x37, 0xc0, 0x9c, 0x6e];\nvar SUBSCRIPTION_DETAILS = {\n    userVisibleOnly: true,\n    applicationServerKey: new Uint8Array(FCM_APPLICATION_SERVER_KEY)\n};\n/* harmony default export */ var fcm_details = ({\n    ENDPOINT: 'https://fcm.googleapis.com',\n    APPLICATION_SERVER_KEY: FCM_APPLICATION_SERVER_KEY,\n    SUBSCRIPTION_OPTIONS: SUBSCRIPTION_DETAILS\n});\n// CONCATENATED MODULE: ./src/messaging/models/token-manager.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\n\n\n\n\nvar FCM_TOKEN_DETAILS_DB = 'fcm_token_details_db';\nvar FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nvar FCM_TOKEN_DETAILS_DB_VERSION = 1;\nvar token_manager_TokenManager = /** @class */function () {\n    function TokenManager() {\n        this.errorFactory_ = new errors[\"a\" /* ErrorFactory */]('messaging', 'Messaging', models_errors.map);\n        this.openDbPromise_ = null;\n    }\n    /**\r\n     * Get the indexedDB as a promsie.\r\n     * @private\r\n     * @return {Promise<IDBDatabase>} The IndexedDB database\r\n     */\n    TokenManager.prototype.openDatabase_ = function () {\n        if (this.openDbPromise_) {\n            return this.openDbPromise_;\n        }\n        this.openDbPromise_ = new Promise(function (resolve, reject) {\n            var request = indexedDB.open(FCM_TOKEN_DETAILS_DB, FCM_TOKEN_DETAILS_DB_VERSION);\n            request.onerror = function (event) {\n                reject(event.target.error);\n            };\n            request.onsuccess = function (event) {\n                resolve(event.target.result);\n            };\n            request.onupgradeneeded = function (event) {\n                var db = event.target.result;\n                var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n                    keyPath: 'swScope'\n                });\n                // Make sure the sender ID can be searched\n                objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n                    unique: false\n                });\n                objectStore.createIndex('fcmToken', 'fcmToken', {\n                    unique: true\n                });\n            };\n        });\n        return this.openDbPromise_;\n    };\n    /**\r\n     * Close the currently open database.\r\n     * @return {Promise<?>} Returns the result of the promise chain.\r\n     */\n    TokenManager.prototype.closeDatabase = function () {\n        var _this = this;\n        if (this.openDbPromise_) {\n            return this.openDbPromise_.then(function (db) {\n                db.close();\n                _this.openDbPromise_ = null;\n            });\n        }\n        return Promise.resolve();\n    };\n    /**\r\n     * Given a token, this method will look up the details in indexedDB.\r\n     * @public\r\n     * @param {string} fcmToken\r\n     * @return {Promise<Object>} The details associated with that token.\r\n     */\n    TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {\n        return this.openDatabase_().then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var index = objectStore.index('fcmToken');\n                var request = index.get(fcmToken);\n                request.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                request.onsuccess = function (event) {\n                    resolve(event.target.result);\n                };\n            });\n        });\n    };\n    TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {\n        return this.openDatabase_().then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var scopeRequest = objectStore.get(swScope);\n                scopeRequest.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                scopeRequest.onsuccess = function (event) {\n                    resolve(event.target.result);\n                };\n            });\n        });\n    };\n    TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {\n        return this.openDatabase_().then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var senderIdTokens = [];\n                var cursorRequest = objectStore.openCursor();\n                cursorRequest.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                cursorRequest.onsuccess = function (event) {\n                    var cursor = event.target.result;\n                    if (cursor) {\n                        if (cursor.value['fcmSenderId'] === senderId) {\n                            senderIdTokens.push(cursor.value);\n                        }\n                        cursor.continue();\n                    } else {\n                        resolve(senderIdTokens);\n                    }\n                };\n            });\n        });\n    };\n    /**\r\n     * Given a PushSubscription and messagingSenderId, get an FCM token.\r\n     * @public\r\n     * @param  {string} senderId The 'messagingSenderId' to tie the token to.\r\n     * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\r\n     * @param  {string=} pushSet If defined this will swap the subscription for\r\n     * matching FCM token.\r\n     * @return {Promise<!Object>} Returns the FCM token to be used in place\r\n     * of the PushSubscription.\r\n     */\n    TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {\n        var _this = this;\n        var p256dh = array_buffer_to_base64(subscription['getKey']('p256dh'));\n        var auth = array_buffer_to_base64(subscription['getKey']('auth'));\n        var fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" + (\"endpoint=\" + subscription.endpoint + \"&\") + (\"encryption_key=\" + p256dh + \"&\") + (\"encryption_auth=\" + auth);\n        if (pushSet) {\n            fcmSubscribeBody += \"&pushSet=\" + pushSet;\n        }\n        var headers = new Headers();\n        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n        var subscribeOptions = {\n            method: 'POST',\n            headers: headers,\n            body: fcmSubscribeBody\n        };\n        return fetch(fcm_details.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions).then(function (response) {\n            return response.json();\n        }).then(function (response) {\n            var fcmTokenResponse = response;\n            if (fcmTokenResponse['error']) {\n                var message = fcmTokenResponse['error']['message'];\n                throw _this.errorFactory_.create(models_errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n                    message: message\n                });\n            }\n            if (!fcmTokenResponse['token']) {\n                throw _this.errorFactory_.create(models_errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n            }\n            if (!fcmTokenResponse['pushSet']) {\n                throw _this.errorFactory_.create(models_errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n            }\n            return {\n                token: fcmTokenResponse['token'],\n                pushSet: fcmTokenResponse['pushSet']\n            };\n        });\n    };\n    /**\r\n     * Checks the that fields in the PushSubscription are equivalent to the\r\n     * details stores in the masterTokenDetails.\r\n     * @private\r\n     * @param  {PushSubscription} subscription The push subscription we expect\r\n     * the master token to match.\r\n     * @param  {Object}  masterTokenDetails The saved details we wish to compare\r\n     * with the PushSubscription\r\n     * @return {boolean} true if the subscription and token details are\r\n     * equivalent.\r\n     */\n    TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {\n        // getKey() isn't defined in the PushSubscription externs file, hence\n        // subscription['getKey']('<key name>').\n        return subscription.endpoint === masterTokenDetails['endpoint'] && array_buffer_to_base64(subscription['getKey']('auth')) === masterTokenDetails['auth'] && array_buffer_to_base64(subscription['getKey']('p256dh')) === masterTokenDetails['p256dh'];\n    };\n    /**\r\n     * Save the details for the fcm token for re-use at a later date.\r\n     * @private\r\n     * @param  {string} senderId The 'messagingSenderId' used for this project\r\n     * @param  {ServiceWorkerRegistration} swRegistration The service worker\r\n     * used to subscribe the user for web push\r\n     * @param  {PushSubscription} subscription The push subscription passed to\r\n     * FCM for the current token.\r\n     * @param  {string} fcmToken The FCM token currently used on this\r\n     * device.\r\n     * @param  {string} fcmPushSet The FCM push tied to the fcm token.\r\n     * @return {Promise<void>}\r\n     */\n    TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {\n        var details = {\n            swScope: swRegistration.scope,\n            endpoint: subscription.endpoint,\n            auth: array_buffer_to_base64(subscription['getKey']('auth')),\n            p256dh: array_buffer_to_base64(subscription['getKey']('p256dh')),\n            fcmToken: fcmToken,\n            fcmPushSet: fcmPushSet,\n            fcmSenderId: senderId\n        };\n        return this.openDatabase_().then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var request = objectStore.put(details);\n                request.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                request.onsuccess = function (event) {\n                    resolve();\n                };\n            });\n        });\n    };\n    /**\r\n     * Returns the saved FCM Token if one is available and still valid,\r\n     * otherwise `null` is returned.\r\n     * @param {string} senderId This should be the sender ID associated with the\r\n     * FCM Token being retrieved.\r\n     * @param {ServiceWorkerRegistration} swRegistration Registration to be used\r\n     * to subscribe the user to push.\r\n     * @return {Promise<string> | Promise} Returns the saved FCM Token if\r\n     * avilable and valid.\r\n     * @export\r\n     */\n    TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {\n        var _this = this;\n        if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n            return Promise.reject(this.errorFactory_.create(models_errors.codes.SW_REGISTRATION_EXPECTED));\n        }\n        if (typeof senderId !== 'string' || senderId.length === 0) {\n            return Promise.reject(this.errorFactory_.create(models_errors.codes.BAD_SENDER_ID));\n        }\n        return this.getAllTokenDetailsForSenderId_(senderId).then(function (allTokenDetails) {\n            if (allTokenDetails.length === 0) {\n                return;\n            }\n            var index = allTokenDetails.findIndex(function (tokenDetails) {\n                return swRegistration.scope === tokenDetails['swScope'] && senderId === tokenDetails['fcmSenderId'];\n            });\n            if (index === -1) {\n                return;\n            }\n            return allTokenDetails[index];\n        }).then(function (tokenDetails) {\n            if (!tokenDetails) {\n                return;\n            }\n            return swRegistration.pushManager.getSubscription().catch(function (err) {\n                throw _this.errorFactory_.create(models_errors.codes.GET_SUBSCRIPTION_FAILED);\n            }).then(function (subscription) {\n                if (subscription && _this.isSameSubscription_(subscription, tokenDetails)) {\n                    return tokenDetails['fcmToken'];\n                }\n            });\n        });\n    };\n    /**\r\n     * Creates a new FCM token.\r\n     */\n    TokenManager.prototype.createToken = function (senderId, swRegistration) {\n        var _this = this;\n        if (typeof senderId !== 'string' || senderId.length === 0) {\n            return Promise.reject(this.errorFactory_.create(models_errors.codes.BAD_SENDER_ID));\n        }\n        if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n            return Promise.reject(this.errorFactory_.create(models_errors.codes.SW_REGISTRATION_EXPECTED));\n        }\n        // Check for existing subscription first\n        var subscription;\n        var fcmTokenDetails;\n        return swRegistration.pushManager.getSubscription().then(function (subscription) {\n            if (subscription) {\n                return subscription;\n            }\n            return swRegistration.pushManager.subscribe(fcm_details.SUBSCRIPTION_OPTIONS);\n        }).then(function (sub) {\n            subscription = sub;\n            return _this.subscribeToFCM(senderId, subscription);\n        }).then(function (tokenDetails) {\n            fcmTokenDetails = tokenDetails;\n            return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n        }).then(function () {\n            return fcmTokenDetails['token'];\n        });\n    };\n    /**\r\n     * This method deletes details of the current FCM token.\r\n     * It's returning a promise in case we need to move to an async\r\n     * method for deleting at a later date.\r\n     * @param {string} token Token to be deleted\r\n     * @return {Promise<Object>} Resolves once the FCM token details have been\r\n     * deleted and returns the deleted details.\r\n     */\n    TokenManager.prototype.deleteToken = function (token) {\n        var _this = this;\n        if (typeof token !== 'string' || token.length === 0) {\n            return Promise.reject(this.errorFactory_.create(models_errors.codes.INVALID_DELETE_TOKEN));\n        }\n        return this.getTokenDetailsFromToken(token).then(function (details) {\n            if (!details) {\n                throw _this.errorFactory_.create(models_errors.codes.DELETE_TOKEN_NOT_FOUND);\n            }\n            return _this.openDatabase_().then(function (db) {\n                return new Promise(function (resolve, reject) {\n                    var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n                    var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                    var request = objectStore.delete(details['swScope']);\n                    request.onerror = function (event) {\n                        reject(event.target.error);\n                    };\n                    request.onsuccess = function (event) {\n                        if (event.target.result === 0) {\n                            reject(_this.errorFactory_.create(models_errors.codes.FAILED_TO_DELETE_TOKEN));\n                            return;\n                        }\n                        resolve(details);\n                    };\n                });\n            });\n        });\n    };\n    return TokenManager;\n}();\n/* harmony default export */ var token_manager = (token_manager_TokenManager);\n// CONCATENATED MODULE: ./src/messaging/models/notification-permission.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\n/* harmony default export */ var notification_permission = ({\n  granted: 'granted',\n  default: 'default',\n  denied: 'denied'\n});\n// CONCATENATED MODULE: ./src/messaging/controllers/controller-interface.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\n\n\n\n\nvar SENDER_ID_OPTION_NAME = 'messagingSenderId';\nvar controller_interface_ControllerInterface = /** @class */function () {\n    /**\r\n     * An interface of the Messaging Service API\r\n     * @param {!firebase.app.App} app\r\n     */\n    function ControllerInterface(app) {\n        var _this = this;\n        this.errorFactory_ = new errors[\"a\" /* ErrorFactory */]('messaging', 'Messaging', models_errors.map);\n        if (!app.options[SENDER_ID_OPTION_NAME] || typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n            throw this.errorFactory_.create(models_errors.codes.BAD_SENDER_ID);\n        }\n        this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n        this.tokenManager_ = new token_manager();\n        this.app = app;\n        this.INTERNAL = {};\n        this.INTERNAL.delete = function () {\n            return _this.delete;\n        };\n    }\n    /**\r\n     * @export\r\n     * @return {Promise<string> | Promise<null>} Returns a promise that\r\n     * resolves to an FCM token.\r\n     */\n    ControllerInterface.prototype.getToken = function () {\n        var _this = this;\n        // Check with permissions\n        var currentPermission = this.getNotificationPermission_();\n        if (currentPermission !== notification_permission.granted) {\n            if (currentPermission === notification_permission.denied) {\n                return Promise.reject(this.errorFactory_.create(models_errors.codes.NOTIFICATIONS_BLOCKED));\n            }\n            // We must wait for permission to be granted\n            return Promise.resolve(null);\n        }\n        return this.getSWRegistration_().then(function (registration) {\n            return _this.tokenManager_.getSavedToken(_this.messagingSenderId_, registration).then(function (token) {\n                if (token) {\n                    return token;\n                }\n                return _this.tokenManager_.createToken(_this.messagingSenderId_, registration);\n            });\n        });\n    };\n    /**\r\n     * This method deletes tokens that the token manager looks after and then\r\n     * unregisters the push subscription if it exists.\r\n     * @export\r\n     * @param {string} token\r\n     * @return {Promise<void>}\r\n     */\n    ControllerInterface.prototype.deleteToken = function (token) {\n        var _this = this;\n        return this.tokenManager_.deleteToken(token).then(function () {\n            return _this.getSWRegistration_().then(function (registration) {\n                if (registration) {\n                    return registration.pushManager.getSubscription();\n                }\n            }).then(function (subscription) {\n                if (subscription) {\n                    return subscription.unsubscribe();\n                }\n            });\n        });\n    };\n    ControllerInterface.prototype.getSWRegistration_ = function () {\n        throw this.errorFactory_.create(models_errors.codes.SHOULD_BE_INHERITED);\n    };\n    //\n    // The following methods should only be available in the window.\n    //\n    ControllerInterface.prototype.requestPermission = function () {\n        throw this.errorFactory_.create(models_errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\r\n     * @export\r\n     * @param {!ServiceWorkerRegistration} registration\r\n     */\n    ControllerInterface.prototype.useServiceWorker = function (registration) {\n        throw this.errorFactory_.create(models_errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\r\n     * @export\r\n     * @param {!firebase.Observer|function(*)} nextOrObserver\r\n     * @param {function(!Error)=} optError\r\n     * @param {function()=} optCompleted\r\n     * @return {!function()}\r\n     */\n    ControllerInterface.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {\n        throw this.errorFactory_.create(models_errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\r\n     * @export\r\n     * @param {!firebase.Observer|function()} nextOrObserver An observer object\r\n     * or a function triggered on token refresh.\r\n     * @param {function(!Error)=} optError Optional A function\r\n     * triggered on token refresh error.\r\n     * @param {function()=} optCompleted Optional function triggered when the\r\n     * observer is removed.\r\n     * @return {!function()} The unsubscribe function for the observer.\r\n     */\n    ControllerInterface.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {\n        throw this.errorFactory_.create(models_errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    //\n    // The following methods are used by the service worker only.\n    //\n    /**\r\n     * @export\r\n     * @param {function(Object)} callback\r\n     */\n    ControllerInterface.prototype.setBackgroundMessageHandler = function (callback) {\n        throw this.errorFactory_.create(models_errors.codes.AVAILABLE_IN_SW);\n    };\n    //\n    // The following methods are used by the service themselves and not exposed\n    // publicly or not expected to be used by developers.\n    //\n    /**\r\n     * This method is required to adhere to the Firebase interface.\r\n     * It closes any currently open indexdb database connections.\r\n     */\n    ControllerInterface.prototype.delete = function () {\n        this.tokenManager_.closeDatabase();\n    };\n    /**\r\n     * Returns the current Notification Permission state.\r\n     * @private\r\n     * @return {string} The currenct permission state.\r\n     */\n    ControllerInterface.prototype.getNotificationPermission_ = function () {\n        return Notification.permission;\n    };\n    /**\r\n     * @protected\r\n     * @returns {TokenManager}\r\n     */\n    ControllerInterface.prototype.getTokenManager = function () {\n        return this.tokenManager_;\n    };\n    return ControllerInterface;\n}();\n/* harmony default export */ var controller_interface = (controller_interface_ControllerInterface);\n// CONCATENATED MODULE: ./src/messaging/models/worker-page-message.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n// These fields are strings to prevent closure from thinking goog.getMsg\n// should be used to initialise the values\n\nvar PARAMS = {\n    TYPE_OF_MSG: 'firebase-messaging-msg-type',\n    DATA: 'firebase-messaging-msg-data'\n};\n// This value isn't using the TYPE_OF_MSG short hand as closure\n// expects the variable to be defined via goog.getMsg\nvar msgType = {\n    PUSH_MSG_RECEIVED: 'push-msg-received',\n    NOTIFICATION_CLICKED: 'notification-clicked'\n};\nvar createNewMsg = function createNewMsg(msgType, msgData) {\n    var message = (_a = {}, _a[PARAMS.TYPE_OF_MSG] = msgType, _a[PARAMS.DATA] = msgData, _a);\n    return message;\n    var _a;\n};\n/* harmony default export */ var worker_page_message = ({\n    PARAMS: PARAMS,\n    TYPES_OF_MSG: msgType,\n    createNewMsg: createNewMsg\n});\n// CONCATENATED MODULE: ./src/messaging/models/default-sw.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\n/* harmony default export */ var default_sw = ({\n  path: '/firebase-messaging-sw.js',\n  scope: '/firebase-cloud-messaging-push-scope'\n});\n// EXTERNAL MODULE: ./src/app/subscribe.ts\nvar subscribe = __webpack_require__(31);\n\n// CONCATENATED MODULE: ./src/messaging/controllers/window-controller.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar __extends = this && this.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\n\n\n\n\n\n\nvar window_controller_WindowController = /** @class */function (_super) {\n    __extends(WindowController, _super);\n    /**\r\n     * A service that provides a MessagingService instance.\r\n     * @param {!firebase.app.App} app\r\n     */\n    function WindowController(app) {\n        var _this = _super.call(this, app) || this;\n        /**\r\n         * @private\r\n         * @type {ServiceWorkerRegistration}\r\n         */\n        _this.registrationToUse_;\n        /**\r\n         * @private\r\n         * @type {Promise}\r\n         */\n        _this.manifestCheckPromise_;\n        /**\r\n         * @private\r\n         * @type {firebase.Observer}\r\n         */\n        _this.messageObserver_ = null;\n        /**\r\n         * @private {!firebase.Subscribe} The subscribe function to the onMessage\r\n         * observer.\r\n         */\n        _this.onMessage_ = Object(subscribe[\"a\" /* createSubscribe */])(function (observer) {\n            _this.messageObserver_ = observer;\n        });\n        /**\r\n         * @private\r\n         * @type {firebase.Observer}\r\n         */\n        _this.tokenRefreshObserver_ = null;\n        _this.onTokenRefresh_ = Object(subscribe[\"a\" /* createSubscribe */])(function (observer) {\n            _this.tokenRefreshObserver_ = observer;\n        });\n        _this.setupSWMessageListener_();\n        return _this;\n    }\n    /**\r\n     * This method returns an FCM token if it can be generated.\r\n     * The return promise will reject if the browser doesn't support\r\n     * FCM, if permission is denied for notifications or it's not\r\n     * possible to generate a token.\r\n     * @export\r\n     * @return {Promise<string> | Promise<null>} Returns a promise the\r\n     * resolves to an FCM token or null if permission isn't granted.\r\n     */\n    WindowController.prototype.getToken = function () {\n        var _this = this;\n        // Check that the required API's are available\n        if (!this.isSupported_()) {\n            return Promise.reject(this.errorFactory_.create(models_errors.codes.UNSUPPORTED_BROWSER));\n        }\n        return this.manifestCheck_().then(function () {\n            return _super.prototype.getToken.call(_this);\n        });\n    };\n    /**\r\n     * The method checks that a manifest is defined and has the correct GCM\r\n     * sender ID.\r\n     * @private\r\n     * @return {Promise} Returns a promise that resolves if the manifest matches\r\n     * our required sender ID\r\n     */\n    WindowController.prototype.manifestCheck_ = function () {\n        var _this = this;\n        if (this.manifestCheckPromise_) {\n            return this.manifestCheckPromise_;\n        }\n        var manifestTag = document.querySelector('link[rel=\"manifest\"]');\n        if (!manifestTag) {\n            this.manifestCheckPromise_ = Promise.resolve();\n        } else {\n            this.manifestCheckPromise_ = fetch(manifestTag.href).then(function (response) {\n                return response.json();\n            }).catch(function () {\n                // If the download or parsing fails allow check.\n                // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n                return Promise.resolve();\n            }).then(function (manifestContent) {\n                if (!manifestContent) {\n                    return;\n                }\n                if (!manifestContent['gcm_sender_id']) {\n                    return;\n                }\n                if (manifestContent['gcm_sender_id'] !== '103953800507') {\n                    throw _this.errorFactory_.create(models_errors.codes.INCORRECT_GCM_SENDER_ID);\n                }\n            });\n        }\n        return this.manifestCheckPromise_;\n    };\n    /**\r\n     * Request permission if it is not currently granted\r\n     * @export\r\n     * @returns {Promise} Resolves if the permission was granted, otherwise\r\n     * rejects\r\n     */\n    WindowController.prototype.requestPermission = function () {\n        var _this = this;\n        if (Notification.permission === notification_permission.granted) {\n            return Promise.resolve();\n        }\n        return new Promise(function (resolve, reject) {\n            var managePermissionResult = function managePermissionResult(result) {\n                if (result === notification_permission.granted) {\n                    return resolve();\n                } else if (result === notification_permission.denied) {\n                    return reject(_this.errorFactory_.create(models_errors.codes.PERMISSION_BLOCKED));\n                } else {\n                    return reject(_this.errorFactory_.create(models_errors.codes.PERMISSION_DEFAULT));\n                }\n            };\n            // The Notification.requestPermission API was changed to\n            // return a promise so now have to handle both in case\n            // browsers stop support callbacks for promised version\n            var permissionPromise = Notification.requestPermission(function (result) {\n                if (permissionPromise) {\n                    // Let the promise manage this\n                    return;\n                }\n                managePermissionResult(result);\n            });\n            if (permissionPromise) {\n                // Prefer the promise version as it's the future API.\n                permissionPromise.then(managePermissionResult);\n            }\n        });\n    };\n    /**\r\n     * This method allows a developer to override the default service worker and\r\n     * instead use a custom service worker.\r\n     * @export\r\n     * @param {!ServiceWorkerRegistration} registration The service worker\r\n     * registration that should be used to receive the push messages.\r\n     */\n    WindowController.prototype.useServiceWorker = function (registration) {\n        if (!(registration instanceof ServiceWorkerRegistration)) {\n            throw this.errorFactory_.create(models_errors.codes.SW_REGISTRATION_EXPECTED);\n        }\n        if (typeof this.registrationToUse_ !== 'undefined') {\n            throw this.errorFactory_.create(models_errors.codes.USE_SW_BEFORE_GET_TOKEN);\n        }\n        this.registrationToUse_ = registration;\n    };\n    /**\r\n     * @export\r\n     * @param {!firebase.Observer|function(*)} nextOrObserver An observer object\r\n     * or a function triggered on message.\r\n     * @param {function(!Error)=} optError Optional A function triggered on\r\n     * message error.\r\n     * @param {function()=} optCompleted Optional function triggered when the\r\n     * observer is removed.\r\n     * @return {!function()} The unsubscribe function for the observer.\r\n     */\n    WindowController.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {\n        return this.onMessage_(nextOrObserver, optError, optCompleted);\n    };\n    /**\r\n     * @export\r\n     * @param {!firebase.Observer|function()} nextOrObserver An observer object\r\n     * or a function triggered on token refresh.\r\n     * @param {function(!Error)=} optError Optional A function\r\n     * triggered on token refresh error.\r\n     * @param {function()=} optCompleted Optional function triggered when the\r\n     * observer is removed.\r\n     * @return {!function()} The unsubscribe function for the observer.\r\n     */\n    WindowController.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {\n        return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);\n    };\n    /**\r\n     * Given a registration, wait for the service worker it relates to\r\n     * become activer\r\n     * @private\r\n     * @param  {ServiceWorkerRegistration} registration Registration to wait\r\n     * for service worker to become active\r\n     * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker\r\n     * registration to become active\r\n     */\n    WindowController.prototype.waitForRegistrationToActivate_ = function (registration) {\n        var _this = this;\n        var serviceWorker = registration.installing || registration.waiting || registration.active;\n        return new Promise(function (resolve, reject) {\n            if (!serviceWorker) {\n                // This is a rare scenario but has occured in firefox\n                reject(_this.errorFactory_.create(models_errors.codes.NO_SW_IN_REG));\n                return;\n            }\n            // Because the Promise function is called on next tick there is a\n            // small chance that the worker became active or redundant already.\n            if (serviceWorker.state === 'activated') {\n                resolve(registration);\n                return;\n            }\n            if (serviceWorker.state === 'redundant') {\n                reject(_this.errorFactory_.create(models_errors.codes.SW_REG_REDUNDANT));\n                return;\n            }\n            var stateChangeListener = function stateChangeListener() {\n                if (serviceWorker.state === 'activated') {\n                    resolve(registration);\n                } else if (serviceWorker.state === 'redundant') {\n                    reject(_this.errorFactory_.create(models_errors.codes.SW_REG_REDUNDANT));\n                } else {\n                    // Return early and wait to next state change\n                    return;\n                }\n                serviceWorker.removeEventListener('statechange', stateChangeListener);\n            };\n            serviceWorker.addEventListener('statechange', stateChangeListener);\n        });\n    };\n    /**\r\n     * This will regiater the default service worker and return the registration\r\n     * @private\r\n     * @return {Promise<!ServiceWorkerRegistration>} The service worker\r\n     * registration to be used for the push service.\r\n     */\n    WindowController.prototype.getSWRegistration_ = function () {\n        var _this = this;\n        if (this.registrationToUse_) {\n            return this.waitForRegistrationToActivate_(this.registrationToUse_);\n        }\n        // Make the registration null so we know useServiceWorker will not\n        // use a new service worker as registrationToUse_ is no longer undefined\n        this.registrationToUse_ = null;\n        return navigator.serviceWorker.register(default_sw.path, {\n            scope: default_sw.scope\n        }).catch(function (err) {\n            throw _this.errorFactory_.create(models_errors.codes.FAILED_DEFAULT_REGISTRATION, {\n                browserErrorMessage: err.message\n            });\n        }).then(function (registration) {\n            return _this.waitForRegistrationToActivate_(registration).then(function () {\n                _this.registrationToUse_ = registration;\n                // We update after activation due to an issue with Firefox v49 where\n                // a race condition occassionally causes the service work to not\n                // install\n                registration.update();\n                return registration;\n            });\n        });\n    };\n    /**\r\n     * This method will set up a message listener to handle\r\n     * events from the service worker that should trigger\r\n     * events in the page.\r\n     *\r\n     * @private\r\n     */\n    WindowController.prototype.setupSWMessageListener_ = function () {\n        var _this = this;\n        if (!('serviceWorker' in navigator)) {\n            return;\n        }\n        navigator.serviceWorker.addEventListener('message', function (event) {\n            if (!event.data || !event.data[worker_page_message.PARAMS.TYPE_OF_MSG]) {\n                // Not a message from FCM\n                return;\n            }\n            var workerPageMessage = event.data;\n            switch (workerPageMessage[worker_page_message.PARAMS.TYPE_OF_MSG]) {\n                case worker_page_message.TYPES_OF_MSG.PUSH_MSG_RECEIVED:\n                case worker_page_message.TYPES_OF_MSG.NOTIFICATION_CLICKED:\n                    var pushMessage = workerPageMessage[worker_page_message.PARAMS.DATA];\n                    _this.messageObserver_.next(pushMessage);\n                    break;\n                default:\n                    // Noop.\n                    break;\n            }\n        }, false);\n    };\n    /**\r\n     * Checks to see if the required API's are valid or not.\r\n     * @private\r\n     * @return {boolean} Returns true if the desired APIs are available.\r\n     */\n    WindowController.prototype.isSupported_ = function () {\n        return 'serviceWorker' in navigator && 'PushManager' in window && 'Notification' in window && 'fetch' in window && ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') && PushSubscription.prototype.hasOwnProperty('getKey');\n    };\n    return WindowController;\n}(controller_interface);\n/* harmony default export */ var window_controller = (window_controller_WindowController);\n// CONCATENATED MODULE: ./src/messaging/controllers/sw-controller.ts\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar sw_controller___extends = this && this.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\n\n\n\n\nvar FCM_MSG = 'FCM_MSG';\nvar sw_controller_SWController = /** @class */function (_super) {\n    sw_controller___extends(SWController, _super);\n    function SWController(app) {\n        var _this = _super.call(this, app) || this;\n        self.addEventListener('push', function (e) {\n            return _this.onPush_(e);\n        }, false);\n        self.addEventListener('pushsubscriptionchange', function (e) {\n            return _this.onSubChange_(e);\n        }, false);\n        self.addEventListener('notificationclick', function (e) {\n            return _this.onNotificationClick_(e);\n        }, false);\n        /**\r\n         * @private\r\n         * @type {function(Object)|null}\r\n         */\n        _this.bgMessageHandler_ = null;\n        return _this;\n    }\n    /**\r\n    * A handler for push events that shows notifications based on the content of\r\n    * the payload.\r\n    *\r\n    * The payload must be a JSON-encoded Object with a `notification` key. The\r\n    * value of the `notification` property will be used as the NotificationOptions\r\n    * object passed to showNotification. Additionally, the `title` property of the\r\n    * notification object will be used as the title.\r\n    *\r\n    * If there is no notification data in the payload then no notification will be\r\n    * shown.\r\n    * @private\r\n    */\n    SWController.prototype.onPush_ = function (event) {\n        var _this = this;\n        var msgPayload;\n        try {\n            msgPayload = event.data.json();\n        } catch (err) {\n            // Not JSON so not an FCM message\n            return;\n        }\n        var handleMsgPromise = this.hasVisibleClients_().then(function (hasVisibleClients) {\n            if (hasVisibleClients) {\n                // Do not need to show a notification.\n                if (msgPayload.notification || _this.bgMessageHandler_) {\n                    // Send to page\n                    return _this.sendMessageToWindowClients_(msgPayload);\n                }\n                return;\n            }\n            var notificationDetails = _this.getNotificationData_(msgPayload);\n            if (notificationDetails) {\n                var notificationTitle = notificationDetails.title || '';\n                return self.registration.showNotification(notificationTitle, notificationDetails);\n            } else if (_this.bgMessageHandler_) {\n                return _this.bgMessageHandler_(msgPayload);\n            }\n        });\n        event.waitUntil(handleMsgPromise);\n    };\n    /**\r\n    * @private\r\n    */\n    SWController.prototype.onSubChange_ = function (event) {\n        var _this = this;\n        var promiseChain = this.getToken().then(function (token) {\n            if (!token) {\n                // We can't resubscribe if we don't have an FCM token for this scope.\n                throw _this.errorFactory_.create(models_errors.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE);\n            }\n            var tokenDetails = null;\n            var tokenManager = _this.getTokenManager();\n            return tokenManager.getTokenDetailsFromToken(token).then(function (details) {\n                tokenDetails = details;\n                if (!tokenDetails) {\n                    throw _this.errorFactory_.create(models_errors.codes.INVALID_SAVED_TOKEN);\n                }\n                // Attempt to get a new subscription\n                return self.registration.pushManager.subscribe(fcm_details.SUBSCRIPTION_OPTIONS);\n            }).then(function (newSubscription) {\n                // Send new subscription to FCM.\n                return tokenManager.subscribeToFCM(tokenDetails.fcmSenderId, newSubscription, tokenDetails.fcmPushSet);\n            }).catch(function (err) {\n                // The best thing we can do is log this to the terminal so\n                // developers might notice the error.\n                return tokenManager.deleteToken(tokenDetails.fcmToken).then(function () {\n                    throw _this.errorFactory_.create(models_errors.codes.UNABLE_TO_RESUBSCRIBE, {\n                        message: err\n                    });\n                });\n            });\n        });\n        event.waitUntil(promiseChain);\n    };\n    /**\r\n    * @private\r\n    */\n    SWController.prototype.onNotificationClick_ = function (event) {\n        var _this = this;\n        if (!(event.notification && event.notification.data && event.notification.data[FCM_MSG])) {\n            // Not an FCM notification, do nothing.\n            return;\n        }\n        // Prevent other listeners from receiving the event\n        event.stopImmediatePropagation();\n        event.notification.close();\n        var msgPayload = event.notification.data[FCM_MSG];\n        var clickAction = msgPayload['notification']['click_action'];\n        if (!clickAction) {\n            // Nothing to do.\n            return;\n        }\n        var promiseChain = this.getWindowClient_(clickAction).then(function (windowClient) {\n            if (!windowClient) {\n                // Unable to find window client so need to open one.\n                return self.clients.openWindow(clickAction);\n            }\n            return windowClient;\n        }).then(function (windowClient) {\n            if (!windowClient) {\n                // Window Client will not be returned if it's for a third party origin.\n                return;\n            }\n            // Delete notification data from payload before sending to the page.\n            var notificationData = msgPayload['notification'];\n            delete msgPayload['notification'];\n            var internalMsg = worker_page_message.createNewMsg(worker_page_message.TYPES_OF_MSG.NOTIFICATION_CLICKED, msgPayload);\n            // Attempt to send a message to the client to handle the data\n            // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n            return _this.attemptToMessageClient_(windowClient, internalMsg);\n        });\n        event.waitUntil(promiseChain);\n    };\n    /**\r\n     * @private\r\n     * @param {Object} msgPayload\r\n     * @return {NotificationOptions|undefined}\r\n     */\n    SWController.prototype.getNotificationData_ = function (msgPayload) {\n        if (!msgPayload) {\n            return;\n        }\n        if (_typeof(msgPayload.notification) !== 'object') {\n            return;\n        }\n        var notificationInformation = Object.assign({}, msgPayload.notification);\n        // Put the message payload under FCM_MSG name so we can identify the\n        // notification as being an FCM notification vs a notification from\n        // somewhere else (i.e. normal web push or developer generated\n        // notification).\n        notificationInformation['data'] = (_a = {}, _a[FCM_MSG] = msgPayload, _a);\n        return notificationInformation;\n        var _a;\n    };\n    /**\r\n     * Calling setBackgroundMessageHandler will opt in to some specific\r\n     * behaviours.\r\n     * 1.) If a notification doesn't need to be shown due to a window already\r\n     * being visible, then push messages will be sent to the page.\r\n     * 2.) If a notification needs to be shown, and the message contains no\r\n     * notification data this method will be called\r\n     * and the promise it returns will be passed to event.waitUntil.\r\n     * If you do not set this callback then all push messages will let and the\r\n     * developer can handle them in a their own 'push' event callback\r\n     * @export\r\n     * @param {function(Object)} callback The callback to be called when a push\r\n     * message is received and a notification must be shown. The callback will\r\n     * be given the data from the push message.\r\n     */\n    SWController.prototype.setBackgroundMessageHandler = function (callback) {\n        if (callback && typeof callback !== 'function') {\n            throw this.errorFactory_.create(models_errors.codes.BG_HANDLER_FUNCTION_EXPECTED);\n        }\n        this.bgMessageHandler_ = callback;\n    };\n    /**\r\n     * @private\r\n     * @param {string} url The URL to look for when focusing a client.\r\n     * @return {Object} Returns an existing window client or a newly opened\r\n     * WindowClient.\r\n     */\n    SWController.prototype.getWindowClient_ = function (url) {\n        // Use URL to normalize the URL when comparing to windowClients.\n        // This at least handles whether to include trailing slashes or not\n        var parsedURL = new URL(url).href;\n        return self.clients.matchAll({\n            type: 'window',\n            includeUncontrolled: true\n        }).then(function (clientList) {\n            var suitableClient = null;\n            for (var i = 0; i < clientList.length; i++) {\n                var parsedClientUrl = new URL(clientList[i].url).href;\n                if (parsedClientUrl === parsedURL) {\n                    suitableClient = clientList[i];\n                    break;\n                }\n            }\n            if (suitableClient) {\n                suitableClient.focus();\n                return suitableClient;\n            }\n        });\n    };\n    /**\r\n     * This message will attempt to send the message to a window client.\r\n     * @private\r\n     * @param {Object} client The WindowClient to send the message to.\r\n     * @param {Object} message The message to send to the client.\r\n     * @returns {Promise} Returns a promise that resolves after sending the\r\n     * message. This does not guarantee that the message was successfully\r\n     * received.\r\n     */\n    SWController.prototype.attemptToMessageClient_ = function (client, message) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (!client) {\n                return reject(_this.errorFactory_.create(models_errors.codes.NO_WINDOW_CLIENT_TO_MSG));\n            }\n            client.postMessage(message);\n            resolve();\n        });\n    };\n    /**\r\n     * @private\r\n     * @returns {Promise<boolean>} If there is currently a visible WindowClient,\r\n     * this method will resolve to true, otherwise false.\r\n     */\n    SWController.prototype.hasVisibleClients_ = function () {\n        return self.clients.matchAll({\n            type: 'window',\n            includeUncontrolled: true\n        }).then(function (clientList) {\n            return clientList.some(function (client) {\n                return client.visibilityState === 'visible';\n            });\n        });\n    };\n    /**\r\n     * @private\r\n     * @param {Object} msgPayload The data from the push event that should be sent\r\n     * to all available pages.\r\n     * @returns {Promise} Returns a promise that resolves once the message\r\n     * has been sent to all WindowClients.\r\n     */\n    SWController.prototype.sendMessageToWindowClients_ = function (msgPayload) {\n        var _this = this;\n        return self.clients.matchAll({\n            type: 'window',\n            includeUncontrolled: true\n        }).then(function (clientList) {\n            var internalMsg = worker_page_message.createNewMsg(worker_page_message.TYPES_OF_MSG.PUSH_MSG_RECEIVED, msgPayload);\n            return Promise.all(clientList.map(function (client) {\n                return _this.attemptToMessageClient_(client, internalMsg);\n            }));\n        });\n    };\n    /**\r\n     * This will register the default service worker and return the registration.\r\n     * @private\r\n     * @return {Promise<!ServiceWorkerRegistration>} The service worker\r\n     * registration to be used for the push service.\r\n     */\n    SWController.prototype.getSWRegistration_ = function () {\n        return Promise.resolve(self.registration);\n    };\n    return SWController;\n}(controller_interface);\n/* harmony default export */ var sw_controller = (sw_controller_SWController);\n// EXTERNAL MODULE: ./src/app.ts + 1 modules\nvar src_app = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./src/messaging.ts\n/* harmony export (immutable) */ __webpack_exports__[\"registerMessaging\"] = registerMessaging;\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\n\n\n\nfunction registerMessaging(instance) {\n    var messagingName = 'messaging';\n    var factoryMethod = function factoryMethod(app) {\n        if (self && 'ServiceWorkerGlobalScope' in self) {\n            return new sw_controller(app);\n        }\n        // Assume we are in the window context.\n        return new window_controller(app);\n    };\n    var namespaceExports = {\n        // no-inline\n        Messaging: window_controller\n    };\n    instance.INTERNAL.registerService(messagingName, factoryMethod, namespaceExports);\n}\nregisterMessaging(src_app[\"default\"]);\n\n/***/ })\n\n},[61]);\n          } catch(error) {\n            throw new Error(\n              'Cannot instantiate firebase-messaging.js - ' +\n              'be sure to load firebase-app.js first.'\n            )\n          }\n\n\n// WEBPACK FOOTER //\n// firebase-messaging.js","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction toBase64(arrayBuffer) {\n  const uint8Version = new Uint8Array(arrayBuffer);\n  return window.btoa(String.fromCharCode.apply(null, uint8Version));\n}\n\nexport default arrayBuffer => {\n  const base64String = toBase64(arrayBuffer);\n  return base64String.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/helpers/array-buffer-to-base64.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport WindowController from './messaging/controllers/window-controller';\nimport SWController from './messaging/controllers/sw-controller';\nimport firebase from './app';\n\nexport function registerMessaging(instance) {\n  const messagingName = 'messaging';\n  const factoryMethod = app => {\n    if (self && 'ServiceWorkerGlobalScope' in self) {\n      return new SWController(app);\n    }\n\n    // Assume we are in the window context.\n    return new WindowController(app);\n  };\n\n  const namespaceExports = {\n    // no-inline\n    Messaging: WindowController\n  };\n\n  instance.INTERNAL.registerService(\n    messagingName,\n    factoryMethod,\n    namespaceExports\n  );\n}\n\nregisterMessaging(firebase);\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nconst CODES = {\n  AVAILABLE_IN_WINDOW: 'only-available-in-window',\n  AVAILABLE_IN_SW: 'only-available-in-sw',\n  SHOULD_BE_INHERITED: 'should-be-overriden',\n  BAD_SENDER_ID: 'bad-sender-id',\n  INCORRECT_GCM_SENDER_ID: 'incorrect-gcm-sender-id',\n  PERMISSION_DEFAULT: 'permission-default',\n  PERMISSION_BLOCKED: 'permission-blocked',\n  UNSUPPORTED_BROWSER: 'unsupported-browser',\n  NOTIFICATIONS_BLOCKED: 'notifications-blocked',\n  FAILED_DEFAULT_REGISTRATION: 'failed-serviceworker-registration',\n  SW_REGISTRATION_EXPECTED: 'sw-registration-expected',\n  GET_SUBSCRIPTION_FAILED: 'get-subscription-failed',\n  INVALID_SAVED_TOKEN: 'invalid-saved-token',\n  SW_REG_REDUNDANT: 'sw-reg-redundant',\n  TOKEN_SUBSCRIBE_FAILED: 'token-subscribe-failed',\n  TOKEN_SUBSCRIBE_NO_TOKEN: 'token-subscribe-no-token',\n  TOKEN_SUBSCRIBE_NO_PUSH_SET: 'token-subscribe-no-push-set',\n  USE_SW_BEFORE_GET_TOKEN: 'use-sw-before-get-token',\n  INVALID_DELETE_TOKEN: 'invalid-delete-token',\n  DELETE_TOKEN_NOT_FOUND: 'delete-token-not-found',\n  DELETE_SCOPE_NOT_FOUND: 'delete-scope-not-found',\n  BG_HANDLER_FUNCTION_EXPECTED: 'bg-handler-function-expected',\n  NO_WINDOW_CLIENT_TO_MSG: 'no-window-client-to-msg',\n  UNABLE_TO_RESUBSCRIBE: 'unable-to-resubscribe',\n  NO_FCM_TOKEN_FOR_RESUBSCRIBE: 'no-fcm-token-for-resubscribe',\n  FAILED_TO_DELETE_TOKEN: 'failed-to-delete-token',\n  NO_SW_IN_REG: 'no-sw-in-reg',\n  BAD_SCOPE: 'bad-scope',\n  BAD_VAPID_KEY: 'bad-vapid-key',\n  BAD_SUBSCRIPTION: 'bad-subscription',\n  BAD_TOKEN: 'bad-token',\n  BAD_PUSH_SET: 'bad-push-set',\n  FAILED_DELETE_VAPID_KEY: 'failed-delete-vapid-key'\n};\n\nconst ERROR_MAP = {\n  [CODES.AVAILABLE_IN_WINDOW]: 'This method is available in a Window context.',\n  [CODES.AVAILABLE_IN_SW]:\n    'This method is available in a service worker ' + 'context.',\n  [CODES.SHOULD_BE_INHERITED]:\n    'This method should be overriden by ' + 'extended classes.',\n  [CODES.BAD_SENDER_ID]:\n    \"Please ensure that 'messagingSenderId' is set \" +\n    'correctly in the options passed into firebase.initializeApp().',\n  [CODES.PERMISSION_DEFAULT]:\n    'The required permissions were not granted and ' + 'dismissed instead.',\n  [CODES.PERMISSION_BLOCKED]:\n    'The required permissions were not granted and ' + 'blocked instead.',\n  [CODES.UNSUPPORTED_BROWSER]:\n    \"This browser doesn't support the API's \" +\n    'required to use the firebase SDK.',\n  [CODES.NOTIFICATIONS_BLOCKED]: 'Notifications have been blocked.',\n  [CODES.FAILED_DEFAULT_REGISTRATION]:\n    'We are unable to register the ' +\n    'default service worker. {$browserErrorMessage}',\n  [CODES.SW_REGISTRATION_EXPECTED]:\n    'A service worker registration was the ' + 'expected input.',\n  [CODES.GET_SUBSCRIPTION_FAILED]:\n    'There was an error when trying to get ' +\n    'any existing Push Subscriptions.',\n  [CODES.INVALID_SAVED_TOKEN]: 'Unable to access details of the saved token.',\n  [CODES.SW_REG_REDUNDANT]:\n    'The service worker being used for push was made ' + 'redundant.',\n  [CODES.TOKEN_SUBSCRIBE_FAILED]:\n    'A problem occured while subscribing the ' + 'user to FCM: {$message}',\n  [CODES.TOKEN_SUBSCRIBE_NO_TOKEN]:\n    'FCM returned no token when subscribing ' + 'the user to push.',\n  [CODES.TOKEN_SUBSCRIBE_NO_PUSH_SET]:\n    'FCM returned an invalid response ' + 'when getting an FCM token.',\n  [CODES.USE_SW_BEFORE_GET_TOKEN]:\n    'You must call useServiceWorker() before ' +\n    'calling getToken() to ensure your service worker is used.',\n  [CODES.INVALID_DELETE_TOKEN]:\n    'You must pass a valid token into ' +\n    'deleteToken(), i.e. the token from getToken().',\n  [CODES.DELETE_TOKEN_NOT_FOUND]:\n    'The deletion attempt for token could not ' +\n    'be performed as the token was not found.',\n  [CODES.DELETE_SCOPE_NOT_FOUND]:\n    'The deletion attempt for service worker ' +\n    'scope could not be performed as the scope was not found.',\n  [CODES.BG_HANDLER_FUNCTION_EXPECTED]:\n    'The input to ' + 'setBackgroundMessageHandler() must be a function.',\n  [CODES.NO_WINDOW_CLIENT_TO_MSG]:\n    'An attempt was made to message a ' + 'non-existant window client.',\n  [CODES.UNABLE_TO_RESUBSCRIBE]:\n    'There was an error while re-subscribing ' +\n    'the FCM token for push messaging. Will have to resubscribe the ' +\n    'user on next visit. {$message}',\n  [CODES.NO_FCM_TOKEN_FOR_RESUBSCRIBE]:\n    'Could not find an FCM token ' +\n    'and as a result, unable to resubscribe. Will have to resubscribe the ' +\n    'user on next visit.',\n  [CODES.FAILED_TO_DELETE_TOKEN]: 'Unable to delete the currently saved token.',\n  [CODES.NO_SW_IN_REG]:\n    'Even though the service worker registration was ' +\n    'successful, there was a problem accessing the service worker itself.',\n  [CODES.INCORRECT_GCM_SENDER_ID]:\n    \"Please change your web app manifest's \" +\n    \"'gcm_sender_id' value to '103953800507' to use Firebase messaging.\",\n  [CODES.BAD_SCOPE]:\n    'The service worker scope must be a string with at ' +\n    'least one character.',\n  [CODES.BAD_VAPID_KEY]:\n    'The public VAPID key must be a string with at ' + 'least one character.',\n  [CODES.BAD_SUBSCRIPTION]:\n    'The subscription must be a valid ' + 'PushSubscription.',\n  [CODES.BAD_TOKEN]:\n    'The FCM Token used for storage / lookup was not ' +\n    'a valid token string.',\n  [CODES.BAD_PUSH_SET]:\n    'The FCM push set used for storage / lookup was not ' +\n    'not a valid push set string.',\n  [CODES.FAILED_DELETE_VAPID_KEY]: 'The VAPID key could not be deleted.'\n};\n\nexport default {\n  codes: CODES,\n  map: ERROR_MAP\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/models/errors.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nconst FCM_APPLICATION_SERVER_KEY = [\n  0x04,\n  0x33,\n  0x94,\n  0xf7,\n  0xdf,\n  0xa1,\n  0xeb,\n  0xb1,\n  0xdc,\n  0x03,\n  0xa2,\n  0x5e,\n  0x15,\n  0x71,\n  0xdb,\n  0x48,\n  0xd3,\n  0x2e,\n  0xed,\n  0xed,\n  0xb2,\n  0x34,\n  0xdb,\n  0xb7,\n  0x47,\n  0x3a,\n  0x0c,\n  0x8f,\n  0xc4,\n  0xcc,\n  0xe1,\n  0x6f,\n  0x3c,\n  0x8c,\n  0x84,\n  0xdf,\n  0xab,\n  0xb6,\n  0x66,\n  0x3e,\n  0xf2,\n  0x0c,\n  0xd4,\n  0x8b,\n  0xfe,\n  0xe3,\n  0xf9,\n  0x76,\n  0x2f,\n  0x14,\n  0x1c,\n  0x63,\n  0x08,\n  0x6a,\n  0x6f,\n  0x2d,\n  0xb1,\n  0x1a,\n  0x95,\n  0xb0,\n  0xce,\n  0x37,\n  0xc0,\n  0x9c,\n  0x6e\n];\n\nconst SUBSCRIPTION_DETAILS = {\n  userVisibleOnly: true,\n  applicationServerKey: new Uint8Array(FCM_APPLICATION_SERVER_KEY)\n};\n\nexport default {\n  ENDPOINT: 'https://fcm.googleapis.com',\n  APPLICATION_SERVER_KEY: FCM_APPLICATION_SERVER_KEY,\n  SUBSCRIPTION_OPTIONS: SUBSCRIPTION_DETAILS\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/models/fcm-details.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '../../app/errors';\n\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nconst FCM_TOKEN_DETAILS_DB = 'fcm_token_details_db';\nconst FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nconst FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nexport default class TokenManager {\n  private errorFactory_: ErrorFactory<string>;\n  private openDbPromise_: Promise<IDBDatabase>;\n\n  constructor() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n  openDatabase_() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise((resolve, reject) => {\n      const request = indexedDB.open(\n        FCM_TOKEN_DETAILS_DB,\n        FCM_TOKEN_DETAILS_DB_VERSION\n      );\n      request.onerror = event => {\n        reject((<IDBRequest>event.target).error);\n      };\n      request.onsuccess = event => {\n        resolve((<IDBRequest>event.target).result);\n      };\n      request.onupgradeneeded = event => {\n        var db = (<IDBRequest>event.target).result;\n\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n\n    return this.openDbPromise_;\n  }\n\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n  closeDatabase() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(db => {\n        db.close();\n        this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n  getTokenDetailsFromToken(fcmToken) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const index = objectStore.index('fcmToken');\n        const request = index.get(fcmToken);\n        request.onerror = function(event) {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = function(event) {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getTokenDetailsFromSWScope_(swScope) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const scopeRequest = objectStore.get(swScope);\n        scopeRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        scopeRequest.onsuccess = event => {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getAllTokenDetailsForSenderId_(senderId): Promise<Array<Object>> {\n    return this.openDatabase_().then(db => {\n      return new Promise<Array<Object>>((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n\n        const senderIdTokens = [];\n\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        cursorRequest.onsuccess = event => {\n          const cursor = (<IDBRequest>event.target).result;\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  }\n\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  subscribeToFCM(senderId, subscription, pushSet?): Promise<Object> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmSubscribeBody =\n      `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (pushSet) {\n      fcmSubscribeBody += `&pushSet=${pushSet}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n\n    return fetch(\n      FCMDetails.ENDPOINT + '/fcm/connect/subscribe',\n      subscribeOptions\n    )\n      .then(response => response.json())\n      .then(response => {\n        const fcmTokenResponse = response;\n        if (fcmTokenResponse['error']) {\n          const message = fcmTokenResponse['error']['message'];\n          throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n            message: message\n          });\n        }\n\n        if (!fcmTokenResponse['token']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN\n          );\n        }\n\n        if (!fcmTokenResponse['pushSet']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET\n          );\n        }\n\n        return {\n          token: fcmTokenResponse['token'],\n          pushSet: fcmTokenResponse['pushSet']\n        };\n      });\n  }\n\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n  isSameSubscription_(subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return (\n      subscription.endpoint === masterTokenDetails['endpoint'] &&\n      arrayBufferToBase64(subscription['getKey']('auth')) ===\n        masterTokenDetails['auth'] &&\n      arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n        masterTokenDetails['p256dh']\n    );\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n  saveTokenDetails_(\n    senderId,\n    swRegistration,\n    subscription,\n    fcmToken,\n    fcmPushSet\n  ) {\n    const details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const request = objectStore.put(details);\n        request.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = event => {\n          resolve();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n  getSavedToken(senderId, swRegistration) {\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId)\n      .then(allTokenDetails => {\n        if (allTokenDetails.length === 0) {\n          return;\n        }\n\n        const index = allTokenDetails.findIndex(tokenDetails => {\n          return (\n            swRegistration.scope === tokenDetails['swScope'] &&\n            senderId === tokenDetails['fcmSenderId']\n          );\n        });\n\n        if (index === -1) {\n          return;\n        }\n\n        return allTokenDetails[index];\n      })\n      .then(tokenDetails => {\n        if (!tokenDetails) {\n          return;\n        }\n\n        return swRegistration.pushManager\n          .getSubscription()\n          .catch(err => {\n            throw this.errorFactory_.create(\n              Errors.codes.GET_SUBSCRIPTION_FAILED\n            );\n          })\n          .then(subscription => {\n            if (\n              subscription &&\n              this.isSameSubscription_(subscription, tokenDetails)\n            ) {\n              return tokenDetails['fcmToken'];\n            }\n          });\n      });\n  }\n\n  /**\n   * Creates a new FCM token.\n   */\n  createToken(senderId, swRegistration): Promise<String> {\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    // Check for existing subscription first\n    let subscription;\n    let fcmTokenDetails;\n    return swRegistration.pushManager\n      .getSubscription()\n      .then(subscription => {\n        if (subscription) {\n          return subscription;\n        }\n\n        return swRegistration.pushManager.subscribe(\n          FCMDetails.SUBSCRIPTION_OPTIONS\n        );\n      })\n      .then(sub => {\n        subscription = sub;\n        return this.subscribeToFCM(senderId, subscription);\n      })\n      .then(tokenDetails => {\n        fcmTokenDetails = tokenDetails;\n        return this.saveTokenDetails_(\n          senderId,\n          swRegistration,\n          subscription,\n          fcmTokenDetails['token'],\n          fcmTokenDetails['pushSet']\n        );\n      })\n      .then(() => fcmTokenDetails['token']);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n  deleteToken(token) {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN)\n      );\n    }\n\n    return this.getTokenDetailsFromToken(token).then(details => {\n      if (!details) {\n        throw this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return this.openDatabase_().then(db => {\n        return new Promise((resolve, reject) => {\n          const transaction = db.transaction(\n            [FCM_TOKEN_OBJ_STORE],\n            'readwrite'\n          );\n          const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          const request = objectStore.delete(details['swScope']);\n          request.onerror = event => {\n            reject((<IDBRequest>event.target).error);\n          };\n          request.onsuccess = event => {\n            if ((<IDBRequest>event.target).result === 0) {\n              reject(\n                this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN)\n              );\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/models/token-manager.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '../../app/errors';\nimport Errors from '../models/errors';\nimport TokenManager from '../models/token-manager';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\n\nconst SENDER_ID_OPTION_NAME = 'messagingSenderId';\n\nexport default class ControllerInterface {\n  public app;\n  public INTERNAL;\n  protected errorFactory_;\n  private messagingSenderId_: string;\n  private tokenManager_: TokenManager;\n\n  /**\n   * An interface of the Messaging Service API\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n\n    if (\n      !app.options[SENDER_ID_OPTION_NAME] ||\n      typeof app.options[SENDER_ID_OPTION_NAME] !== 'string'\n    ) {\n      throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n    }\n\n    this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n\n    this.tokenManager_ = new TokenManager();\n\n    this.app = app;\n    this.INTERNAL = {};\n    this.INTERNAL.delete = () => this.delete;\n  }\n\n  /**\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise that\n   * resolves to an FCM token.\n   */\n  getToken() {\n    // Check with permissions\n    const currentPermission = this.getNotificationPermission_();\n    if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n      if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n        return Promise.reject(\n          this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED)\n        );\n      }\n\n      // We must wait for permission to be granted\n      return Promise.resolve(null);\n    }\n\n    return this.getSWRegistration_().then(registration => {\n      return this.tokenManager_\n        .getSavedToken(this.messagingSenderId_, registration)\n        .then(token => {\n          if (token) {\n            return token;\n          }\n\n          return this.tokenManager_.createToken(\n            this.messagingSenderId_,\n            registration\n          );\n        });\n    });\n  }\n\n  /**\n   * This method deletes tokens that the token manager looks after and then\n   * unregisters the push subscription if it exists.\n   * @export\n   * @param {string} token\n   * @return {Promise<void>}\n   */\n  deleteToken(token) {\n    return this.tokenManager_.deleteToken(token).then(() => {\n      return this.getSWRegistration_()\n        .then(registration => {\n          if (registration) {\n            return registration.pushManager.getSubscription();\n          }\n        })\n        .then(subscription => {\n          if (subscription) {\n            return subscription.unsubscribe();\n          }\n        });\n    });\n  }\n\n  getSWRegistration_(): Promise<ServiceWorkerRegistration> {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }\n\n  //\n  // The following methods should only be available in the window.\n  //\n\n  requestPermission() {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!ServiceWorkerRegistration} registration\n   */\n  useServiceWorker(registration) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver\n   * @param {function(!Error)=} optError\n   * @param {function()=} optCompleted\n   * @return {!function()}\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  //\n  // The following methods are used by the service worker only.\n  //\n\n  /**\n   * @export\n   * @param {function(Object)} callback\n   */\n  setBackgroundMessageHandler(callback) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n  }\n\n  //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n  delete() {\n    this.tokenManager_.closeDatabase();\n  }\n\n  /**\n   * Returns the current Notification Permission state.\n   * @private\n   * @return {string} The currenct permission state.\n   */\n  getNotificationPermission_() {\n    return (Notification as any).permission;\n  }\n\n  /**\n   * @protected\n   * @returns {TokenManager}\n   */\n  getTokenManager() {\n    return this.tokenManager_;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/controllers/controller-interface.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\n// These fields are strings to prevent closure from thinking goog.getMsg\n// should be used to initialise the values\nconst PARAMS = {\n  TYPE_OF_MSG: 'firebase-messaging-msg-type',\n  DATA: 'firebase-messaging-msg-data'\n};\n\n// This value isn't using the TYPE_OF_MSG short hand as closure\n// expects the variable to be defined via goog.getMsg\nconst msgType = {\n  PUSH_MSG_RECEIVED: 'push-msg-received',\n  NOTIFICATION_CLICKED: 'notification-clicked'\n};\n\nconst createNewMsg = (msgType, msgData) => {\n  const message = {\n    [PARAMS.TYPE_OF_MSG]: msgType,\n    [PARAMS.DATA]: msgData\n  };\n  return message;\n};\n\nexport default {\n  PARAMS,\n  TYPES_OF_MSG: msgType,\n  createNewMsg\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/models/worker-page-message.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nexport default {\n  path: '/firebase-messaging-sw.js',\n  scope: '/firebase-cloud-messaging-push-scope'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/models/default-sw.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport DefaultSW from '../models/default-sw';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport { createSubscribe } from '../../app/subscribe';\n\ndeclare const firebase: any;\n\nexport default class WindowController extends ControllerInterface {\n  private registrationToUse_;\n  private manifestCheckPromise_;\n  private messageObserver_;\n  private onMessage_;\n  private tokenRefreshObserver_;\n  private onTokenRefresh_;\n\n  /**\n   * A service that provides a MessagingService instance.\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    super(app);\n\n    /**\n     * @private\n     * @type {ServiceWorkerRegistration}\n     */\n    this.registrationToUse_;\n\n    /**\n     * @private\n     * @type {Promise}\n     */\n    this.manifestCheckPromise_;\n\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n    this.messageObserver_ = null;\n    /**\n     * @private {!firebase.Subscribe} The subscribe function to the onMessage\n     * observer.\n     */\n    this.onMessage_ = createSubscribe(observer => {\n      this.messageObserver_ = observer;\n    });\n\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n    this.tokenRefreshObserver_ = null;\n    this.onTokenRefresh_ = createSubscribe(observer => {\n      this.tokenRefreshObserver_ = observer;\n    });\n\n    this.setupSWMessageListener_();\n  }\n\n  /**\n   * This method returns an FCM token if it can be generated.\n   * The return promise will reject if the browser doesn't support\n   * FCM, if permission is denied for notifications or it's not\n   * possible to generate a token.\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise the\n   * resolves to an FCM token or null if permission isn't granted.\n   */\n  getToken() {\n    // Check that the required API's are available\n    if (!this.isSupported_()) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.UNSUPPORTED_BROWSER)\n      );\n    }\n\n    return this.manifestCheck_().then(() => {\n      return super.getToken();\n    });\n  }\n\n  /**\n   * The method checks that a manifest is defined and has the correct GCM\n   * sender ID.\n   * @private\n   * @return {Promise} Returns a promise that resolves if the manifest matches\n   * our required sender ID\n   */\n  manifestCheck_() {\n    if (this.manifestCheckPromise_) {\n      return this.manifestCheckPromise_;\n    }\n\n    const manifestTag = <HTMLAnchorElement>document.querySelector(\n      'link[rel=\"manifest\"]'\n    );\n    if (!manifestTag) {\n      this.manifestCheckPromise_ = Promise.resolve();\n    } else {\n      this.manifestCheckPromise_ = fetch(manifestTag.href)\n        .then(response => {\n          return response.json();\n        })\n        .catch(() => {\n          // If the download or parsing fails allow check.\n          // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n          return Promise.resolve();\n        })\n        .then(manifestContent => {\n          if (!manifestContent) {\n            return;\n          }\n\n          if (!manifestContent['gcm_sender_id']) {\n            return;\n          }\n\n          if (manifestContent['gcm_sender_id'] !== '103953800507') {\n            throw this.errorFactory_.create(\n              Errors.codes.INCORRECT_GCM_SENDER_ID\n            );\n          }\n        });\n    }\n\n    return this.manifestCheckPromise_;\n  }\n\n  /**\n   * Request permission if it is not currently granted\n   * @export\n   * @returns {Promise} Resolves if the permission was granted, otherwise\n   * rejects\n   */\n  requestPermission() {\n    if ((Notification as any).permission === NOTIFICATION_PERMISSION.granted) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const managePermissionResult = result => {\n        if (result === NOTIFICATION_PERMISSION.granted) {\n          return resolve();\n        } else if (result === NOTIFICATION_PERMISSION.denied) {\n          return reject(\n            this.errorFactory_.create(Errors.codes.PERMISSION_BLOCKED)\n          );\n        } else {\n          return reject(\n            this.errorFactory_.create(Errors.codes.PERMISSION_DEFAULT)\n          );\n        }\n      };\n\n      // The Notification.requestPermission API was changed to\n      // return a promise so now have to handle both in case\n      // browsers stop support callbacks for promised version\n      const permissionPromise = Notification.requestPermission(result => {\n        if (permissionPromise) {\n          // Let the promise manage this\n          return;\n        }\n\n        managePermissionResult(result);\n      });\n\n      if (permissionPromise) {\n        // Prefer the promise version as it's the future API.\n        permissionPromise.then(managePermissionResult);\n      }\n    });\n  }\n\n  /**\n   * This method allows a developer to override the default service worker and\n   * instead use a custom service worker.\n   * @export\n   * @param {!ServiceWorkerRegistration} registration The service worker\n   * registration that should be used to receive the push messages.\n   */\n  useServiceWorker(registration) {\n    if (!(registration instanceof ServiceWorkerRegistration)) {\n      throw this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED);\n    }\n\n    if (typeof this.registrationToUse_ !== 'undefined') {\n      throw this.errorFactory_.create(Errors.codes.USE_SW_BEFORE_GET_TOKEN);\n    }\n\n    this.registrationToUse_ = registration;\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver An observer object\n   * or a function triggered on message.\n   * @param {function(!Error)=} optError Optional A function triggered on\n   * message error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    return this.onMessage_(nextOrObserver, optError, optCompleted);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);\n  }\n\n  /**\n   * Given a registration, wait for the service worker it relates to\n   * become activer\n   * @private\n   * @param  {ServiceWorkerRegistration} registration Registration to wait\n   * for service worker to become active\n   * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker\n   * registration to become active\n   */\n  waitForRegistrationToActivate_(registration) {\n    const serviceWorker =\n      registration.installing || registration.waiting || registration.active;\n\n    return new Promise<ServiceWorkerRegistration>((resolve, reject) => {\n      if (!serviceWorker) {\n        // This is a rare scenario but has occured in firefox\n        reject(this.errorFactory_.create(Errors.codes.NO_SW_IN_REG));\n        return;\n      }\n      // Because the Promise function is called on next tick there is a\n      // small chance that the worker became active or redundant already.\n      if (serviceWorker.state === 'activated') {\n        resolve(registration);\n        return;\n      }\n\n      if (serviceWorker.state === 'redundant') {\n        reject(this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        return;\n      }\n\n      let stateChangeListener = () => {\n        if (serviceWorker.state === 'activated') {\n          resolve(registration);\n        } else if (serviceWorker.state === 'redundant') {\n          reject(this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        } else {\n          // Return early and wait to next state change\n          return;\n        }\n        serviceWorker.removeEventListener('statechange', stateChangeListener);\n      };\n      serviceWorker.addEventListener('statechange', stateChangeListener);\n    });\n  }\n\n  /**\n   * This will regiater the default service worker and return the registration\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    if (this.registrationToUse_) {\n      return this.waitForRegistrationToActivate_(this.registrationToUse_);\n    }\n\n    // Make the registration null so we know useServiceWorker will not\n    // use a new service worker as registrationToUse_ is no longer undefined\n    this.registrationToUse_ = null;\n\n    return navigator.serviceWorker\n      .register(DefaultSW.path, {\n        scope: DefaultSW.scope\n      })\n      .catch(err => {\n        throw this.errorFactory_.create(\n          Errors.codes.FAILED_DEFAULT_REGISTRATION,\n          {\n            browserErrorMessage: err.message\n          }\n        );\n      })\n      .then(registration => {\n        return this.waitForRegistrationToActivate_(registration).then(() => {\n          this.registrationToUse_ = registration;\n\n          // We update after activation due to an issue with Firefox v49 where\n          // a race condition occassionally causes the service work to not\n          // install\n          registration.update();\n\n          return registration;\n        });\n      });\n  }\n\n  /**\n   * This method will set up a message listener to handle\n   * events from the service worker that should trigger\n   * events in the page.\n   *\n   * @private\n   */\n  setupSWMessageListener_() {\n    if (!('serviceWorker' in navigator)) {\n      return;\n    }\n\n    navigator.serviceWorker.addEventListener(\n      'message',\n      event => {\n        if (!event.data || !event.data[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n          // Not a message from FCM\n          return;\n        }\n\n        const workerPageMessage = event.data;\n        switch (workerPageMessage[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n          case WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED:\n          case WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED:\n            const pushMessage =\n              workerPageMessage[WorkerPageMessage.PARAMS.DATA];\n            this.messageObserver_.next(pushMessage);\n            break;\n          default:\n            // Noop.\n            break;\n        }\n      },\n      false\n    );\n  }\n\n  /**\n   * Checks to see if the required API's are valid or not.\n   * @private\n   * @return {boolean} Returns true if the desired APIs are available.\n   */\n  isSupported_() {\n    return (\n      'serviceWorker' in navigator &&\n      'PushManager' in window &&\n      'Notification' in window &&\n      'fetch' in window &&\n      ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n      PushSubscription.prototype.hasOwnProperty('getKey')\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/controllers/window-controller.ts","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport FCMDetails from '../models/fcm-details';\n\nconst FCM_MSG = 'FCM_MSG';\n\nexport default class SWController extends ControllerInterface {\n  private bgMessageHandler_: (input: Object) => Promise<any>;\n\n  constructor(app) {\n    super(app);\n\n    self.addEventListener('push', e => this.onPush_(e), false);\n    self.addEventListener(\n      'pushsubscriptionchange',\n      e => this.onSubChange_(e),\n      false\n    );\n    self.addEventListener(\n      'notificationclick',\n      e => this.onNotificationClick_(e),\n      false\n    );\n\n    /**\n     * @private\n     * @type {function(Object)|null}\n     */\n    this.bgMessageHandler_ = null;\n  }\n\n  /**\n  * A handler for push events that shows notifications based on the content of\n  * the payload.\n  *\n  * The payload must be a JSON-encoded Object with a `notification` key. The\n  * value of the `notification` property will be used as the NotificationOptions\n  * object passed to showNotification. Additionally, the `title` property of the\n  * notification object will be used as the title.\n  *\n  * If there is no notification data in the payload then no notification will be\n  * shown.\n  * @private\n  */\n  onPush_(event) {\n    let msgPayload;\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    const handleMsgPromise = this.hasVisibleClients_().then(\n      hasVisibleClients => {\n        if (hasVisibleClients) {\n          // Do not need to show a notification.\n          if (msgPayload.notification || this.bgMessageHandler_) {\n            // Send to page\n            return this.sendMessageToWindowClients_(msgPayload);\n          }\n          return;\n        }\n\n        const notificationDetails = this.getNotificationData_(msgPayload);\n        if (notificationDetails) {\n          const notificationTitle = notificationDetails.title || '';\n          return (self as any).registration.showNotification(\n            notificationTitle,\n            notificationDetails\n          );\n        } else if (this.bgMessageHandler_) {\n          return this.bgMessageHandler_(msgPayload);\n        }\n      }\n    );\n\n    event.waitUntil(handleMsgPromise);\n  }\n\n  /**\n  * @private\n  */\n  onSubChange_(event) {\n    const promiseChain = this.getToken().then(token => {\n      if (!token) {\n        // We can't resubscribe if we don't have an FCM token for this scope.\n        throw this.errorFactory_.create(\n          Errors.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE\n        );\n      }\n\n      let tokenDetails = null;\n      const tokenManager = this.getTokenManager();\n      return tokenManager\n        .getTokenDetailsFromToken(token)\n        .then(details => {\n          tokenDetails = details;\n          if (!tokenDetails) {\n            throw this.errorFactory_.create(Errors.codes.INVALID_SAVED_TOKEN);\n          }\n\n          // Attempt to get a new subscription\n          return (self as any).registration.pushManager.subscribe(\n            FCMDetails.SUBSCRIPTION_OPTIONS\n          );\n        })\n        .then(newSubscription => {\n          // Send new subscription to FCM.\n          return tokenManager.subscribeToFCM(\n            tokenDetails.fcmSenderId,\n            newSubscription,\n            tokenDetails.fcmPushSet\n          );\n        })\n        .catch(err => {\n          // The best thing we can do is log this to the terminal so\n          // developers might notice the error.\n          return tokenManager.deleteToken(tokenDetails.fcmToken).then(() => {\n            throw this.errorFactory_.create(\n              Errors.codes.UNABLE_TO_RESUBSCRIBE,\n              {\n                message: err\n              }\n            );\n          });\n        });\n    });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n  * @private\n  */\n  onNotificationClick_(event) {\n    if (\n      !(\n        event.notification &&\n        event.notification.data &&\n        event.notification.data[FCM_MSG]\n      )\n    ) {\n      // Not an FCM notification, do nothing.\n      return;\n    }\n\n    // Prevent other listeners from receiving the event\n    event.stopImmediatePropagation();\n\n    event.notification.close();\n\n    const msgPayload = event.notification.data[FCM_MSG];\n    const clickAction = msgPayload['notification']['click_action'];\n    if (!clickAction) {\n      // Nothing to do.\n      return;\n    }\n\n    const promiseChain = this.getWindowClient_(clickAction)\n      .then(windowClient => {\n        if (!windowClient) {\n          // Unable to find window client so need to open one.\n          return (self as any).clients.openWindow(clickAction);\n        }\n        return windowClient;\n      })\n      .then(windowClient => {\n        if (!windowClient) {\n          // Window Client will not be returned if it's for a third party origin.\n          return;\n        }\n\n        // Delete notification data from payload before sending to the page.\n        const notificationData = msgPayload['notification'];\n        delete msgPayload['notification'];\n\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED,\n          msgPayload\n        );\n        // Attempt to send a message to the client to handle the data\n        // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n        return this.attemptToMessageClient_(windowClient, internalMsg);\n      });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload\n   * @return {NotificationOptions|undefined}\n   */\n  getNotificationData_(msgPayload) {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    const notificationInformation = Object.assign({}, msgPayload.notification);\n    // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n    notificationInformation['data'] = {\n      [FCM_MSG]: msgPayload\n    };\n\n    return notificationInformation;\n  }\n\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   * @export\n   * @param {function(Object)} callback The callback to be called when a push\n   * message is received and a notification must be shown. The callback will\n   * be given the data from the push message.\n   */\n  setBackgroundMessageHandler(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw this.errorFactory_.create(\n        Errors.codes.BG_HANDLER_FUNCTION_EXPECTED\n      );\n    }\n\n    this.bgMessageHandler_ = callback;\n  }\n\n  /**\n   * @private\n   * @param {string} url The URL to look for when focusing a client.\n   * @return {Object} Returns an existing window client or a newly opened\n   * WindowClient.\n   */\n  getWindowClient_(url) {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    const parsedURL = new URL(url).href;\n\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        let suitableClient = null;\n        for (let i = 0; i < clientList.length; i++) {\n          const parsedClientUrl = new URL(clientList[i].url).href;\n          if (parsedClientUrl === parsedURL) {\n            suitableClient = clientList[i];\n            break;\n          }\n        }\n\n        if (suitableClient) {\n          suitableClient.focus();\n          return suitableClient;\n        }\n      });\n  }\n\n  /**\n   * This message will attempt to send the message to a window client.\n   * @private\n   * @param {Object} client The WindowClient to send the message to.\n   * @param {Object} message The message to send to the client.\n   * @returns {Promise} Returns a promise that resolves after sending the\n   * message. This does not guarantee that the message was successfully\n   * received.\n   */\n  attemptToMessageClient_(client, message) {\n    return new Promise((resolve, reject) => {\n      if (!client) {\n        return reject(\n          this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG)\n        );\n      }\n\n      client.postMessage(message);\n      resolve();\n    });\n  }\n\n  /**\n   * @private\n   * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n   * this method will resolve to true, otherwise false.\n   */\n  hasVisibleClients_() {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        return clientList.some(client => client.visibilityState === 'visible');\n      });\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload The data from the push event that should be sent\n   * to all available pages.\n   * @returns {Promise} Returns a promise that resolves once the message\n   * has been sent to all WindowClients.\n   */\n  sendMessageToWindowClients_(msgPayload) {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED,\n          msgPayload\n        );\n\n        return Promise.all(\n          clientList.map(client => {\n            return this.attemptToMessageClient_(client, internalMsg);\n          })\n        );\n      });\n  }\n\n  /**\n   * This will register the default service worker and return the registration.\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    return Promise.resolve((self as any).registration);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/messaging/controllers/sw-controller.ts"],"sourceRoot":""}